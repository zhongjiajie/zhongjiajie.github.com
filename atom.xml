<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhongjiajie&#39;s blog</title>
  
  <subtitle>My personal blog and wiki</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhongjiajie.com/"/>
  <updated>2020-04-21T14:31:08.399Z</updated>
  <id>http://zhongjiajie.com/</id>
  
  <author>
    <name>zhongjiajie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Airflow资源链接&amp;常见问题-持续更新</title>
    <link href="http://zhongjiajie.com/2020/04/21/airflow-faq-and-useful-resource/"/>
    <id>http://zhongjiajie.com/2020/04/21/airflow-faq-and-useful-resource/</id>
    <published>2020-04-21T01:48:05.000Z</published>
    <updated>2020-04-21T14:31:08.399Z</updated>
    
    <content type="html"><![CDATA[<p>使用Apache-Airflow过程中常见问题及解决方案，提供学习Apache-Airflow相关资源，本博文持续更新</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>路走对了就不怕远。这篇博文不是为了替代官网<a href="https://airflow.readthedocs.io/en/latest/faq.html" target="_blank" rel="noopener">FAQ</a>，而是为了补充其内容，或者解决非master分支的问题（大部分人生产中的版本比较旧，部分问题可能仅存在于旧版本中，但master分支已经修复了）。本篇文章不应该含有和官网<a href="https://airflow.readthedocs.io/en/latest/faq.html" target="_blank" rel="noopener">FAQ</a>一样的内容，如果有<a href="http://zhongjiajie.com/about/index.html#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F">请联系作者</a>将其删除。</p><h2 id="关键TIPS"><a href="#关键TIPS" class="headerlink" title="关键TIPS"></a>关键TIPS</h2><ul><li>我应该使用<strong>什么版本的Airflow</strong>，如果你第一次使用Airflow，或者想要调研Airflow解决方案，那推荐直接使用最新版，<code>pip install apache-airlfow</code>。因为Airflow的社区非常活跃，新版本包含了很多有趣的功能且修复了较多的bug。直到Backport Packages发布之前都是推荐新用户使用最新版，Backport Packages发布之后如果有用户想要稳定的生产环境，可以使用Backport Packages版本</li><li>如果你是Airflow的新人，遇到了安装/Tutorial跑不起来等安装类似问题，请先<strong>重启/重试/重装</strong>，一般都能解决问题</li><li>如果你是Airflow的新人，请阅读<a href="https://airflow.readthedocs.io/en/latest" target="_blank" rel="noopener">官网</a>中如下三部分内容: <strong>Tutorial、Qiuck Start、Installation</strong>三部分的内容，及内容部分对应的连接，以上内容通读一遍大概就对Airflow有初步的了解</li><li>有问题请先检查问题是否在官网<a href="https://airflow.readthedocs.io/en/latest/faq.html" target="_blank" rel="noopener">FAQ</a>中已经有答案，如果没有，请去<a href="https://github.com/apache/airflow/issues" target="_blank" rel="noopener">Airflow-Github-issue</a>或<a href="https://issues.apache.org/jira/projects/AIRFLOW/summary" target="_blank" rel="noopener">Airflow-JIRA</a>中查看是否别人也遇到类似问题，及相应的解决方案。之后才是在本博文的<a href="#问题汇总">问题汇总</a>中寻找是否有相似的答案。如果经过了上述过程还不能找到对应的解决方案，才是加入<a href="#相关讨论群">相关讨论群</a>进行讨论。<strong>解决问题的顺序是：官网文档 &gt; 官方ISSUE &gt; 讨论群，而不是反过来遇到问题就找群友帮忙</strong></li></ul><h2 id="相关讨论群"><a href="#相关讨论群" class="headerlink" title="相关讨论群"></a>相关讨论群</h2><!-- TODO 这里不生效 --><style>table th:nth-of-type(2) {    width: 5cm;}</style><table><thead><tr><th align="left">类型</th><th align="left">活跃程度</th><th align="left">谁在支持</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://apache-airflow-slack.herokuapp.com" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/slack-join_chat-white.svg?logo=slack&style=social" alt="Slack Status"></a></td><td align="left">非常活跃</td><td align="left">官方支持</td><td align="left">很多人帮忙解答问题，常用<strong>用户channel</strong><code>#random #newbie-questions #troubleshooting</code>。常用<strong>开发者channel</strong><code>#development #airflow-breeze #airflow-creative</code>。<strong>中国用户channel</strong><code>#users-china</code>。<strong>中文用户讨论没有QQ群活跃</strong>，但本博文强烈建议想深入了解Airflow的进去看看。如果你是首次使用Slack可以参考<a href="https://github.com/zhongjiajie/zhongjiajie.github.com/wiki/How-to-join-airflow-slack-china" target="_blank" rel="noopener">如何加入Airflow slack中国用户频道</a></td></tr><tr><td align="left"><a href="https://shang.qq.com/wpa/qunwpa?idkey=586919e2e4934b7253aba5bbb572409e078f04c7c2523dc475b20edbb7bd6fed" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/QQ%E7%BE%A4-178978627-blue.svg" alt="QQ-Group"></a></td><td align="left">比较活跃</td><td align="left">用户支持</td><td align="left">国内部分Airflow使用者聚集地，较推荐中文用户加入，缺点是500人群，<strong>经常满人</strong></td></tr></tbody></table><h2 id="实用连接"><a href="#实用连接" class="headerlink" title="实用连接"></a>实用连接</h2><style>table th:first-of-type {    width: 2.7cm;}table th:nth-of-type(2) {    width: 1.2cm;}table th:nth-of-type(3) {    width: 1.75cm;}table th:nth-of-type(4) {    width: 1.25cm;}table th:nth-of-type(5) {    width: 4cm;}</style><table><thead><tr><th align="left">资源链接</th><th align="left">更新频率</th><th align="left">谁在支持</th><th align="left">推荐程度</th><th align="left">资源描述</th></tr></thead><tbody><tr><td align="left"><a href="https://airflow.readthedocs.io/en/latest" target="_blank" rel="noopener">Airflow官方文档</a></td><td align="left">频繁更新</td><td align="left">社区支持</td><td align="left">强烈推荐</td><td align="left">官方文档，最全，最新，覆盖最广。因为Airflow是一个<strong>社区驱动</strong>的项目，所以官方文档应该是全值得看的</td></tr><tr><td align="left"><a href="http://airflow.apache.org/blog" target="_blank" rel="noopener">Airflow官网-Blog</a></td><td align="left">频繁更新</td><td align="left">社区支持</td><td align="left">强烈推荐</td><td align="left">Airflow官网的博客，由<strong>Airflow committer维护</strong>，有第一手资料，起步阶段资料还比较少，从1.10.9开始每个release有概览</td></tr><tr><td align="left"><a href="https://www.astronomer.io/guides" target="_blank" rel="noopener">Astronomer-Guides</a></td><td align="left">频繁更新</td><td align="left">商业公司支持</td><td align="left">强烈推荐</td><td align="left"><strong>最值得看的第三方文档</strong> Airflow商业版公司Astronomer（多个<strong>Airflow核心开发者</strong>所在公司）维护的指南，非常值得一看，很多问题可以在上面找到答案</td></tr><tr><td align="left"><a href="https://github.com/apache/airflow/issues" target="_blank" rel="noopener">Airflow-Issue</a></td><td align="left">频繁更新</td><td align="left">社区支持</td><td align="left">推荐</td><td align="left">Airflow项目<strong>官方汇报ISSUE</strong>的地方，可以看看你遇到的问题是不是别人也遇到了，是否已经解决了。2020年3月以前的问题在<a href="https://issues.apache.org/jira/projects/AIRFLOW/summary" target="_blank" rel="noopener">Airflow-JIRA</a>中，<a href="https://lists.apache.org/thread.html/r19014fac5aa2aa15a86890aa438940da263e430cb535ca451ef451a4%40%3Cdev.airflow.apache.org%3E" target="_blank" rel="noopener">mial-list</a>讨论了从JIRA迁移到Github-ISSUE的问题</td></tr><tr><td align="left"><a href="https://github.com/jghoman/awesome-apache-airflow" target="_blank" rel="noopener">awesome-airflow</a></td><td align="left">很少更新</td><td align="left">社区支持</td><td align="left">推荐</td><td align="left">有<strong>Airflow导师</strong><a href="https://github.com/jghoman" target="_blank" rel="noopener">jghoman</a>维护，涵盖简介、最佳实践、部署、相关博客、及商用版供应商等信息</td></tr><tr><td align="left"><a href="https://github.com/apachecn/airflow-doc-zh" target="_blank" rel="noopener">Airflow中文文档</a></td><td align="left">不更新</td><td align="left">社区支持</td><td align="left">推荐</td><td align="left">由<a href="https://github.com/apachecn" target="_blank" rel="noopener">apachecn</a>统筹翻译，仅翻译了<strong>Airflow-1.10.2文档</strong>，如果有兴趣可以和<a href="https://github.com/apachecn" target="_blank" rel="noopener">apachecn</a>沟通进一步翻译别的版本的文档</td></tr><tr><td align="left"><a href="https://cloud.google.com/composer" target="_blank" rel="noopener">Google-Composer</a></td><td align="left">/</td><td align="left">商业公司支持</td><td align="left">了解</td><td align="left">GCP基于Airflow研发的商用版本，和<a href="https://www.astronomer.io/guides" target="_blank" rel="noopener">Astronomer-guides</a>异曲同工，有利于内部公司定制版本的借鉴，Google Composer向Airflow社区贡献并还维护着<a href="https://github.com/apache/airflow-on-k8s-operator" target="_blank" rel="noopener">apache/airflow-on-k8s-operator</a></td></tr></tbody></table><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p>简单对问题汇总的使用/查阅方式做说明</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 这个是说明同时是创建新问题的模板 如果有新的问题需要创建 则复制如下内容到 问题汇总 最后的一个问题 并修改 `常见问题汇总的问题标题（新建问题时需修改该题目）` --&gt;</span></span></span><br><span class="line"><span class="section">### 常见问题汇总的问题标题（新建问题时需修改该题目）</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span><span class="strong">**问题描述：**</span>对该问题的描述</span><br><span class="line"><span class="bullet">* </span><span class="strong">**原因分析：**</span>分析问题出现的原因</span><br><span class="line"><span class="bullet">* </span><span class="strong">**解决方案：**</span>对该问题的解决方案</span><br><span class="line"><span class="bullet">* </span><span class="strong">**社区追踪：**</span>Airflow社区对这个问题的处理，及相关的结果</span><br></pre></td></tr></table></figure><h3 id="DAG表的description字段不支持中文"><a href="#DAG表的description字段不支持中文" class="headerlink" title="DAG表的description字段不支持中文"></a>DAG表的description字段不支持中文</h3><ul><li><p><strong>问题描述：</strong>在没有修改过数据库参数情况下可能存在。当新建DAG文件且其中的description是中文时，会发现新的DAG一直没有被scheduler发现，webserver没有显示，且数据库dag表没有这个dag_id。查看scheduler日志有如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlalchemy.exc.OperationalError: (_mysql_exceptions.OperationalError) (1366, &quot;Incorrect string value: &#39;\\xE4\\xB8\\xAD\\xE6\\x96\\x87...&#39; for column &#39;description&#39; at row 1&quot;)</span><br><span class="line">[SQL: UPDATE dag SET last_scheduler_run&#x3D;%s, description&#x3D;%s WHERE dag.dag_id &#x3D; %s]</span><br><span class="line">[parameters: (datetime.datetime(2020, 4, 21, 14, 26, 50, 786593), &#39;中文测试&#39;, &#39;tutorial&#39;)]</span><br></pre></td></tr></table></figure></li><li><p><strong>原因分析：</strong>数据库编码有误，不支持中文，导致插入数据时报错，但是Airflow页面没有给出提示</p></li><li><p><strong>解决方案：</strong>修改数据库dag表的description字段编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以 MySQL 为例</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> airflow.dag <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> description <span class="built_in">text</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure></li><li><p><strong>社区追踪：</strong>无，但应该要解决</p></li></ul><h3 id="SSHOperator命令在retry和failed的时候不会终结"><a href="#SSHOperator命令在retry和failed的时候不会终结" class="headerlink" title="SSHOperator命令在retry和failed的时候不会终结"></a>SSHOperator命令在retry和failed的时候不会终结</h3><ul><li><p><strong>问题描述：</strong>使用SSHOperator的过程中，当task的状态变成failed或者up_for_retry时，SSHOperator后台进程仍在运行没有终结，按照道理应该是要kill掉进程的</p></li><li><p><strong>原因分析：</strong>这个<strong>不仅仅是SSHOperator的问题</strong>，很多的operator都存在类似的问题，原因是这些operator缺少<code>on_kill</code>方法，导致当这些operator状态变成failed或者超时导致up_for_retry时，executor没有调用对应的operator<code>on_kill</code>方法杀死他</p></li><li><p><strong>解决方案：</strong>修改SSHoperator中的源码，并使用修改后的SSHOperator而不是之前的SSHOperator，以下代码基于airflow-1.10.0源码修改</p><ul><li><p>SSHHook中的修改</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- SSHHook 中增加 kill 方法 --&gt;</span><br><span class="line"><span class="addition">+    def kill(self):</span></span><br><span class="line"><span class="addition">+        self.client.close()</span></span><br></pre></td></tr></table></figure></li><li><p>SSHoperator中的修改</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- SSHoperator 参数修改 增加 get_pty 并默认设置成 True 删除 timeout --&gt;</span><br><span class="line">    @apply_defaults</span><br><span class="line">    def __init__(self,</span><br><span class="line">                 ssh_hook=None,</span><br><span class="line">                 ssh_conn_id=None,</span><br><span class="line">                 remote_host=None,</span><br><span class="line">                 command=None,</span><br><span class="line"><span class="deletion">-                timeout=10,</span></span><br><span class="line"><span class="addition">+                get_pty=True,</span></span><br><span class="line">                 do_xcom_push=False,</span><br><span class="line">                 *args,</span><br><span class="line">                 **kwargs):</span><br><span class="line">        super(SSHOperator, self).__init__(*args, **kwargs)</span><br><span class="line">        self.ssh_hook = ssh_hook</span><br><span class="line">        self.ssh_conn_id = ssh_conn_id</span><br><span class="line">        self.remote_host = remote_host</span><br><span class="line">        self.command = command</span><br><span class="line"><span class="deletion">-       self.timeout = timeout</span></span><br><span class="line"><span class="addition">+       self.get_pty = get_pty</span></span><br><span class="line">        self.do_xcom_push = do_xcom_push</span><br><span class="line"></span><br><span class="line">&lt;!-- SSHoperator 删除通过 command 判断是否 get_pty 的逻辑 --&gt;</span><br><span class="line"><span class="deletion">-           get_pty = False</span></span><br><span class="line"><span class="deletion">-           if self.command.startswith('sudo'):</span></span><br><span class="line"><span class="deletion">-               get_pty = True</span></span><br><span class="line"></span><br><span class="line">&lt;!-- SSHoperator 删除 timeout 的引用 --&gt;</span><br><span class="line">            stdin, stdout, stderr = ssh_client.exec_command(command=self.command,</span><br><span class="line"><span class="deletion">-                                                           get_pty=get_pty</span></span><br><span class="line"><span class="deletion">-                                                           timeout=self.timeout</span></span><br><span class="line"><span class="addition">+                                                           get_pty=self.get_pty</span></span><br><span class="line">                                                            )</span><br><span class="line"></span><br><span class="line"><span class="deletion">-               readq, _, _ = select([channel], [], [], self.timeout)</span></span><br><span class="line"><span class="addition">+               readq, _, _ = select([channel], [], [])</span></span><br><span class="line"></span><br><span class="line">&lt;!-- SSHoperator 中增加 on_kill 方法 调用 SSHHook 中的 kill 方法 --&gt;</span><br><span class="line"><span class="addition">+   def on_kill(self):</span></span><br><span class="line"><span class="addition">+       self.log.debug("Kill ssh process in remote")</span></span><br><span class="line"><span class="addition">+       self.ssh_hook.kill()</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>社区追踪：</strong>有一个Draft PR追踪该问题，该PR通过将BaseOperator的<code>execute</code>和<code>on_kill</code>方法设置成<code>@abstractmethod</code>让继承BaseOperator的全部类都必须含有<code>execute</code>和<code>on_kill</code>方法，详见<a href="https://github.com/apache/airflow/pull/8296" target="_blank" rel="noopener">PR-8296</a></p></li></ul><h3 id="Tree-View页面无法加载"><a href="#Tree-View页面无法加载" class="headerlink" title="Tree View页面无法加载"></a>Tree View页面无法加载</h3><ul><li><strong>问题描述：</strong>如果DAG含有很多的task且已经运行了一段时间，打开webserver中的Tree View时会非常卡，有时甚至会页面奔溃</li><li><strong>原因分析：</strong>从数据库返回浏览器的数据太多，其中包含了较多无用的信息，减少返回的数据有利于降低响应时间</li><li><strong>解决方案：</strong>Airflow-1.10.9之前没有较好的解决方案，只能通过降低配置文件airflow.cfg中的<code>default_dag_run_display_number</code>值来稍微加速，Airflow-1.10.10已经修复了这个问题</li><li><strong>社区追踪：</strong>Airflow社区已经解决了这个问题，参考<a href="https://github.com/apache/airflow/pull/7492" target="_blank" rel="noopener">PR-7492</a>，已经在Airflow-1.10.10中<a href="https://github.com/apache/airflow/blob/c9c336c3fdedee5316d6dde24d604ef84a545139/CHANGELOG.txt#L100" target="_blank" rel="noopener">发布</a>了</li></ul><h3 id="实现DAG之间的依赖"><a href="#实现DAG之间的依赖" class="headerlink" title="实现DAG之间的依赖"></a>实现DAG之间的依赖</h3><ul><li><strong>问题描述：</strong>想实现DAG之间的依赖关系，不知道怎么实现</li><li><strong>原因分析：</strong>无</li><li><strong>解决方案：</strong>目前看到的解决方案主要有三种<ul><li>使用<a href="https://github.com/apache/airflow/blob/master/airflow/operators/subdag_operator.py" target="_blank" rel="noopener">SubDagOperator</a>。因为SubDagOperator可以将DAG文件切分成多个，且能实现依赖关系，相当于实现了DAG间的触发，详细可参考官网的例子。<a href="https://github.com/apache/airflow/blob/master/airflow/example_dags/example_subdag_operator.py" target="_blank" rel="noopener">example_subdag_operator</a>和<a href="https://github.com/apache/airflow/blob/master/airflow/example_dags/subdags/subdag.py" target="_blank" rel="noopener">subdag</a>。但是SubDagOperator本质是一个operator所有有很多局限性，可能出现的问题有：<strong>无并发控制 和 死锁</strong>详细问题见<a href="https://lists.apache.org/thread.html/0aec158c42662370c3e8dc210c1a2b5ec21278d85243e257c174a549%40%3Cdev.airflow.apache.org%3E" target="_blank" rel="noopener">mail-list</a>，这些问题在master分支代码中已经fix了，相关的[PR-5498]，但是一直没有release(截止Airflow-1.10.10都没有)。所以如果想要使用SubDagOperator来实现切分大DAG和DAG间依赖的同学要注意。优点是<strong>能在webserver联动</strong>，可以点击查看SubDagOperator</li><li>使用<a href="https://github.com/apache/airflow/blob/master/airflow/operators/dagrun_operator.py" target="_blank" rel="noopener">TriggerDagRunOperator</a>。这也是个不错的解决方案，没有了SubDagOperator中存在的问题，但<strong>不能监控被触发DAG的状态</strong>，即不知道DAG是成功/失败/运行。这是因为使用<code>trigger_dag</code>方法触发别的DAG，只要触发了就标记task为成功。因为是只是一个Operator，没有放例子</li><li>使用<a href="https://github.com/apache/airflow/blob/master/airflow/providers/http/sensors/http.py" target="_blank" rel="noopener">http-sensors</a>+<a href="https://github.com/apache/airflow/blob/97a429f9d0cf740c5698060ad55f11e93cb57b55/airflow/api/common/experimental/get_dag_run_state.py" target="_blank" rel="noopener">get_dag_run_state</a>API。这里理论可行，博主没有尝试过。SubDagOperator和TriggerDagRunOperator都是上有DAG主动触发下游DAG实现DAG间依赖的，这个方法是下游DAG主动监控上游DAG的状态实现DAG间依赖。<em>实现方式</em>是：下游DAG第一个task必须是http-sensors，调用Airflow自己的API<code>get_dag_run_state</code>，不断监控上游DAG的状态，如果成功才标记http-sensors为成功。但是这个解决方案也有问题，一是需要sensors一直监控（要资源）上游DAG状态（查询也要<strong>浪费资源</strong>），另一个是需要上下游DAG需要有<strong>差不多的schedule_interval</strong>。第一个很好理解，资源问题，第二个是为了保证上游DAG成功时立马调用下游。</li></ul></li></ul><table><thead><tr><th align="left">方案</th><th align="left">优势</th><th align="left">劣势</th></tr></thead><tbody><tr><td align="left">SubDagOperator</td><td align="left">原生支持 能在webserver联动</td><td align="left">无并发控制 死锁 master修复但是没有release</td></tr><tr><td align="left">TriggerDagRunOperator</td><td align="left">原生支持 没有SubDagOperator的问题</td><td align="left">不能监控下游DAG的状态</td></tr><tr><td align="left">http-sensors + get_dag_run_state-API</td><td align="left">原生支持</td><td align="left">schedule_interval需要差不多 资源浪费</td></tr></tbody></table><ul><li><strong>社区追踪：</strong>Airflow社区暂时没有人对DAG间依赖有兴趣，博主也觉得DAG大点没有关系，分类好一点即可解决很多问题。<strong>如果一定要实现</strong>建议基于TriggerDagRunOperator修改，可借鉴第三种方式，让TriggerDagRunOperator触发完后不知里面标记成功，而是一直监控子DAG的状态是否成功。另外最近<a href="https://github.com/xinbinhuang" target="_blank" rel="noopener">bin</a>正在重构SubDagOperator，进度见<a href="https://cwiki.apache.org/confluence/display/AIRFLOW/AIP-34+Refactor+SubDagOperator" target="_blank" rel="noopener">AIP-34 Refactor SubDagOperator</a></li></ul><h3 id="REST触发DAG如何接收参数"><a href="#REST触发DAG如何接收参数" class="headerlink" title="REST触发DAG如何接收参数"></a>REST触发DAG如何接收参数</h3><ul><li><p><strong>问题描述：</strong>使用API不知如何触发DAG，如何接收传入DAG的参数</p></li><li><p><strong>原因分析：</strong>因为官网没有相似例子</p></li><li><p><strong>解决方案：</strong>首先如果触发DAG官网是给了<a href="https://airflow.readthedocs.io/en/latest/rest-api-ref.html#post--api-experimental-dags--DAG_ID--dag_runs" target="_blank" rel="noopener">解决方案</a>的，要注意curl的<code>-d</code>参数是一个字符串，只要这个字符串写正确就肯定能触发DAG（这个字符串确实难写，建议调用时使用调用语言key-value转换字符串封装，如JAVA重写Hashmap的toString，Python重写dict的<strong>str_</strong>）。如何调用的问题解决了，来看看如何在DAG中接收参数。可以使用<code>dag_run.conf[&#39;key&#39;]</code>的方式拿到传进去的键值对。这里给给一个简单的例子，以官方例子POST的，要拿到传入的’key’对应的’value’</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在dag文件中获取 value</span></span><br><span class="line">in_dag_file = dag_run.conf[<span class="string">'key'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在operator中获取 value</span></span><br><span class="line">bash = BashOperator(</span><br><span class="line">    task_id=<span class="string">f'test_<span class="subst">&#123;in_dag_file&#125;</span>'</span>,  <span class="comment"># dag中获取的in_dag_file变量传递给operator</span></span><br><span class="line">    bash_command=<span class="string">'echo "in operator value is &#123;&#123; dag_run.conf['</span>key<span class="string">'] &#125;&#125;"'</span>,</span><br><span class="line">    dag=dag,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>社区追踪：</strong>Airflow社区准备重构REST API<a href="https://cwiki.apache.org/confluence/display/AIRFLOW/AIP-32%3A+Airflow+REST+API" target="_blank" rel="noopener">AIP-32: Airflow REST API</a>，相信到AIP完成的时候不管文档还是易用性应该会有较大提高</p></li></ul><h2 id="我想问的这里没有"><a href="#我想问的这里没有" class="headerlink" title="我想问的这里没有"></a>我想问的这里没有</h2><p>请核对是否按照<a href="#关键TIPS">关键TIPS</a>第三点顺序查找完了且没有相似问题，如果是，你有以下渠道反馈问题，越靠前越推荐</p><ul><li>根据<a href="#帮忙改进文档">帮忙改进文档</a>中的指引，创建PR并在<a href="#问题汇总">问题汇总</a>最后面增加你的问题</li><li>加入<a href="#相关讨论群">相关讨论群</a>寻找问题的解决方案，如果在群中得到解答，且觉得该问题应该包含在博文中，请根据第一点提PR</li><li>在本博文的评论页面增加你想要问的问题</li></ul><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>一个人走可以走得很快，但是一群人能走得更远。如果你在使用Apache-Airflow，觉得这是好的工作流解决方案，且想要丰富其中文资料，参与到这篇博文的建设中，请参考<a href="#帮忙改进文档">帮忙改进文档</a>对文档进行改进。目前的贡献形式仅有合并zhongjiajie这篇博文这一个，如果以后贡献的人变多，或有小伙伴想要将本资料库做大，非常欢迎<a href="http://zhongjiajie.com/about/index.html#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F">联系作者</a>，可以考虑创建一个Github组织专门做这个事。</p><h2 id="帮忙改进文档"><a href="#帮忙改进文档" class="headerlink" title="帮忙改进文档"></a>帮忙改进文档</h2><p>目前形式比较单一且不是太友好，如果帮忙改进文档的人数比较多，会创建新的Github组织，创建特定项目完成这件事，当前的形式如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fork项目https://github.com/zhongjiajie/zhongjiajie.github.com</span></span><br><span class="line"><span class="comment"># 在github中clone本博客源码</span></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 --single-branch --branch <span class="built_in">source</span> https://github.com/&lt;YOUR_GITHUB_ID&gt;/zhongjiajie.github.com.git</span><br><span class="line"><span class="comment"># 找到对应的博文源文件叫 2020-04-21-airflow-faq-and-useful-resource.md</span></span><br><span class="line">ls zhongjiajie.github.com/<span class="built_in">source</span>/_posts/ | grep <span class="string">"2020-04-21-airflow-faq-and-useful-resource.md"</span></span><br><span class="line"><span class="comment"># 使用任意的markdown编辑器打开文件 修改对应的内容 并提交到本地并push到你的origin分支</span></span><br><span class="line"><span class="comment"># 创建PR并将base分支从master修改成source，点击创建 你可能需要参考 https://help.github.com/cn/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request</span></span><br></pre></td></tr></table></figure><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><ul><li>2020-04-17: 起草博文</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Apache-Airflow过程中常见问题及解决方案，提供学习Apache-Airflow相关资源，本博文持续更新&lt;/p&gt;
    
    </summary>
    
    
      <category term="Airflow" scheme="http://zhongjiajie.com/categories/Airflow/"/>
    
    
  </entry>
  
  <entry>
    <title>博客大版本更新</title>
    <link href="http://zhongjiajie.com/2020/03/17/add-domain-name-update-hexo-next/"/>
    <id>http://zhongjiajie.com/2020/03/17/add-domain-name-update-hexo-next/</id>
    <published>2020-03-17T12:08:23.000Z</published>
    <updated>2020-03-24T04:52:12.164Z</updated>
    
    <content type="html"><![CDATA[<p>本次进行了博客大版本更新，其中包括：增加个人域名、更新到最新的NexT主题、更新到了最新的Hexo版本</p><a id="more"></a><h2 id="个人域名"><a href="#个人域名" class="headerlink" title="个人域名"></a>个人域名</h2><p>写博客的时候就有考虑顾是否要买个人域名，当时担心自己只是玩玩，所以一直没有买，现在转眼间已经毕业两年多了，还是想在互联网留下点属于自己的东西，所以近期在万网买了一个域名，从此我也是有域名的人了。哈哈，欢迎大家<a href="http://zhongjiajie.com/">常来看看</a>。如何证明解析已经成功了呢？当你输入github page的地址可以自动跳转到你的域名时就证明成功了。例如我的<a href="zhongjiajie.github.io">zhongjiajie.github.io</a>可以跳转到<a href="http://zhongjiajie.com/">zhongjiajie.com</a>。</p><h2 id="Github和Coding双线部署"><a href="#Github和Coding双线部署" class="headerlink" title="Github和Coding双线部署"></a>Github和Coding双线部署</h2><p>因为使用了个人域名，为Github和Coding双线部署提供了可能。只需要在阿里云解析中配置好CNAME的对应关系，并将Coding的解析线路设置成国内，Github的解析线路设置成境外就能实现境内访问统一使用Coding进行加速，境外的使用Github page服务的功能。同时由于百度不能爬取Github，但是可以爬取Coding，也能为以后网站获取百度流量做准备。由于网上关于Coding怎么搭建静态网站的教程都比较老，我现在（2020年03月19日）放<a href="https://help.coding.net/docs/devops/cd/static-website.html#pageTitle" target="_blank" rel="noopener">Coding官方教程</a>，给有需要的同学。最后放上我云解析DNS的截图，给有需要参考的同学。</p><p><img src="aliyun-dns.png" alt="aliyun-dns"></p><h2 id="更新NexT到最新版"><a href="#更新NexT到最新版" class="headerlink" title="更新NexT到最新版"></a>更新NexT到最新版</h2><p>我的NexT主题已经很久没有更新了，本次直接更新到了github中的master版本，以后会定期更新的，更新文档主要参考了<a href="https://github.com/theme-NexT/Hexo-theme-NexT/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md" target="_blank" rel="noopener">官网的文档</a>，基本仅保留了<code>themen/NexT/_config.yml</code>中的内容，并把修改了的内容记录到<a href="https://github.com/zhongjiajie/zhongjiajie.github.com/blob/source/README.md" target="_blank" rel="noopener">source-README</a>中，以备下次更新可以直接挑选需要的部分更新新的NexT主题中。更新NexT主题的时候发现，如果有太多自定义的样式和效果，更新迁移的时候会带来更多的麻烦，所以我决定以后仅使用NexT中默认的样式，这样才能保证每次更新仅修改<code>themen/NexT/_config.yml</code>文件就能达到目标。将更多的精力专注在内容的本身。</p><h2 id="更新Hexo至最新版"><a href="#更新Hexo至最新版" class="headerlink" title="更新Hexo至最新版"></a>更新Hexo至最新版</h2><p>和NexT主题一样，Hexo框架也很久没有更新了，此次更新了NexT主题的同时也更新了Hexo框架到最新版，方法是使用<code>npm outdated</code>查看最新版本，然后手动修改package.json文件更新到最新版本</p><h2 id="更新了NexT相关组件到最新版"><a href="#更新了NexT相关组件到最新版" class="headerlink" title="更新了NexT相关组件到最新版"></a>更新了NexT相关组件到最新版</h2><p>更新过程如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br><span class="line"><span class="comment"># 将 package.json 中限制版本的 ^ 去掉</span></span><br><span class="line">npm update</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="Google和百度SEO"><a href="#Google和百度SEO" class="headerlink" title="Google和百度SEO"></a>Google和百度SEO</h2><p>买了个人域名自然想到增加网站的曝光度，那就是国内的<a href="https://ziyuan.baidu.com" target="_blank" rel="noopener">百度站长</a>和国外的<a href="https://www.google.com/webmasters" target="_blank" rel="noopener">谷歌站长</a>了。百度使用了<code>hexo-generator-baidu-sitemap</code>以及<code>hexo-baidu-url-submit</code>进行被动的sitemap抓取和主动的推送抓取（这里我把<code>sitemap.xml</code>和<code>baidusitemap.xml</code>都放了进去）。谷歌直接使用sitemap被动抓取，但是由于之前谷歌放了旧网址，所以先要将其删除。</p><h2 id="删除了Hexo-tag"><a href="#删除了Hexo-tag" class="headerlink" title="删除了Hexo-tag"></a>删除了Hexo-tag</h2><p>由于博客内容没有很多，所以删除了标签，直接使用分类对文章进行区分，并且隐藏了页面中的标签页</p><h2 id="切换了主题至Pisces"><a href="#切换了主题至Pisces" class="headerlink" title="切换了主题至Pisces"></a>切换了主题至Pisces</h2><p>不想要太多的动态效果，所以切换了主题到Pisces，这样右侧栏就没有动态效果了</p><h2 id="Gitalk修改成自定义的域名"><a href="#Gitalk修改成自定义的域名" class="headerlink" title="Gitalk修改成自定义的域名"></a>Gitalk修改成自定义的域名</h2><p>修改成了个人域名后gitalk自动创建失效了，通过<a href="https://github.com/gitalk/gitalk/issues/115" target="_blank" rel="noopener">相关ISSUE</a>找到了是因为改了域名导致的，只要将域名进行相应的修改就能重新使用了，修改后的情况如下</p><p><img src="gitalk-self-domain.png" alt="gitalk-self-domain"></p><h2 id="增加了个人twitter和微信在侧边栏"><a href="#增加了个人twitter和微信在侧边栏" class="headerlink" title="增加了个人twitter和微信在侧边栏"></a>增加了个人twitter和微信在侧边栏</h2><p>增加了个人微信在侧边栏。twitter没有怎么玩，但是因为要接触apache社区，所以以开通并且放出来了。久不久登陆上去，顺便学习学习英文。</p><h2 id="创建文章使用英文避免链接encodeRUI编码"><a href="#创建文章使用英文避免链接encodeRUI编码" class="headerlink" title="创建文章使用英文避免链接encodeRUI编码"></a>创建文章使用英文避免链接encodeRUI编码</h2><p>之前的创建文章时都是使用中文，导致最后的连接含有中文会自动转成encodeRUI编码，现在统一使用<code>Hexo new &quot;post-english-name&quot;</code>避免了这样的情况发生</p><h2 id="增加了google-adsence在侧边栏和评论页面结尾"><a href="#增加了google-adsence在侧边栏和评论页面结尾" class="headerlink" title="增加了google adsence在侧边栏和评论页面结尾"></a>增加了google adsence在侧边栏和评论页面结尾</h2><p>想要看看有么有人会点广告，能不能通过卖广告来增加收入，主要是穷……呵呵。主要参考了<a href="http://www.darylliu.cn/archives/6a1f6623.html" target="_blank" rel="noopener">这篇文章</a></p><h2 id="修复了很多之前博客的错误"><a href="#修复了很多之前博客的错误" class="headerlink" title="修复了很多之前博客的错误"></a>修复了很多之前博客的错误</h2><h3 id="图片显示的错误"><a href="#图片显示的错误" class="headerlink" title="图片显示的错误"></a>图片显示的错误</h3><p>之前博客部分图片不能正常显示，也不确定是插件有问题还是路径有问题，升级了NexT新版后已经默认支持本地图片加载了，只需要在Hexo配置文件中配置<code>post_asset_folder: true</code>即可</p><h3 id="删除了重复的文章标题名"><a href="#删除了重复的文章标题名" class="headerlink" title="删除了重复的文章标题名"></a>删除了重复的文章标题名</h3><p>之前每次运行完<code>Hexo new &quot;post-name&quot;</code>之后都会在文章开头加上标题名称，review的时候发现这个操作没有必要，而且会导致vscode的markdown插件提示语法错误，所以全部文章统一删除了首段的标题</p><h3 id="使用正确的多个分类方式"><a href="#使用正确的多个分类方式" class="headerlink" title="使用正确的多个分类方式"></a>使用正确的多个分类方式</h3><p>之前的多个分类方式是错误的，错误的将子分类当成了多个分类，现在已经纠正了，保证了分类页面的准确性</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 之前错误的多分类方式 --&gt;</span></span></span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">  - </span>Blog</span><br><span class="line"><span class="bullet">  - </span>Github</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 正确的多分类方式 --&gt;</span></span></span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">  - </span>[Blog]</span><br><span class="line"><span class="bullet">  - </span>[Github]</span><br></pre></td></tr></table></figure><h3 id="修改了markdown相关的错误"><a href="#修改了markdown相关的错误" class="headerlink" title="修改了markdown相关的错误"></a>修改了markdown相关的错误</h3><p>之前文章存在较多的markdown语法错误，比如多次引用一个<code>#</code>，结尾没有空行，引用代码有误等，现在已经全部修正</p><h3 id="修复local-serach使用algolia-search"><a href="#修复local-serach使用algolia-search" class="headerlink" title="修复local serach使用algolia search"></a><del>修复local serach</del>使用algolia search</h3><p><del>发现local search失效了，现在已经将其修复</del>，不知道为什么local search一直是失效的，使用NexT推荐的第一个搜索algolia search，详细配置见<a href="https://theme-NexT.org/docs/third-party-services/search-services" target="_blank" rel="noopener">NexT-search-services</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次进行了博客大版本更新，其中包括：增加个人域名、更新到最新的NexT主题、更新到了最新的Hexo版本&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://zhongjiajie.com/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>GithubAPI更新导致Gitalk触发持续邮件提醒</title>
    <link href="http://zhongjiajie.com/2020/02/13/GithubAPI%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4Gitalk%E8%A7%A6%E5%8F%91%E6%8C%81%E7%BB%AD%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/"/>
    <id>http://zhongjiajie.com/2020/02/13/GithubAPI%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4Gitalk%E8%A7%A6%E5%8F%91%E6%8C%81%E7%BB%AD%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/</id>
    <published>2020-02-13T07:02:46.000Z</published>
    <updated>2020-03-18T12:18:18.075Z</updated>
    
    <content type="html"><![CDATA[<p>春节这几天持续收到了Github关于部分弃用API的邮件提醒，一天就能收到五六封，但是由于但是没有很好的网络条件没有进行处理，现在回来广州可以进行处理了。</p><a id="more"></a><p><img src="github_api_alter.png" alt="github-api-alter"></p><h2 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h2><p>情况大概是我使用的博客评论系统Gittalk依赖，但是根据<a href="https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api/#authenticating-using-query-parameters" target="_blank" rel="noopener">Github-Deprecated APIs and authentication</a>可以知道Github对参数需求进行了部分修改，该方法已经被弃用了。</p><blockquote><p>GitHub is deprecating password authentication to the API. Instead of using password authentication, create a personal access token using your Personal access tokens settings page in limited situations like testing.</p></blockquote><p>我这边追踪到了<a href="https://github.com/gitalk/gitalk/issues/343" target="_blank" rel="noopener">Gitalk-issue-343</a>以及发现gitalk社区已经追踪到了这个issue并并且大家都给了自己临时的解决方案了，最后看到issue后面跟了一个已经合并了的相关PR，我意识到这个问题可能已经有了比较合理的解决方案<a href="https://github.com/gitalk/gitalk/pull/344" target="_blank" rel="noopener">Gitalk-PR-344</a>以及<a href="https://github.com/gitalk/gitalk/pull/346" target="_blank" rel="noopener">Gitalk-PR-346</a>。并且在<a href="https://github.com/gitalk/gitalk/pull/346" target="_blank" rel="noopener">Gitalk-PR-346</a>中可知，只需要将gitalk升级到v1.5.2就可以了。</p><p><strong>解决方案已经出来了</strong>，就是将hexo-next关于gitalk的的版本升级到1.5.2。</p><p>我去了theme-next/hexo-theme-next的库中查找了相关的issue以及PR，发现了两个相关的PR[hexo-theme-next-PR-1365]以及[hexo-theme-next-PR-1369]，从两个PR中可以知道Gitalk为了应对<a href="https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api/#authenticating-using-query-parameters" target="_blank" rel="noopener">Github-Deprecated APIs and authentication</a>也是经过了多次升级，但是根据我上面所说的</p><blockquote><p><strong>解决方案已经出来了</strong>，就是将hexo-next关于gitalk的的版本升级到1.5.2。</p></blockquote><p>可以知道，只需要将next的gitalk升级成1.5.2就可以了，从[hexo-theme-next-PR-1365]以及[hexo-theme-next-PR-1369]中可以知道next-gitalk相关引用路径在<code>themes/next/layout/_third-party/comment/gitalk.swig</code>,将其中的gitalk-js以及gitalk-css版本升级到1.5.2就行（因为此时的next还没有发布最新的release，只能手动更新）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  &#123;% set gitalk_js_url = "//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js" %&#125;</span></span><br><span class="line"><span class="addition">+  &#123;% set gitalk_js_url = "//cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js" %&#125;</span></span><br><span class="line">  &#123;% if theme.vendors.gitalk_js %&#125;</span><br><span class="line">    &#123;% set gitalk_js_url = theme.vendors.gitalk_js %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;script src="&#123;&#123; gitalk_js_url &#125;&#125;"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  &#123;% set gitalk_css_url = "//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.css" %&#125;</span></span><br><span class="line"><span class="addition">+  &#123;% set gitalk_css_url = "//cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.css" %&#125;</span></span><br><span class="line">  &#123;% if theme.vendors.gitalk_css %&#125;</span><br><span class="line">    &#123;% set gitalk_css_url = theme.vendors.gitalk_css %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;link rel="stylesheet" href="&#123;&#123; gitalk_css_url &#125;&#125;"/&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% set md5_url = "//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js" %&#125;</span><br><span class="line">  &#123;% if theme.vendors.md5 %&#125;</span><br><span class="line">    &#123;% set md5_url = theme.vendors.md5 %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;script src="&#123;&#123; md5_url &#125;&#125;"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">   &lt;script&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: '&#123;&#123; theme.gitalk.client_id &#125;&#125;',</span><br><span class="line">          clientSecret: '&#123;&#123; theme.gitalk.client_secret &#125;&#125;',</span><br><span class="line">          repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;',</span><br><span class="line">          owner: '&#123;&#123; theme.gitalk.github_id &#125;&#125;',</span><br><span class="line">          admin: ['&#123;&#123; theme.gitalk.admin_user &#125;&#125;'],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: '&#123;&#123; theme.gitalk.distraction_free_mode &#125;&#125;'</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render('gitalk-container')</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>之后就是运行命令进行重新的部署</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节这几天持续收到了Github关于部分弃用API的邮件提醒，一天就能收到五六封，但是由于但是没有很好的网络条件没有进行处理，现在回来广州可以进行处理了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://zhongjiajie.com/categories/Blog/"/>
    
      <category term="Github" scheme="http://zhongjiajie.com/categories/Github/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年度总结-在路上</title>
    <link href="http://zhongjiajie.com/2020/02/01/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    <id>http://zhongjiajie.com/2020/02/01/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-%E5%9C%A8%E8%B7%AF%E4%B8%8A/</id>
    <published>2020-02-01T10:50:41.000Z</published>
    <updated>2020-03-18T12:18:23.192Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2020年2月1日，近两天结束了新春的事务(陪嗑瓜子陪聊人生以及修电脑)，原本回穗的计划因为武汉疫情打断。回望春节放假前制定的春节学习计划又泡汤了，赶紧在趁结束把年度总结写了。</p><a id="more"></a><h2 id="2019年回顾"><a href="#2019年回顾" class="headerlink" title="2019年回顾"></a>2019年回顾</h2><h3 id="2019年算是体验了半个创业人的辛酸"><a href="#2019年算是体验了半个创业人的辛酸" class="headerlink" title="2019年算是体验了半个创业人的辛酸"></a>2019年算是体验了半个创业人的辛酸</h3><p>为什么说半个创业人?按照道理我应该算公司的创始人之一，但是和之前工作的感觉也没有太多的差别，春节前我也思考了很久为什么会出现这样的情况，个人总结的原因是–公司决策的参与程度不高。可能是因为公司是直接在客户现场办公，所以一般重要的计划都是跟着客户而变化的原因。也可能是我占的股份不多，导致其实公司开了很多重要的会议，但是没有通知我参加。反正在我看来就是参与公司决策不多，但是我在创业这件事却是事实，所以我只能算是：<strong>半个创业人</strong></p><h3 id="有一定的成长"><a href="#有一定的成长" class="headerlink" title="有一定的成长"></a>有一定的成长</h3><p>今年的相比18年在宏观的方面有了较大的进步，之前的我几乎只关注自己的一亩三分地，19年我更加多的从整个项目的角度，这个团队的家角度，整个业务的角度思考问题。之前的我仅关心自己的sql，数据流程使用按时、正确地得到结果。19年的我</p><ul><li>在完成自己部分任务的同时，还会关注同事的任务进度，在工作中遇到的问题，看看更加有经验的同事是怎么确定里程碑事件的</li><li>除了直接纯粹的写sql的工作中抽厘出来，结合github开源的程序写了数个udf（身份证是否有效 确定生日 性别 行政区（省市））将hive中map类型和字符串间转换 判断电话号码是否有效</li><li>开始写后端的业务代码，基于同事代码结构了基础上，写了部分后端的spring boot的业务代码，并重新规划了测试服务和线上服务的配置及部署区别</li><li>开始接触较大型的开源代码贡献，向 Apache-airflow 开始贡献代码，主要是一些使用中遇到的小bug，以及希望有的小 feature，并成功冲到了 contributors 的第23名</li><li>较为主动的补齐了团队中的短板，发现了公司应用部署还是纯手工的部署，主动承担起编写自动部署脚本的责任。新的团队成员不懂具体的业务逻辑，我会主动的和他解释其中的业务。部分同事之前使用svn，没有接触过git，我为其讲解git的分区及基本的使用。公司需要写对外宣传的PPT，我作为团队中比较熟悉业务和数据的人员，主动承担其了PPT主要的目标部分和业务部分的编写。接到客户新的业务需求，我会主动去和客户进行业务的交流和需求的确认。</li><li>基于之前和客户沟通的业务，我更加懂得在业务的角度思考问题，在和客户讨论新需求的时候，我会站在业务+技术的角色给出必要的建议。这样不仅能够更加明确的确定需求，还能给客户的主观感觉上团队的响应和业务理解更加深刻</li><li>懂得跳出客户的思维思考问题。我是客户需求为主导的公司，之前的印象就是客户需要什么我们提供什么就完事了，但是19年踩了不少坑，发现并不是这么回事。所以19年我逐渐尝试跳出客户的思维思考问题，这里的跳出并不是说不完成客户的需求，而是在他给我们的需求上增加一些可以增加的东西。因为客户给的需求仅仅是想要看看目前的形式下，这样的决策是否有效，这个功能是否能覆盖业务需求。但是既然客户提出了这个想法，他当然是觉得这个需求应该是可以落地的，如果此时做出来的东西不满足客户原先的设想，我会主动去寻找其中的原因，可能是少考虑了部分的条件，可能是参数的设置有问题的，导致最后的结果和预设值背离。</li></ul><h3 id="有一定的不足"><a href="#有一定的不足" class="headerlink" title="有一定的不足"></a>有一定的不足</h3><ul><li>主要的工作还是以写sql为主，对Python以及Java的工程应用方面还是比较薄弱</li><li>从开始贡献开源代码到现在已经快要一年时间，还没贡献太多的核心代码，主要还是在修复已有的bug或者增加部分小的feature，Aiflow有很多AIP提供给开发者提交patch，我不仅没有没有提交对应的代码，甚至很多AIP我都没有去了解</li><li>从部署自动化开始使用较多的shell脚本，但是现在还有很多函数是使用过来就忘记，没有很多的记录和复习方案去专门克服这方面的内容</li><li>由于直接在客户现场办公，很多的会议加上很多的临时需求时常会导致原先设定的周计划泡汤，导致每天基本上是加班的状态，想要晚上补齐之前欠下的计算机基础课程都成了一个难题</li><li>沟通能力有待加强，很多时候我能理解用户的意思，但是表达的时候总会言不达义，导致沟通成本上有所增加，能意简言赅地表达出想要表达的内容是今年的一个目标</li></ul><h2 id="2019年定下的目标及完成的情况"><a href="#2019年定下的目标及完成的情况" class="headerlink" title="2019年定下的目标及完成的情况"></a>2019年定下的目标及完成的情况</h2><p>回顾一下19年定下的目标</p><h3 id="技术展望"><a href="#技术展望" class="headerlink" title="技术展望"></a>技术展望</h3><ul><li><input checked="" disabled="" type="checkbox"> python能从小学生到中学生过度：这个算是成功了一半吧，毕竟我觉得我现在也没能太好的掌握</li><li><input checked="" disabled="" type="checkbox"> java能从新手到小学生过度：真的只是小学生，hello world 级别</li><li><input disabled="" type="checkbox"> <del>希望增强基础理论的学习，如数据结构和基本算法</del>：失败，大大的失败，非常失败</li><li><input disabled="" type="checkbox"> <del>加强hadoop家族尤其是spark的学习，跟上时代的步伐</del>：失败，大大的失败，非常失败</li><li><input disabled="" type="checkbox"> <del>静下心看1-2本进阶的书籍，摆脱小学生的能力</del>：失败，大大的失败，非常失败</li><li><input checked="" disabled="" type="checkbox"> 能热情得投入开源项目的怀抱，积极参加一个较大的开源项目：算成功吧<ul><li>主要贡献了<a href="https://github.com/apache/airflow/commits?author=zhongjiajie&since=2019-01-01&until=2019-12-31" target="_blank" rel="noopener">Apache-airflow</a>，以及aiflow相关的如<a href="https://github.com/apachecn/airflow-doc-zh/commits?author=zhongjiajie&since=2019-01-01&until=2019-12-31" target="_blank" rel="noopener">Aapche-airflow-中文文档</a></li><li>datax自己维护了一个版本fork：<a href="https://github.com/zhongjiajie/DataX/commits?author=zhongjiajie" target="_blank" rel="noopener">zhongjiajie/datax</a></li><li>patch了几个<a href="https://github.com/EbookFoundation/free-programming-books/commits?author=zhongjiajie&since=2019-01-01&until=2019-12-31" target="_blank" rel="noopener">EbookFoundation/free-programming-books</a></li></ul></li><li><input checked="" disabled="" type="checkbox"> 能好好通过wiki积累知识，能通过blog和大家分享我学到的东西：还算成功，目前是每一个月更新一次<a href="https://github.com/zhongjiajie/zhongjiajie.github.com/wiki" target="_blank" rel="noopener">zhongjiajie/wiki</a></li><li><input checked="" disabled="" type="checkbox"> 整理好github的repo，将类似的repo合并，将没有意义的repo删除：已经完成了</li></ul><h3 id="生活展望"><a href="#生活展望" class="headerlink" title="生活展望"></a>生活展望</h3><ul><li><input disabled="" type="checkbox"> <del>热爱我的生活</del>：这个应该说是失败了的，我的19年生活过得一般，工作日是在加班中度过的，周末是在睡懒觉+洗狗+做饭中度过的，没有太多让我热爱的部分</li><li><input disabled="" type="checkbox"> <del>希望能够乐观地对待这个世界，同时也被这世界善待</del>：19年其实……并没有很乐观，唉，可能我是一个悲观的人吧</li><li><input disabled="" type="checkbox"> <del>坚持锻炼，即使每天30分钟也比没有强</del>：一开始是有的，后面就gg了，没有坚持起来，所以这个也是20年的目标</li><li><input disabled="" type="checkbox"> <del>周末不要睡太晚，早点起床即使不学习也可以运运动，买买菜</del>：oh，shit，恩，这个也会是20年的目标</li><li><input disabled="" type="checkbox"> <del>晚上早点睡觉，争取12点前睡着</del>：同上，真是，生活习惯不怎么好呀</li><li><input checked="" disabled="" type="checkbox"> 不求生活给我惊喜，只求它别给我太多惊吓：确实没有惊喜，同时惊吓也是一半而已，可以接受</li></ul><h3 id="理财展望"><a href="#理财展望" class="headerlink" title="理财展望"></a>理财展望</h3><ul><li><input checked="" disabled="" type="checkbox"> 输少当赢：在20年春节前我终于实现了基金翻红。本来应该是20年春节前有较大的盈利的，覆盘的时候发现重要的原因是我在整个19年市场最低的时候，没有多于的资本去加仓，导致整体的持有成本非常高，这个给小伙伴们一个建议，如果想要买基金的话（定投），一定要将资金分配好，不要前期过量的投入，等到市场低点的时候发现没有资本加仓。同时，自己一定要做好现金流的估计，不要将自己挤到进退两难的位置</li><li><input checked="" disabled="" type="checkbox"> 19年年末有存款：虽然仅有一点点，但是还算是有存款</li></ul><h3 id="情感展望"><a href="#情感展望" class="headerlink" title="情感展望"></a>情感展望</h3><ul><li><input checked="" disabled="" type="checkbox"> 希望情感不会被柴米油盐打败：目前还算成功</li><li><input checked="" disabled="" type="checkbox"> 带女朋友见家长，希望双方都喜欢对方：只完成了前面的一半，家人对女票的印象一般，但是我会尽我最大的能力让家人接受女票的</li></ul><h2 id="2020年目标"><a href="#2020年目标" class="headerlink" title="2020年目标"></a>2020年目标</h2><p>20年如果全部的目标都能实现的话，将会有*个里程碑事件：跳槽去较大的本地企业、成为Apache-Airflow committer、买房、养成良好的生活习惯并热爱生活</p><ul><li>跳槽去较大的本地企业：第一个公司base是杭州的to-B企业，现在的公司是和前同事一同创立的企业。第一个公司由于支持不足，要撤离在广州的研发人员，所以和前同事创立了现公司，但是由于规模太小，资金回笼过慢暴露了很多问题，我个人已经决定了将要退出公司去别的公司求职，目前希望公司是base广州的或者广州有较大研发团队的，20年遇到国内疫情，可能HC的数量会少一些，但是也希望可以找到</li><li>成为Apache-Airflow committer：目前已经贡献了23个commit，虽然说有部分是非常小的贡献，显示已经是贡献榜的第23名了，20年的目标是成为committer。也不是说贪慕committer的名头，只是觉得要有一个目标才能更好的努力。我会仔细阅读Airflow-AIP的部分（目前还没有仔细的了解全部的AIP内容），了解下Roadmap，更多的参与社区的讨论和 pull request 的 review 工作，争取提升自己整体认识的同时成为一个得到社区认可的人</li><li>买房：安居才能乐业，我觉得也差不多考虑这个问题的时候了，当然可能资金不够会承压，但是我还是愿意去尝试一下</li><li>养成良好的生活习惯并热爱生活：上了大学以及毕业后的生活习惯确实不怎么好，没有很好的形体、没有日常锻炼、没有早睡早起、没有什么仪式感、不够乐观地看待生活、看待身边的人和事，我认为这是影响人一生的东西，之前没有养成良好的习惯，但是我愿意在我还年轻的时候纠正它，让它朝着美好的方向发展</li></ul><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><ul><li><input disabled="" type="checkbox"> 提高英文读写能力</li><li><input disabled="" type="checkbox"> 跳槽去base本地的大厂</li><li><input disabled="" type="checkbox"> 成为Apache-Airflow committer</li><li><input disabled="" type="checkbox"> HDFS Hive Spark 了解大概并找一个深入研究</li><li><input disabled="" type="checkbox"> 看完&lt;流程的Python&gt;</li><li><input disabled="" type="checkbox"> 挑选着看&lt;Java核心技术卷&gt;</li><li><input disabled="" type="checkbox"> 增加计算机基础课程的补习</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li><input disabled="" type="checkbox"> 抬头挺胸</li><li><input disabled="" type="checkbox"> 坚持锻炼</li><li><input disabled="" type="checkbox"> 早睡早起</li><li><input disabled="" type="checkbox"> 情感不会被柴米油盐打败</li><li><input disabled="" type="checkbox"> 热爱生活本身 过有意义的周末(制定有意义的周末计划)</li><li><input disabled="" type="checkbox"> 存款增加到一定程度，让买房的愿望成为可能</li><li><input disabled="" type="checkbox"> 买房</li><li><input disabled="" type="checkbox"> 拔两个智慧齿</li><li><input disabled="" type="checkbox"> 乐观地对待世界，被这世界善待</li></ul><h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3><ul><li><input disabled="" type="checkbox"> 基金总体能获利10%-20%(在上证3000-3300之间运行 在第一季度开始逐渐抛售 第二季度开始留意政治影响)</li><li><input disabled="" type="checkbox"> 信用卡固额提到230k</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2020年2月1日，近两天结束了新春的事务(陪嗑瓜子陪聊人生以及修电脑)，原本回穗的计划因为武汉疫情打断。回望春节放假前制定的春节学习计划又泡汤了，赶紧在趁结束把年度总结写了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://zhongjiajie.com/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Airflow-钉钉消息dingdingOperator使用</title>
    <link href="http://zhongjiajie.com/2019/07/05/Airflow-%E9%92%89%E9%92%89%E6%B6%88%E6%81%AFdingdingOperator%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhongjiajie.com/2019/07/05/Airflow-%E9%92%89%E9%92%89%E6%B6%88%E6%81%AFdingdingOperator%E4%BD%BF%E7%94%A8/</id>
    <published>2019-07-05T12:04:25.000Z</published>
    <updated>2020-03-18T12:18:28.543Z</updated>
    
    <content type="html"><![CDATA[<p>Airflow 发送钉钉消息的 dingdingOperator 已经随着 <a href="https://airflow.apache.org/changelog.html#airflow-1-10-3-2019-04-09" target="_blank" rel="noopener">Airflow 1.10.3</a> 一起发布了, 有了 dingdingOperator 我们可以在 Airflow 中更优雅地发送钉钉消息,以及 任务 失败 成功 重试 sla过时等的通知.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在较久之前,Airflow对消息系统的支持仅仅是<a href="https://github.com/apache/airflow/blob/master/airflow/operators/email_operator.py" target="_blank" rel="noopener">email</a>以及<a href="https://github.com/apache/airflow/blob/master/airflow/operators/slack_operator.py" target="_blank" rel="noopener">slack</a>.国内习惯使用IM系统作为通知,email一般比较少.slack在国内的普及程度远远没有达到<a href="https://www.dingtalk.com/" target="_blank" rel="noopener">钉钉</a>和<a href="https://weixin.qq.com/" target="_blank" rel="noopener">微信</a>的水平,所以就有了在Airflow中新加钉钉或者微信作为消息通知的功能</p><p>由于我司使用钉钉作为内部通信而非企业微信(好像只有企业微信才开放了webhook?),所以我只给Airflow增加了钉钉的 operator,相关PR在<a href="https://github.com/apache/airflow/pull/4895" target="_blank" rel="noopener">AIRFLOW-1526</a></p><a id="more"></a><h2 id="在没有Airflow-dingdingOperator之前"><a href="#在没有Airflow-dingdingOperator之前" class="headerlink" title="在没有Airflow dingdingOperator之前"></a>在没有Airflow dingdingOperator之前</h2><p>在dingdingOperator没有合并到Airflow master分支之前,网上已经有方案解决Airflow使用钉钉发送消息通知问题</p><ul><li><a href="http://yangcongchufang.com/airflow/airflow-dingding-bot-plugin.html" target="_blank" rel="noopener">Apache-airflow 钉钉机器人插件</a>: 需要入侵Airflow发送email的源码,需要对Airflow的<code>basemodel</code>类(一个非常基础的类)进行修改,增加<code>ding_on_failure</code>以及<code>ding_on_retry</code>,并重新打包代码</li></ul><p>有没有不对源码修改并且能实现发送系统消息的功能呢?答案是肯定的,可以使用Airflow中各种已经定义好了的callback.dingdingOperator正是通过这个方法实现了消息通知的功能的</p><h2 id="dingdingOperator实现原理"><a href="#dingdingOperator实现原理" class="headerlink" title="dingdingOperator实现原理"></a>dingdingOperator实现原理</h2><p>dingdingOperator的实现原理参考了<code>slack_wehook</code>的实现.主要的逻辑都在<code>DingdingHook</code>这个类中,通过继承<code>HttpHook</code>,将用户传过来的消息通过钉钉的webhook进行发送</p><h2 id="dingdingOperator怎么使用"><a href="#dingdingOperator怎么使用" class="headerlink" title="dingdingOperator怎么使用"></a>dingdingOperator怎么使用</h2><p>详情参考<a href="http://airflow.apache.org/howto/operator/dingding.html" target="_blank" rel="noopener">这里</a>,已经默认定义了一个<code>dingding_default</code>作为默认的connection,只需要修改webhook详情就可以了,<strong>注意: 需要将webhook放入<code>password</code>字段中, 且仅仅需要token而不是一整串的webhook</strong></p><p>一般的使用方法为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">text_msg_remind_all = DingdingOperator(</span><br><span class="line">    task_id=<span class="string">'text_msg_remind_all'</span>,</span><br><span class="line">    dingding_conn_id=<span class="string">'dingding_default'</span>,</span><br><span class="line">    message_type=<span class="string">'text'</span>,</span><br><span class="line">    message=<span class="string">'Airflow dingding text message remind all users in group'</span>,</span><br><span class="line">    <span class="comment"># list of user phone/email here in the group</span></span><br><span class="line">    <span class="comment"># when at_all is specific will cover at_mobiles</span></span><br><span class="line">    at_mobiles=[<span class="string">'156XXXXXXXX'</span>, <span class="string">'130XXXXXXXX'</span>],</span><br><span class="line">    at_all=<span class="literal">True</span>,</span><br><span class="line">    dag=dag,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果想要发送富文本内容</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">markdown_msg = DingdingOperator(</span><br><span class="line">    task_id=<span class="string">'markdown_msg'</span>,</span><br><span class="line">    dingding_conn_id=<span class="string">'dingding_default'</span>,</span><br><span class="line">    message_type=<span class="string">'markdown'</span>,</span><br><span class="line">    message=&#123;</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'Airflow dingding markdown message'</span>,</span><br><span class="line">        <span class="string">'text'</span>: <span class="string">'# Markdown message title\n'</span></span><br><span class="line">                <span class="string">'content content .. \n'</span></span><br><span class="line">                <span class="string">'### sub-title\n'</span></span><br><span class="line">                <span class="string">'![logo](http://airflow.apache.org/_images/pin_large.png)'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    at_mobiles=[<span class="string">'156XXXXXXXX'</span>],</span><br><span class="line">    at_all=<span class="literal">False</span>,</span><br><span class="line">    dag=dag,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="支持的消息类型"><a href="#支持的消息类型" class="headerlink" title="支持的消息类型"></a>支持的消息类型</h3><p>目前支持 <code>普通消息</code>, <code>link</code>, <code>markdown</code>, <code>actionCard</code> 和 <code>feedCard</code>, 考虑到用户对普通消息的需求更大,所以将普通消息进行了封装,不必传<code>content</code>关键字,只需要传消息的内容就行</p><h2 id="通过dingdingoperator发送DAG状态的消息"><a href="#通过dingdingoperator发送DAG状态的消息" class="headerlink" title="通过dingdingoperator发送DAG状态的消息"></a>通过dingdingoperator发送DAG状态的消息</h2><p>上面的方法是使用dingdingOperator发送消息,本质是定义了一个dingdingOperator实例化后的task,放在DAG中的某个位置,当上游完全满足条件的时候由scheduler触发这个task.</p><p>但是作为消息通知,更常使用的场景是: 当Airflow中DAG运行到某个状态(task成功 失败 重试等)的时候发送消息通知对应的用户,这种情况就类似与callback函数,它应该作为DAG内部的一部分,而是不是仅仅是一个task.</p><p>这种情况下我们可以使用<code>Task callback</code>,在定义DAG的时候将<code>DingdingOperator</code>传到<code>DAG.default_args</code>的属性中,支持的callback类型包括<code>sla_miss_callback</code>, <code>on_success_callback</code>, <code>on_failure_callback</code>, 或者 <code>on_retry_callback</code>, 下面我们以 <code>on_failure_callback</code> 为例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">args = &#123;</span><br><span class="line">    <span class="string">'owner'</span>: <span class="string">'airflow'</span>,</span><br><span class="line">    <span class="string">'retries'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'start_date'</span>: airflow.utils.dates.days_ago(<span class="number">2</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">failure_callback</span><span class="params">(context)</span>:</span></span><br><span class="line">    message = <span class="string">'AIRFLOW TASK FAILURE TIPS:\n'</span> \</span><br><span class="line">              <span class="string">'DAG:    &#123;&#125;\n'</span> \</span><br><span class="line">              <span class="string">'TASKS:  &#123;&#125;\n'</span> \</span><br><span class="line">              <span class="string">'Reason: &#123;&#125;\n'</span> \</span><br><span class="line">        .format(context[<span class="string">'task_instance'</span>].dag_id,</span><br><span class="line">                context[<span class="string">'task_instance'</span>].task_id,</span><br><span class="line">                context[<span class="string">'exception'</span>])</span><br><span class="line">    <span class="keyword">return</span> DingdingOperator(</span><br><span class="line">        task_id=<span class="string">'dingding_success_callback'</span>,</span><br><span class="line">        dingding_conn_id=<span class="string">'dingding_default'</span>,</span><br><span class="line">        message_type=<span class="string">'text'</span>,</span><br><span class="line">        message=message,</span><br><span class="line">        at_all=<span class="literal">True</span>,</span><br><span class="line">    ).execute(context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args[<span class="string">'on_failure_callback'</span>] = failure_callback</span><br><span class="line"></span><br><span class="line">dag = DAG(</span><br><span class="line">    dag_id=<span class="string">'example_dingding_operator'</span>,</span><br><span class="line">    default_args=args,</span><br><span class="line">    schedule_interval=<span class="string">'@once'</span>,</span><br><span class="line">    dagrun_timeout=timedelta(minutes=<span class="number">60</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上面的例子,当DAG中有task报错时,会触发<code>dingding_success_callback</code>这个task,发送一个钉钉的消息到群中,并且<code>@</code>群里的全部人员.<code>message</code>中对应的信息是通过<code>context</code>获取的</p><p>如果消息中定义更多的类型,可以自行定义,<code>context</code>对象支持的属性有</p><ul><li><a href="https://github.com/apache/airflow/blob/2b366934cdc20e8fb60b4b1e7b6c840a6708b258/airflow/models/taskinstance.py#L1200-L1241" target="_blank" rel="noopener">get_template_context返回的全部类型</a>, 其中有几个比较大的对象是:<ul><li><code>task instance</code>对象,<a href="https://github.com/apache/airflow/blob/2b366934cdc20e8fb60b4b1e7b6c840a6708b258/airflow/models/taskinstance.py#L115-L149" target="_blank" rel="noopener">task_instance有的属性</a></li><li><code>configuration</code>对象,<a href="https://github.com/apache/airflow/blob/master/airflow/configuration.py" target="_blank" rel="noopener">configuration有的属性</a></li><li>数据血缘关系<code>inlets</code>和<code>outlets</code></li></ul></li><li>如果任务失败会还会<a href="https://github.com/apache/airflow/blob/2b366934cdc20e8fb60b4b1e7b6c840a6708b258/airflow/models/taskinstance.py#L1057-L1058" target="_blank" rel="noopener">增加exception属性</a></li></ul><p>以上,希望大家可以更加方便的使用dingding发送系统消息.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Airflow 发送钉钉消息的 dingdingOperator 已经随着 &lt;a href=&quot;https://airflow.apache.org/changelog.html#airflow-1-10-3-2019-04-09&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Airflow 1.10.3&lt;/a&gt; 一起发布了, 有了 dingdingOperator 我们可以在 Airflow 中更优雅地发送钉钉消息,以及 任务 失败 成功 重试 sla过时等的通知.&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在较久之前,Airflow对消息系统的支持仅仅是&lt;a href=&quot;https://github.com/apache/airflow/blob/master/airflow/operators/email_operator.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;email&lt;/a&gt;以及&lt;a href=&quot;https://github.com/apache/airflow/blob/master/airflow/operators/slack_operator.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slack&lt;/a&gt;.国内习惯使用IM系统作为通知,email一般比较少.slack在国内的普及程度远远没有达到&lt;a href=&quot;https://www.dingtalk.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;钉钉&lt;/a&gt;和&lt;a href=&quot;https://weixin.qq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信&lt;/a&gt;的水平,所以就有了在Airflow中新加钉钉或者微信作为消息通知的功能&lt;/p&gt;
&lt;p&gt;由于我司使用钉钉作为内部通信而非企业微信(好像只有企业微信才开放了webhook?),所以我只给Airflow增加了钉钉的 operator,相关PR在&lt;a href=&quot;https://github.com/apache/airflow/pull/4895&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AIRFLOW-1526&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Airflow" scheme="http://zhongjiajie.com/categories/Airflow/"/>
    
    
  </entry>
  
  <entry>
    <title>Airflow 用户指南</title>
    <link href="http://zhongjiajie.com/2019/04/05/Airflow-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"/>
    <id>http://zhongjiajie.com/2019/04/05/Airflow-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/</id>
    <published>2019-04-05T11:35:36.000Z</published>
    <updated>2020-03-18T04:00:47.043Z</updated>
    
    <content type="html"><![CDATA[<p>Airflow用户指南,基于<a href="https://github.com/zhongjiajie/zhongjiajie.github.com/wiki/Airflow-user" target="_blank" rel="noopener">我的wiki</a>提炼出来的内容,简单描述了使用Airflow过程中有什么注意事项及需要关注的点</p><a id="more"></a><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p><strong>根据<a href="https://github.com/apache/airflow/pull/4779#issuecomment-473930751" target="_blank" rel="noopener">committer成员的讨论</a>,更加推荐使用位操作符(bitwise operators)来解决依赖</strong></p><ul><li><p>最原始的方式<code>task.set_upstream(task1); task.set_downstream(task2)</code></p></li><li><p>位操作(bitwise operators)方式,airflow1.8之后<code>task &gt;&gt; task1; task &lt;&lt; task1; task &gt;&gt; task1 &lt;&lt; task2</code></p><ul><li>DAG的位操作符号可以提供更多的功能: <code>t1 &gt;&gt; [t2, t3] &gt;&gt; t4</code>已经能被支持了</li></ul></li><li><p><del>使用<code>chain</code>方法实现多个task的依次依赖</del>(Airflow 1.10.3已经取消<code>chain</code>方法)</p><ul><li><p><del>chain的一般使用</del></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow.utils.helpers <span class="keyword">import</span> chain</span><br><span class="line">chain(task, task1, task2)</span><br></pre></td></tr></table></figure></li><li><p><del>通过列表解析直接生成task列表然后chain起来</del></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow.utils.helpers <span class="keyword">import</span> chain</span><br><span class="line">ds_true = [DummyOperator(task_id=<span class="string">'true_'</span> + str(i), dag=dag) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">chain(cond_true, *ds_true)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一对多的链接关系</p><ul><li><code>t1 &gt;&gt; [t2, t3]</code>(推荐)</li><li><code>group = [task1, task2, task3]; task.set_downstream(group);</code></li></ul></li><li><p>多对一的链接关系</p><ul><li><code>[t1, t2] &gt;&gt; t3</code>(推荐)</li><li><code>group = [task1, task2, task3]; task.set_upstream(group)</code></li></ul></li><li><p>多对多的笛卡尔积</p><ul><li><p><code>airflow.utils.helper.cross_downstream([t1, t2, t3], [t4, t5, t6])</code>(推荐)</p></li><li><p>使用自定义的方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> airflow.utils.helper.chain</span><br><span class="line">group_a=[task1, task2, task3]</span><br><span class="line">group_b=[task4, task5]</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> itertools.product(group_a, group_b):</span><br><span class="line">    chain(*pair)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果有根据一定条件选择下游执行哪个task操作的逻辑,可以使用<code>BranchPythonOperator</code>算子,使用是可以通过<code>TriggerRule.ONE_SUCCESS</code>设置实现.例如<a href="https://github.com/puckel/docker-airflow/issues/301#issuecomment-457076168" target="_blank" rel="noopener">例子</a>A是<code>BranchPythonOperator</code>,一个分支运行B,另一个分支运行C,同时B-&gt;C,这时可以在C中设置<code>TriggerRule.ONE_SUCCESS</code>.以前我总认为一个该<a href="https://github.com/puckel/docker-airflow/issues/301#issuecomment-457058866" target="_blank" rel="noopener">这样</a>实现,会多个两个算子</p></li></ul><h2 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h2><ul><li>使用Airflow内置的日期宏<ul><li>airflow内置了部分时间相关的参数,如<code> '{{ ds }}' </code><br>代表运行的时间,<code> '{{ yesterday_ds }}' </code><br>运行时间昨天的日期,更多时间相关的参数见<a href="https://airflow.apache.org/code.html#default-variables" target="_blank" rel="noopener">这里</a></li></ul></li><li>自定义时间参数<ul><li>简单的时间操作: 通过<code>replace</code>完成,获取运行日期同时改变成特殊的时间<code> some_command.sh {{ execution_date.replace(day=1) }} </code></li><li>通过<code>macros</code>对时间进行更多操作: <code>macros.ds_add</code>将内置时间进行计算<code> '{{ macros.ds_add(ds, 1) }}' </code></li></ul></li></ul><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>作为一个工作流工具,除了完成各种复杂的上下游关系外,我认为解决资源的限制也是很重要的点.资源限制包括限制DAG的并发,限制多个DAG的运行关系.限制同一个/同一类Task的并发</p><h3 id="DAG的限制"><a href="#DAG的限制" class="headerlink" title="DAG的限制"></a>DAG的限制</h3><ul><li><p>限制dag并行实例数量</p><ul><li><p>在<code>airflow.cfg</code>的<code>[core]</code>设置<code>dag_concurrency</code>限制并行数量</p></li><li><p>在DAG文件中限制</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> DAG</span><br><span class="line"></span><br><span class="line">default_args = &#123;</span><br><span class="line">    <span class="string">'owner'</span>: <span class="string">'airflow'</span>,</span><br><span class="line">    <span class="comment"># here to set value</span></span><br><span class="line">    <span class="string">'concurrency'</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dag = DAG(</span><br><span class="line">    <span class="string">'tutorial'</span>,</span><br><span class="line">    default_args=default_args,</span><br><span class="line">    description=<span class="string">'A simple tutorial DAG'</span>,</span><br><span class="line">    schedule_interval=timedelta(days=<span class="number">1</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Task的限制"><a href="#Task的限制" class="headerlink" title="Task的限制"></a>Task的限制</h3><ul><li>限制task的并行数量: operetor中的参数<code>task_concurrency</code>可以设置task的并行数量</li><li>限制多个不同类型的task并行数量: operetor中的参数<code>pool</code>限制一类task的并行数量,与<code>task_concurrency</code>参数的区别是<code>task_concurrency</code>设置的是同一个task的并行数task_id要相同,<code>pool</code>设置的是一类task的并行数task_id可以不同,只要保证<code>pool</code>参数的名称相同就可以.设置后并行的task不会超过<code>pool</code>对象的<code>slots</code>值</li></ul><h2 id="将Airflow中的对象通过DAG或者脚本的方式进行保存"><a href="#将Airflow中的对象通过DAG或者脚本的方式进行保存" class="headerlink" title="将Airflow中的对象通过DAG或者脚本的方式进行保存"></a>将Airflow中的对象通过DAG或者脚本的方式进行保存</h2><h3 id="connection-variables-pool"><a href="#connection-variables-pool" class="headerlink" title="connection variables pool"></a>connection variables pool</h3><p>目前Airflow创建connection variables pool能通过如下方式创建:</p><ul><li>Airflow的cli命令创建,对应命令分别为: <code>airflow connections --add</code> <code>airflow variables -s</code> <code>airflow pools -s</code></li><li>Airflow的web UI页面进行设置,分别为: <code>Admin -&gt; connections</code> <code>Admin -&gt; variables</code> <code>Admin -&gt; pools</code></li></ul><p>这里提供一个将connection variables pool固定到DAG的方法,查看<a href="https://github.com/puckel/docker-airflow/issues/323" target="_blank" rel="noopener">这里</a>.主要是之前使用docker-airflow每次重启时都会清空postgre数据,这样能保证connection variables pool能被git进行版本管理,下面以<code>connections</code>的创建为例子,进行说明</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># conf.py</span></span><br><span class="line">var = &#123;</span><br><span class="line">    <span class="string">'connections'</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'conn_id'</span>: <span class="string">'ssh_my_own_1'</span>,</span><br><span class="line">            <span class="string">'conn_type'</span>: <span class="string">'ssh'</span>,</span><br><span class="line">            <span class="string">'host'</span>: <span class="string">'127.0.0.2'</span>,</span><br><span class="line">            <span class="string">'port'</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="string">'login'</span>: <span class="string">'root'</span>,</span><br><span class="line">            <span class="string">'password'</span>: <span class="string">'pwd'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'conn_id'</span>: <span class="string">'ssh_my_own_2'</span>,</span><br><span class="line">            <span class="string">'conn_type'</span>: <span class="string">'ssh'</span>,</span><br><span class="line">            <span class="string">'host'</span>: <span class="string">'127.0.0.3'</span>,</span><br><span class="line">            <span class="string">'port'</span>: <span class="number">22</span>,</span><br><span class="line">            <span class="string">'login'</span>: <span class="string">'root'</span>,</span><br><span class="line">            <span class="string">'password'</span>: <span class="string">'pwd'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># init_conn_var.py</span></span><br><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> DAG, Connection</span><br><span class="line"><span class="keyword">from</span> airflow.setting <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> airflow.operators.python_operator <span class="keyword">import</span> PythonOperator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crt_airflow_conn</span><span class="params">(conf)</span>:</span></span><br><span class="line">    conn = Connection()</span><br><span class="line">    conn.conn_id = conf.get(<span class="string">'conn_id'</span>)</span><br><span class="line">    conn.conn_type = conf.get(<span class="string">'conn_type'</span>)</span><br><span class="line">    conn.host = conf.get(<span class="string">'host'</span>)</span><br><span class="line">    conn.port = conf.get(<span class="string">'port'</span>)</span><br><span class="line">    conn.login = conf.get(<span class="string">'login'</span>)</span><br><span class="line">    conn.password = conf.get(<span class="string">'password'</span>)</span><br><span class="line">    conn.schema = conf.get(<span class="string">'schema'</span>)</span><br><span class="line">    conn.extra = conf.get(<span class="string">'extra'</span>)</span><br><span class="line"></span><br><span class="line">    session = Session()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exists_conn = session.query(Connection.conn_id == conn.conn_id).one()</span><br><span class="line">    <span class="keyword">except</span> exc.NoResultFound:</span><br><span class="line">        logging.info(<span class="string">'connection not exists, will create it.'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.info(<span class="string">'connection exists, will delete it before create.'</span>)</span><br><span class="line">        session.delete(exists_conn)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        session.add(conn)</span><br><span class="line">        session.commit()</span><br><span class="line">    session.close()</span><br><span class="line"></span><br><span class="line">dag = DAG(</span><br><span class="line">    dag_id=<span class="string">'create_conn'</span>,</span><br><span class="line">    schedule_interval=<span class="string">'@once'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> connection <span class="keyword">in</span> conf.get(<span class="string">'connection'</span>):</span><br><span class="line">    crt_conn = PythonOperator(</span><br><span class="line">        task_id=<span class="string">'create_conn_&#123;&#125;'</span>.format(connection.get(<span class="string">'conn_id'</span>)),</span><br><span class="line">        pyhton_callable=crt_airflow_conn,</span><br><span class="line">        op_kwargs=&#123;<span class="string">'conf'</span>: connection&#125;,</span><br><span class="line">        provide_context=<span class="literal">False</span>,</span><br><span class="line">        dag=dag,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="用户创建"><a href="#用户创建" class="headerlink" title="用户创建"></a>用户创建</h3><ul><li><p>通过Airflow UI页面进行创建<code>Airflow -&gt; Admin -&gt; User</code>,目前创建补支持密码</p></li><li><p>使用cli命令行进行用户创建<code>airflow create_user -r &lt;ROLE&gt; -u &lt;USERNAME&gt; -e &lt;EMAIL&gt; -p &lt;PASSWORD&gt;</code></p></li><li><p>通过自定义脚本实现,将如下脚本放到<code>AIRFLOW_HOME</code>中,当需要创建用户的时候可以运行脚本进行交互式的创建</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> airflow</span><br><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> models, settings</span><br><span class="line"><span class="keyword">from</span> airflow.contrib.auth.backends.password_auth <span class="keyword">import</span> PasswordUser</span><br><span class="line"></span><br><span class="line">IS_CORRECT = <span class="string">"Y"</span></span><br><span class="line">HINT_THIS_SCRIPT = <span class="string">"\nhint!!\n==&gt; YOU RUN THIS SCRIPT TO CREATE AIRFLOW USER NOW\n"</span></span><br><span class="line">HINT_USER = <span class="string">"Please enter username you want to create: "</span></span><br><span class="line">HINT_EMAIL_WITH_USER = <span class="string">"Please enter email for user `&#123;username&#125;`: "</span></span><br><span class="line">HINT_PASSWORD_WITH_USER = <span class="string">"Please enter password for user `&#123;username&#125;`: "</span></span><br><span class="line">HINT_CONFIRM_USER_PASSWORD = <span class="string">"\nhint!! &gt; you want to add user `&#123;username&#125;` with email `&#123;email&#125;`\n"</span> \</span><br><span class="line">    <span class="string">"enter 'Y/y' to confirm the information\nor enter other key to reinput information\n&gt;&gt; "</span></span><br><span class="line"></span><br><span class="line">user = PasswordUser(models.User())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(HINT_THIS_SCRIPT)</span><br><span class="line">    user.username = input(HINT_USER)</span><br><span class="line">    user.email = input(HINT_EMAIL_WITH_USER.format(username=user.username))</span><br><span class="line">    user.password = getpass.getpass(HINT_PASSWORD_WITH_USER.format(username=user.username))</span><br><span class="line">    correct = input(HINT_CONFIRM_USER_PASSWORD.format(username=user.username, email=user.email))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> correct.strip().upper() == IS_CORRECT:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">session = settings.Session()</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></li></ul><h2 id="DAG开发流程"><a href="#DAG开发流程" class="headerlink" title="DAG开发流程"></a>DAG开发流程</h2><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li>airflow创建及调试的顺序<ul><li>上传/更新DAG文件</li><li>检测语法有没有错误<code>python &lt;文件名&gt;</code></li><li>使用airflow test运行单个task<code>airflow test DAG_ID TASK_ID execute_date</code></li></ul></li></ul><h2 id="Airflow-operator"><a href="#Airflow-operator" class="headerlink" title="Airflow operator"></a>Airflow operator</h2><p>这里记录几个Airflow里面常用但是比较难理解的operator</p><ul><li><code>BranchPythonOperator</code>: 通过不同的情况运行对应的下游task.通过<code>python_callable</code>参数的返回值确定下游要运行的task,返回值的名称就是要运行task的task_id</li></ul><h2 id="docker-airflow"><a href="#docker-airflow" class="headerlink" title="docker-airflow"></a>docker-airflow</h2><p><strong>update at 2019-04-05</strong>: 已经在我的仓库中创建了<a href="https://github.com/zhongjiajie/docker-airflow" target="_blank" rel="noopener">zhongjiajie/docker-airflow</a>定期将<a href="https://github.com/puckel/docker-airflow" target="_blank" rel="noopener">puckel/docker-airflow</a>中优秀的PR合并到master,上面还有一套我自己使用的环境<a href="https://github.com/zhongjiajie/docker-airflow/tree/custom" target="_blank" rel="noopener">branch-custom</a></p><p>较常用的镜像是<a href="https://github.com/puckel/docker-airflow" target="_blank" rel="noopener">puckel/docker-airflow</a>,这个镜像维护人的热度不高,且<a href="https://github.com/apache/airflow/pull/4483" target="_blank" rel="noopener">airflow官方的docker</a>进行进行,后期可能会不使用这个版本.下面说明他可能存在的问题</p><ul><li>将数据库从postgresql切换到mysql:按照airflow官网的方式直接增加<code>AIRFLOW__CORE__SQL_ALCHEMY_CONN</code>变量没有效果,因为这个repo的<code>scripts/entrypoint.sh</code>有一句<code>AIRFLOW__CORE__SQL_ALCHEMY_CONN=&quot;postgresql+psycopg2://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_HOST:$POSTGRES_PORT/$POSTGRES_DB&quot;</code>指定了数据库的类型和链接信息,即使你在docker-compose指定了<code>AIRFLOW__CORE__SQL_ALCHEMY_CONN</code>也会被<code>scripts/entrypoint.sh</code>覆盖掉,目前比较可取的方法灵感来自是<a href="https://github.com/puckel/docker-airflow/issues/286#issuecomment-450521949" target="_blank" rel="noopener">这个issue的答案</a>,将<code>AIRFLOW__CORE__SQL_ALCHEMY_CONN=&quot;postgresql+psycopg2://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_HOST:$POSTGRES_PORT/$POSTGRES_DB&quot;</code>改成<code>: &quot;${AIRFLOW__CORE__SQL_ALCHEMY_CONN:=&quot;postgresql+psycopg2://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_HOST:$POSTGRES_PORT/$POSTGRES_DB&quot;}&quot;</code></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>自定义operator后发现不能运行但是代码没有问题,有可能是自定义operator中的参数和Airflow内部变量的参数同名,如同<a href="https://stackoverflow.com/questions/52176131/airflow-date-error-dag-normalize-schedule-typeerror" target="_blank" rel="noopener">ariflow date error</a>中的原因,就是因为子自定义的Operator中定义了一个<code>start_date</code>变量,并把变量声明成<code>template_fields</code>导致的错误</li><li>airflow schedule_interval设置了<code>@once</code>之后dag一直hung,是因为<code>airflow.cfg</code>中的<code>catchup_by_default</code>设为了True,或者DAG默认参数设为了True,解决上面的问题,只要设置会正确值重启就可.<a href="https://stackoverflow.com/a/48752253/7152658" target="_blank" rel="noopener">has usage of @once for scheduler interval changed in v1.9</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://segmentfault.com/a/1190000005078547" target="_blank" rel="noopener">解密 Airbnb 的数据流编程神器：Airflow 中的技巧和陷阱</a></li><li><a href="http://dockone.io/article/2845" target="_blank" rel="noopener">DockOne微信分享（一四七）：瓜子云的任务调度系统</a>: 将airflow迁移到k8s上面的思路及主要解决的问题.借助Kubernetes的自动扩展，集群资源统一管理</li><li><a href="http://dockone.io/article/2845" target="_blank" rel="noopener">DockOne微信分享（一四七）：瓜子云的任务调度系统</a></li><li>非常有用,<a href="http://michal.karzynski.pl/blog/2017/03/19/developing-workflows-with-apache-airflow/" target="_blank" rel="noopener">Get started developing workflows with Apache Airflow</a>: install, start, DAG, first Operator, plugin, Debugg Operator, <strong>airflow debug with Ipython.embed</strong>, airflow debug with Pycharm, Sensor and it poke function</li><li><a href="https://www.jianshu.com/p/2ecef979c606" target="_blank" rel="noopener">如何部署一个健壮的 apache-airflow 调度系统</a></li><li><a href="https://102.alibaba.com/detail?id=172" target="_blank" rel="noopener">阿里基于Airflow开发的调度系统maat</a></li><li><a href="https://stackoverflow.com/a/48752253/7152658" target="_blank" rel="noopener">has usage of @once for scheduler interval changed in v1.9</a></li><li><a href="https://github.com/puckel/docker-airflow" target="_blank" rel="noopener">puckel/docker-airflow</a></li><li><a href="https://github.com/apache/airflow/pull/4483" target="_blank" rel="noopener">airflow-pr-Add official dockerfile</a></li><li><a href="https://github.com/puckel/docker-airflow/issues/149" target="_blank" rel="noopener">puckel/docker-airflow issue Example utilizing RDS or other external Postgres instance</a></li><li><a href="https://github.com/puckel/docker-airflow/issues/286#issuecomment-450521949" target="_blank" rel="noopener">puckel/docker-airflow issue non-postgres result_backed is overridden by hardcoded values in entrypoint.sh</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Airflow用户指南,基于&lt;a href=&quot;https://github.com/zhongjiajie/zhongjiajie.github.com/wiki/Airflow-user&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的wiki&lt;/a&gt;提炼出来的内容,简单描述了使用Airflow过程中有什么注意事项及需要关注的点&lt;/p&gt;
    
    </summary>
    
    
      <category term="Airflow" scheme="http://zhongjiajie.com/categories/Airflow/"/>
    
    
  </entry>
  
  <entry>
    <title>如何加入Apache Airflow slack中国用户频道</title>
    <link href="http://zhongjiajie.com/2019/04/04/%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5Apache-Airflow-slack%E4%B8%AD%E5%9B%BD%E7%94%A8%E6%88%B7%E9%A2%91%E9%81%93/"/>
    <id>http://zhongjiajie.com/2019/04/04/%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5Apache-Airflow-slack%E4%B8%AD%E5%9B%BD%E7%94%A8%E6%88%B7%E9%A2%91%E9%81%93/</id>
    <published>2019-04-04T14:09:26.000Z</published>
    <updated>2020-03-18T04:00:43.523Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是介绍如何加入Airflow slack中国用户频道<code>#user-china</code></p><a id="more"></a><h2 id="为什么要加入Airflow-slack-user-china"><a href="#为什么要加入Airflow-slack-user-china" class="headerlink" title="为什么要加入Airflow slack user-china"></a>为什么要加入Airflow slack user-china</h2><p>Apache Airflow 官方的 chat channel 是 slack,里面除了有很多的使用者和代码贡献者外,还有 committer 和 PMC member.在上面问问题能够得到较快且交正确的解答.</p><p>由于 Airflow 在中国不算太流行,所以在看这篇教程之前你可能已经加入了多个微信/QQ群,可能你会问:为什么我还要加入 slack?这个软件我没有用过而且是英文的,我在微信/QQ群已经能得到解答了.我个人认为原因如下:</p><ul><li>官方谈论频道:个人认为这个非常重要,因为Airflow在国内使用并不多,有官方的支持才能保证社区的活跃且不关闭</li><li>讨论更为集中:目前太多的微信/QQ群,导致同一个问题可能在不同的地方被提问,如果集中在一个地方讨论会更加集中,有利于问题的解决</li><li>更多参与者:目前微信/QQ群都是国内的用户,但是在 slack 中可以看看国外大神是怎么使用 Airflow 的,遇到问题是怎么解决的.很多人会从源码层面解释这个问题的原因</li><li>创建了中文频道:由于以上原因,我向PMC成员<a href="https://github.com/ashb" target="_blank" rel="noopener">ashb</a>申请了Airflow中文频道,使用 想要二次开发 或者想要向Airflow共享代码的各位可以加入slack的讨论</li></ul><h2 id="加入的步骤"><a href="#加入的步骤" class="headerlink" title="加入的步骤"></a>加入的步骤</h2><ul><li>浏览器输入<code>https://apache-airflow-slack.herokuapp.com/</code>,跳转到join页面,填入邮箱</li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0tgxs88cej210b0j0n1o.jpg" alt="enter-email"></p><ul><li>点击<code>join</code>,获得提示</li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th0qjzngj20js05hjs5.jpg" alt="check-email-hist"></p><ul><li>登录刚刚填写的邮箱点击<code>join now</code>(可能邮件在垃圾箱)</li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th2svg2fj20p40cm0th.jpg" alt="click-join-now-in-email"></p><ul><li>填写必要信息</li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th3iif2mj21020hgjsk.jpg" alt="enter-info"></p><ul><li>下一步并同意</li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th4ea0m7j21010hdjub.jpg" alt="next-step"></p><ul><li>点击channel搜索</li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th5gs805j21070hfwhh.jpg" alt="click-channel"></p><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th6g987nj20s30gx0tb.jpg" alt="enter-users-china"></p><ul><li>加入<code>users-china</code></li></ul><p><img src="http://ww1.sinaimg.cn/large/775a67e7gy1g0th7yv7mgj20tp0esgnd.jpg" alt="join-users-china"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是介绍如何加入Airflow slack中国用户频道&lt;code&gt;#user-china&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Airflow" scheme="http://zhongjiajie.com/categories/Airflow/"/>
    
    
  </entry>
  
  <entry>
    <title>&#39;工资突然崩塌式下降是什么感受&#39;有感</title>
    <link href="http://zhongjiajie.com/2019/01/17/%E5%B7%A5%E8%B5%84%E7%AA%81%E7%84%B6%E5%B4%A9%E5%A1%8C%E5%BC%8F%E4%B8%8B%E9%99%8D%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%9F%E5%8F%97-%E6%9C%89%E6%84%9F/"/>
    <id>http://zhongjiajie.com/2019/01/17/%E5%B7%A5%E8%B5%84%E7%AA%81%E7%84%B6%E5%B4%A9%E5%A1%8C%E5%BC%8F%E4%B8%8B%E9%99%8D%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%9F%E5%8F%97-%E6%9C%89%E6%84%9F/</id>
    <published>2019-01-17T00:51:33.000Z</published>
    <updated>2020-03-18T04:44:15.706Z</updated>
    
    <content type="html"><![CDATA[<p>今天公交上读到<a href="https://www.zhihu.com/question/280202473/answer/441437975" target="_blank" rel="noopener">工资突然崩塌式下降是什么感受？ - 知乎</a>突然内心涌起波澜.答主毕业时进入与专业对口,大家都羡慕的高薪行业,最要的是如果一直干可以到退休(如果我有这样的工作一定不会放弃,毕竟码农30岁是一个大坎).因为爱情选择了去女友的大城市发展,一开始工资有了提升,但是行业温水主青蛙式崩塌答主全然不知,最后被辞退,歇业了一段时间,当再次找到工作时工资下跌一半</p><a id="more"></a><p>当然,让我感到最沉重的莫过于答主引用陶杰先生的一句话:</p><blockquote><p>当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。  – 陶杰 《杀鹌鹑的少女》</p></blockquote><p>看了看评论,有一句话也非常值得我们去思考:</p><blockquote><p>可能是缺乏战略眼光导致选择失误，最开始年轻选择多容易忽略，尤其是执行力可塑性精明程度都强的情况下，容易自己把棋走死。即使没有跳槽也可能面临类似结局吧。心智模式才是决定因素，所谓行业都是在不断变化，做不得数。 – <a href="https://www.zhihu.com/people/davidhan-58/activities" target="_blank" rel="noopener">David han</a></p></blockquote><p>我最近总在思考一个问题,我30岁后能干什么?我是继续在办公室吹着暖气写着代码,还是在界面吹着冷风卖这煎饼?大三的我,听了几场师兄师姐的建议,决定了以后从事计算机工作,当时我是一个数学系学生.大三老师推荐了一份校企合作的企业,开始了计算机的打怪升级之路,怪打了不少,但是升级没有多少.大四我自己找了份互联网+政务的企业,这个行业有一个特点,就是技术和业务都不是最重要的,最重要的是人脉,有人,就没有做不成的事.可偏偏我就是做技术的(各位别笑,码农也是技术),更为糟糕的是,生活中<a href="https://zhongjiajie.com/2019/01/11/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">一些变化</a>包括辞职,理财失败,给了家人一笔现金等,导致我现金流紧缺.现在正和前同事创业,给的工资比之前高了一点,但是不确定性却高了数倍.加入创业时我认为:<em>没关系,我还年轻,很多东西没有就没有吧</em>.第一次我去介意这种事情的时候是在我去医院看病,听说定点可以增加报销额度,我就定点,工作人员和我说,我的社保卡是<strong>封存</strong>状态不能定点,才想起我已经小半年没有较社保公积金了,如果此时我有什么大病,后果将是不堪设想的,现金流弱+没有医保.(这里一个小插曲,我离职前买了意外险,定寿,重疾,就是没有买医疗险,当我意识到医疗问题的严重性后,想加一款医疗险发现很多都要有社保缴费记录,没有缴费记录的都死贵死贵)</p><p>我就在想,等我30岁,或者更年长的时候看这几个决定,我是什么心态看的?那时的我会悔恨现在的我么?我要怎么做才能减少未来的我对现在的我的悔恨?</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天公交上读到&lt;a href=&quot;https://www.zhihu.com/question/280202473/answer/441437975&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工资突然崩塌式下降是什么感受？ - 知乎&lt;/a&gt;突然内心涌起波澜.答主毕业时进入与专业对口,大家都羡慕的高薪行业,最要的是如果一直干可以到退休(如果我有这样的工作一定不会放弃,毕竟码农30岁是一个大坎).因为爱情选择了去女友的大城市发展,一开始工资有了提升,但是行业温水主青蛙式崩塌答主全然不知,最后被辞退,歇业了一段时间,当再次找到工作时工资下跌一半&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://zhongjiajie.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感悟" scheme="http://zhongjiajie.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年度总结-我还是小学生</title>
    <link href="http://zhongjiajie.com/2019/01/11/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://zhongjiajie.com/2019/01/11/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2019-01-11T14:21:38.000Z</published>
    <updated>2020-03-18T04:00:34.922Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2019年1月11日,这是第一次在github page写年度总结,希望这不是最后一次,希望我能坚持下来.2018年是我毕业一来最为复杂的一年,也是最难的一年.好吧一共毕业才1年半,也验证了<strong>成年人的世界里没有容易</strong>这句话.</p><a id="more"></a><h2 id="2018年历险记"><a href="#2018年历险记" class="headerlink" title="2018年历险记"></a>2018年历险记</h2><p>2018年过完春节,我们搬了家,搬家真是各劳神伤财的活.同时因为公司在长沙拿了一个大项目,同时广州的项目接连没有得到用户的认可,我们base广州的几个人被<strong>建议</strong>去长沙或者回公司base杭州发展.基于很多原因考虑,我和同时都选择了长沙,所以2018年春节可以说是我第一次出省工作的一年.</p><p>长沙给我的印象是风景很美,人很豪爽,交通相对流畅,还有很辣.我在长沙吃了我人生中第一次放了辣椒的西红柿炒蛋…换了新的环境,接触的东西也多了很多,由于项目原因开始解除java,基于spring和dubbo完成的开发.说实在话,对于一个从python sql学起的非科班码农,java显得特别不友好,一开始最抵触的一点就是参数和结果类型的转换问题,经常因为不知道返回值什么类型但是idea一直提示错误(这里不得不说idea是写java很好的ide).幸亏同事比较友善,很乐意帮我解决我对java的疑问.那段期间我渐渐对java有了一些皮毛的了解,可以看得懂简单的代码了.写了其中一部分小功能.</p><p>同时,项目的测试服务器管理放到了我这边,公司有一台外网的测试服务器和四台内网测试服务器,都是从裸机开始搭建的,外网只是用来对外演示用,所以大部分应用,如mysql,zookeeper,rocketmq都是用docker容器+docker-compose部署.期间了写了一键重启docker-compose,一键从gitlab中拉取最新代码更新应用的shell.这大概是我在长沙项目作出的全部贡献了.</p><p>长沙的项目做的是应用的中台,目的是实现应用发布平台,下级部门将建设完后,相关人员对应用进行提交,审核,研判,发布工作,后台接口跟踪流程,进度.分析各部门应用的数量,应用使用情况,提供用户对应用评价,建议等功能</p><p>7月份事情有了转折,我长期在外出差,女朋友一人和一只狗在广州,加上女朋友刚毕业就遇到37互娱式变态加班,心态有点崩,几次电话都哭泣,我也心感内疚.所以7月就离职走人了.回到广州,想要投简历,遇到之前的同事创业,和之前的工作类似,想了想就去了,从次开启了地狱模式.</p><p>工作内容确实类似,都是数据工程,写写sql,规划写数仓数据,但是平台是自己搭的,而且是一个人新搭的.架构从hive+hadoop -&gt; hadoop+yarn+hive -&gt; hadoop+hive+yarn+spark,最后决定了使用spark的STS作为平台的主要入口接收sql,数据同步使用sqoop和datax,平台调度使用airflow.但是spark thrift server确实比hive server弱一点,经常对挂掉,所以平台同事希望将sql转成spark dataframe直接操作HDFS中的数据,然后每个流程用spark-submit提交java类.我肯定是拒绝的,我认为数仓大部分是业务层的东西,理解业务并解决他才是王道,这时候用通用的sql会对实现更加友好;业务层很多东西都是容器改变的,写成java程序打包变更太频繁;数仓的东西高度依赖上下游,如果有业务功能需要在数据流中找一个最优的地方加上业务,如果用spark-submit要去源码中看实现了什么功能然后再加显得十分笨拙;接受部分是spark-submit任务,但是全部切换成spark-submit方式我坚决反对.为此和同事吵了很多次,甚至至今谁都不服谁.</p><p>说说目前的项目,项目整体方案使用的是hadoop+yarn+spark+mysql+Elasticsearch+redis+spring boot+react+ArcGIS+echarts这样的解决方案,做的是一个特定行业的内部分析系统,最后给用户使用的是一套数据分析操作,及基础数据结合GIS的展现系统</p><p>调度方面开始正式使用airflow,初级是了解airflow是在17年毕业的时候,觉得用代码定义DAG流特别牛叉,平台部署的是使用github上最多start的airflow docker repo,由于业务需要我fork了项目并增加了很多需要的包,制作了自己的镜像部署,部署使用CeleryExecutor+2个worker在单台机器上部署,期间了遇到了很多坑,都爬过来的现在他已经能稳定运行,但是scheduler时间长了会僵死的问题还是没能解决,找遍了社区的方案也只有定时重启这个方法.我个人希望在19年可以对airflow进行较深入的研究,并将我踩过的坑,积累的经验分享到博客.</p><p>号外,最近airflow已经成为apache顶级项目了</p><p>目前,新公司的项目还在招投标阶段,有中标的希望拿到我在公司的第一个标,同时也是公司的第一个标.但是苦逼的我却要每天熬夜奋战在写投标文件和招标文件.</p><p>2018年理财方面可谓一塌糊涂,可谓白打工,最惨的月份甚至是负资产,遥想我毕业的时候还有50K的存款,加上一年半工作的收入.居然会有资产为负数的月份,全靠两张信用卡活到现在.可见2018年花费太多,或者理财过于失败(主要投了个跑路的P2P).2018年让我对现金流水的重要性有了个很好的认识,2019年不求将我18年亏的赚回来,我只求19年不要亏太惨,输少当赢</p><p>2019总结起来就是:</p><ul><li>第一次长期出差工作经历</li><li>第一次写java生产级项目经历(虽然到现在都不知道dubbo是什么个原理,但是还是完成了上级交的工作)</li><li>第一次正式工作离职</li><li>第一次参加创业</li><li>第一次选择和正式环境下使用airflow</li><li>第一次亲自参加招标,准备投标</li><li>第一次在小规模使用spark</li><li>第一次小规模使用elasticsearch</li><li>学会了在用户角度考虑产品的发展</li><li>python开始写得比小学生高级一点</li></ul><h2 id="展望2019年"><a href="#展望2019年" class="headerlink" title="展望2019年"></a>展望2019年</h2><h3 id="技术展望"><a href="#技术展望" class="headerlink" title="技术展望"></a>技术展望</h3><ul><li>python能从小学生到中学生过度</li><li>java能从新手到小学生过度</li><li>希望增强基础理论的学习,如数据结构和基本算法</li><li>加强hadoop家族尤其是spark的学习,跟上时代的步伐</li><li>静下心看1-2本进阶的书籍,摆脱小学生的能力</li><li>能热情得投入开源项目的怀抱,积极参加一个较大的开源项目</li><li>能好好通过wiki积累知识,能通过blog和大家分享我学到的东西</li><li>整理好github的repo,将类似的repo合并,将没有意义的repo删除</li></ul><h3 id="生活展望"><a href="#生活展望" class="headerlink" title="生活展望"></a>生活展望</h3><ul><li>热爱我的生活</li><li>希望能够乐观地对待这个世界,同时也被这世界善待</li><li>坚持锻炼,即使每天30分钟也比没有强</li><li>周末不要睡太晚,早点起床即使不学习也可以运运动,买买菜</li><li>晚上早点睡觉,争取12点前睡着</li><li>不求生活给我惊喜,只求它别给我太多惊吓</li></ul><h3 id="理财展望"><a href="#理财展望" class="headerlink" title="理财展望"></a>理财展望</h3><ul><li>输少当赢</li><li>19年年末有存款</li></ul><h3 id="情感展望"><a href="#情感展望" class="headerlink" title="情感展望"></a>情感展望</h3><ul><li>希望情感不会被柴米油盐打败</li><li>待女朋友见家长时,希望双方都喜欢对方</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2019年1月11日,这是第一次在github page写年度总结,希望这不是最后一次,希望我能坚持下来.2018年是我毕业一来最为复杂的一年,也是最难的一年.好吧一共毕业才1年半,也验证了&lt;strong&gt;成年人的世界里没有容易&lt;/strong&gt;这句话.&lt;/p&gt;
    
    </summary>
    
    
      <category term="年度总结" scheme="http://zhongjiajie.com/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>shadowsocks使用技巧</title>
    <link href="http://zhongjiajie.com/2018/04/01/shadowsocks%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://zhongjiajie.com/2018/04/01/shadowsocks%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2018-04-01T06:53:07.000Z</published>
    <updated>2020-03-18T04:03:40.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timeline"><a href="#timeline" class="headerlink" title="timeline"></a>timeline</h2><ul><li>update at 2019-01-11: update content from personal wiki.</li></ul><p>记录了安装使用ss过程中使用到的文档,包括后期遇到的问题及相关的解决方案</p><a id="more"></a><ul><li><p><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">github-shadowsocks</a></p></li><li><p>相关资料</p><ul><li>逗逼根据地<ul><li><a href="https://doub.io/ss-jc26/" target="_blank" rel="noopener">Shadowsocks指导篇（总结归类）——从无到有，境无止尽！</a></li><li><a href="https://doub.io/ss-jc9/" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="https://doub.io/vps-tj/" target="_blank" rel="noopener">一些便宜性价比高的VPS推荐</a></li></ul></li><li><a href="http://wuchong.me/blog/2015/02/02/shadowsocks-install-and-optimize/" target="_blank" rel="noopener">wuchong-科学上网之 Shadowsocks 安装及优化加速</a></li><li>全套包括客户端</li></ul></li><li><p>Github</p><ul><li><a href="https://github.com/shadowsocks/shadowsocks/issues/682" target="_blank" rel="noopener">如何关闭SS的日志</a>: ss的日志问题，日志等级及日志的输出位置</li></ul></li><li><p>关于PAC的自定义规则</p><ul><li><a href="http://honglu.me/2015/06/26/ShadowSocks%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99/" target="_blank" rel="noopener">ShadowSocks 自定义规则</a></li><li><a href="https://www.zybuluo.com/yiranphp/note/632963" target="_blank" rel="noopener">Shadowsocks 进阶之 PAC</a></li><li><a href="https://adblockplus.org/zh_CN/filters" target="_blank" rel="noopener">撰写 Adblock Plus 过滤规则</a>： Adblock Plus官网 user-rule用该规则定义</li></ul></li><li><p>关于GFWlist</p><ul><li><a href="https://github.com/gfwlist/gfwlist" target="_blank" rel="noopener">github-gfwlist/gfwlist</a>: 一定时间更新 通过base64编码</li><li><a href="https://github.com/itcook/gfwlist2pac" target="_blank" rel="noopener">github-itcook/gfwlist2pac</a>： 时间复杂度O(1)，将base64编码还原成pac文件</li></ul></li><li><p>用了ss还是上不了或者慢的问题</p><ul><li><strong>PAC模式</strong>失效是要使用<strong>全局模式</strong>，定时更新客户端，更新PAC</li><li>关于<strong>s3下载慢</strong>的问题，可以用<strong>ss开全局模式</strong>下载</li><li><strong>s3</strong>慢还可以在host文件中增加一条路由<code>219.76.4.4  github-cloud.s3.amazonaws.com</code></li></ul></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li><p>ss开了多个端口且多人使用后，发现 <code>ssseerver</code> 服务经常死掉，参照<a href="http://aircjm.com/2016/10/17/linux-timer-task-instance-shadowsocks-process-automatically-restarts-after-stopping/" target="_blank" rel="noopener">shadowsocks进程停止后自动重启</a>写了一个定时检查的任务运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">proc_name="shadowsocks"</span><br><span class="line">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class="line">if [ $number -eq 0 ]; then</span><br><span class="line">  ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>将文件放在任意目录下，如 <code>/root</code></li><li>启动系统的 <code>cron</code> 任务 <code>sudo service cron start</code></li><li>编辑 crontab 任务，增加一个任务 <strong>注意路径要是全路径</strong> <code>*/1 * * * * /bin/bash /path/to/file</code> ，其中 <code>*/1 * * * *</code> 代表每分钟运行一次</li></ul></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">github-shadowsocks</a></li><li><a href="https://doub.io/ss-jc9/" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="https://doub.io/ss-jc26/" target="_blank" rel="noopener">Shadowsocks指导篇（总结归类）——从无到有，境无止尽！</a></li><li><a href="https://doub.io/vps-tj/" target="_blank" rel="noopener">一些便宜性价比高的VPS推荐</a></li><li><a href="http://wuchong.me/blog/2015/02/02/shadowsocks-install-and-optimize/" target="_blank" rel="noopener">科学上网之 Shadowsocks 安装及优化加速</a></li><li><a href="https://github.com/shadowsocks/shadowsocks/issues/682" target="_blank" rel="noopener">如何关闭SS的日志</a></li><li><a href="http://honglu.me/2015/06/26/ShadowSocks%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99/" target="_blank" rel="noopener">ShadowSocks 自定义规则</a></li><li><a href="https://www.zybuluo.com/yiranphp/note/632963" target="_blank" rel="noopener">Shadowsocks 进阶之 PAC</a></li><li><a href="https://adblockplus.org/zh_CN/filters" target="_blank" rel="noopener">撰写 Adblock Plus 过滤规则</a></li><li><a href="https://github.com/gfwlist/gfwlist" target="_blank" rel="noopener">github-gfwlist/gfwlist</a></li><li><a href="https://github.com/itcook/gfwlist2pac" target="_blank" rel="noopener">github-itcook/gfwlist2pac</a></li><li><a href="http://aircjm.com/2016/10/17/linux-timer-task-instance-shadowsocks-process-automatically-restarts-after-stopping/" target="_blank" rel="noopener">shadowsocks进程停止后自动重启</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;timeline&quot;&gt;&lt;a href=&quot;#timeline&quot; class=&quot;headerlink&quot; title=&quot;timeline&quot;&gt;&lt;/a&gt;timeline&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;update at 2019-01-11: update content from personal wiki.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录了安装使用ss过程中使用到的文档,包括后期遇到的问题及相关的解决方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="http://zhongjiajie.com/categories/Shadowsocks/"/>
    
      <category term="配置" scheme="http://zhongjiajie.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu常用软件安装和配置</title>
    <link href="http://zhongjiajie.com/2018/04/01/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://zhongjiajie.com/2018/04/01/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2018-04-01T06:50:11.000Z</published>
    <updated>2020-03-18T04:00:30.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timeline"><a href="#timeline" class="headerlink" title="timeline"></a>timeline</h2><ul><li>update at 2019-01-11: ubuntu 18.04 LTS 的常用配置</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文章介绍了自己第一次接触 Linux 系统的软件安装及常用配置，作为一名应届新萌，一直不能流畅的操作服务器，所以决定逼自己一把，直接将自己的操作系统换成 ubuntu</p><a id="more"></a><h2 id="wifi驱动缺失"><a href="#wifi驱动缺失" class="headerlink" title="wifi驱动缺失"></a>wifi驱动缺失</h2><p>ubuntu18.04默认没有wifi驱动,安装成功后需要将安装介质插入,然后在里边手动安装驱动,安装过程中可能有依赖,建议此时网线联网</p><h2 id="ubuntu国内源"><a href="#ubuntu国内源" class="headerlink" title="ubuntu国内源"></a>ubuntu国内源</h2><p>在<a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学ubuntu镜像帮助</a>页面选择对应的ubuntu版本，然后将系统原来的<code>/etc/apt/sources.list</code>进行备份，<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code>，将页面中的配置覆盖原<code>/etc/apt/sources.list</code>文件的内容，这个运行<code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></p><h2 id="优化流程的配置"><a href="#优化流程的配置" class="headerlink" title="优化流程的配置"></a>优化流程的配置</h2><h3 id="sudo免密"><a href="#sudo免密" class="headerlink" title="sudo免密"></a>sudo免密</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sudoers</span><br><span class="line">your_user_name ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><h3 id="gnome扩展"><a href="#gnome扩展" class="headerlink" title="gnome扩展"></a>gnome扩展</h3><p>打开<a href="https://extensions.gnome.org/" target="_blank" rel="noopener">gnome-extensions</a>在浏览器中添加gnome的插件,然后在terminal中添加gnome-shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install chrome-gnome-shell</span><br></pre></td></tr></table></figure><p>之后就可以直接在浏览器中搜索插件并安装了</p><ul><li>Pixel Saver: 减少最大化后的窗口标题大小</li><li>Dash to Dock: 将会自定折叠dock,调整dock的位置,增加屏幕的大小</li></ul><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><h3 id="shadowsocks客户端"><a href="#shadowsocks客户端" class="headerlink" title="shadowsocks客户端"></a>shadowsocks客户端</h3><p>外面的世界很精彩,ss自然也会在我的安装清单中,各种系统的安装请参考页面<a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">安装指南</a>.</p><p><del>ubuntu推荐用ppa方式安装</del></p><p><del>```shell</del><br><del>sudo add-apt-repository ppa:hzwhuang/ss-qt5</del><br><del>sudo apt-get update</del><br><del>sudo apt-get install shadowsocks-qt5</del><br><del>```</del></p><p>ppa的源在ubuntu 18.04中已经不管用了,推荐直接用<code>sslocal</code>启动,安装方式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install shadowsocks</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 sslocal 本地配置文件</span></span><br><span class="line">mkdir ~/.sslocal</span><br><span class="line">vim ~/.sslocal/sslocal.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"server"</span>: &lt;your_server_ip&gt;,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"server_port"</span>: &lt;your_port&gt;,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"local_port"</span>: 1080,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"password"</span>: &lt;your_service_pwd&gt;,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"timeout"</span>: 300,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="string">"method"</span>: <span class="string">"RC4-MD5"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#125;</span></span><br><span class="line">sslocal -c ~/.sslocal/sslocal.json</span><br></pre></td></tr></table></figure><p>设置开机启动,<code>crontab -e</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@reboot /usr/bin/python /usr/bin/sslocal -c /home/zhongjiajie/.sslocal/sslocal.json</span><br></pre></td></tr></table></figure><p>ss服务端可以配置多个账户登录，配置方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shadowsocks.json</span><br><span class="line">&#123;</span><br><span class="line">    "server":"your_server_ip",</span><br><span class="line">    # 你的端口对应的密码</span><br><span class="line">    "port_password":&#123;</span><br><span class="line">        "8381":"pass1",</span><br><span class="line">        "8382":"pass2",</span><br><span class="line">        "8383":"pass3",</span><br><span class="line">        "8384":"pass4"</span><br><span class="line">        &#125;,</span><br><span class="line">    "timeout":60,</span><br><span class="line">    "method":"rc4-md5",</span><br><span class="line">    "fast_open":false,</span><br><span class="line">    "workers":1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/" target="_blank" rel="noopener">Chrome 配置 SwitchyOmega</a>里面介绍了 SwitchyOmega 的简单配置使用，包括设置 ss 代理、配置国家防火墙、配置自动切换代理等</p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>谷歌浏览器，这个没有什么比较解释，很多插件和google的app都在chrome上面，<a href="http://blog.csdn.net/sdujava2011/article/details/50880663" target="_blank" rel="noopener">下载方式</a>有两种</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add</span><br><span class="line">sudo sh -c 'echo "deb http://dl.google.com/linux/chrome/deb/ stable main" &gt;&gt; /etc/apt/sources.list.d/google-chrome.list'</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install google-chrome</span><br></pre></td></tr></table></figure><p>安装完成后打开chrome发现及时运行了ss客户端还是没有办法翻墙，这个和windows下比较不同，ubuntu下需要手动设置代理才能翻墙，但是发现代理软件需要登陆chrome应用市场下载，后来发现<a href="https://portableapps.com/node/22329" target="_blank" rel="noopener">start Google Chrome with proxy command</a>可以在命令行启动chrome，于是在命令行下运行<code>google-chrome --proxy-server=&quot;socks5://127.0.0.1:1080&quot;</code>然后chrome就能科学上网了</p><h3 id="修改root角色密码"><a href="#修改root角色密码" class="headerlink" title="修改root角色密码"></a>修改root角色密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line"><span class="meta">#</span><span class="bash"> enter root password and repeat it</span></span><br></pre></td></tr></table></figure><h3 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 微软onedrive的DNS被污染，增加两行</span></span><br><span class="line">204.79.197.217    onedrive.live.com</span><br><span class="line">134.170.108.152   skyapi.onedrive.live.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> IntelliJ Pycharm 检测是注册url</span></span><br><span class="line">0.0.0.0           account.jetbrains.com</span><br><span class="line">192.168.0.253     slave.isoft</span><br><span class="line">192.168.0.252     hdp.isoft</span><br></pre></td></tr></table></figure><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>zsh被称为终极shell，比ubuntu默认的bash要强大不少。根据<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" target="_blank" rel="noopener">Installing ZSH</a>安装zsh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> check <span class="keyword">if</span> installed</span></span><br><span class="line">zsh --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> check default shell <span class="keyword">in</span> system</span></span><br><span class="line">echo $SHELL</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 oh-my-zsh 项目来配置 zsh 会自动读取环境变量并且自动帮 zsh 进行设置</span></span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> make zsh as your default shell</span></span><br><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><h2 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h2><p>thefuck 是自动纠正上一个命令的命令行工具，经常用命令行的同学怎么可以错过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-dev python3-pip</span><br><span class="line">sudo pip3 install thefuck</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 .zshrc 文件</span></span><br><span class="line">eval $(thefuck --alias fuck)</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.tmux.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认&lt;prefix&gt;是Ctrl+b，如果你觉得不好按可以调整为Ctrl+a</span></span><br><span class="line">unbind ^b</span><br><span class="line">set -g prefix 'C-a'</span><br><span class="line"><span class="meta">#</span><span class="bash"> Tmux动态载入配置而不是重启 设一个快捷键&lt;prefix&gt;r来重新载入配置</span></span><br><span class="line">bind r source-file ~/.tmux.conf \; display-message "Config reloaded"</span><br></pre></td></tr></table></figure><ul><li>基本使用方式</li></ul><p>tmux-concept相关概念</p><p>[[tmux-concept.png|tmux-concept]]</p><p><code>&lt;prefix&gt;</code>指的是tmux的前缀键,所有tmux快捷键都需要先按前缀键.它的默认值是<code>Ctrl+b</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快捷键帮助列表</span></span><br><span class="line">&lt;prefix&gt;?</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个session</span></span><br><span class="line">tmux new -s &lt;session_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者新建一个无名session然后重命名</span></span><br><span class="line">tmux</span><br><span class="line">&lt;prefix&gt;$</span><br><span class="line"><span class="meta">#</span><span class="bash"> unicode 显示问题 启动tmux增加参数</span></span><br><span class="line">tmux -u</span><br><span class="line"><span class="meta">#</span><span class="bash"> detach 退出 Tmux Session，回到父级 Shell</span></span><br><span class="line">&lt;prefix&gt;d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在bash查看当前tmux服务有哪些session</span></span><br><span class="line">tmux ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据session名字回去该session</span></span><br><span class="line">tmux a -t &lt;session_name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在tmux里面列出所有session及window的树结构 可以通过左右键展开树状结构 可以查看并切换session及windows</span></span><br><span class="line">&lt;prefix&gt;s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭session</span></span><br><span class="line">tmux kill-session -t &lt;session_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建windows</span></span><br><span class="line">&lt;prefix&gt;c</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换同一session的第n个windows</span></span><br><span class="line">&lt;prefix&gt;&lt;n&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭当前窗口</span></span><br><span class="line">&lt;prefix&gt;&amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换window</span></span><br><span class="line">&lt;prefix&gt;&lt;编号&gt;  # 切换到指定编号windows</span><br><span class="line">&lt;prefix&gt;p      # 切换至上一窗口</span><br><span class="line">&lt;prefix&gt;n      # 切换至下一窗口</span><br><span class="line">&lt;prefix&gt;w      # 通过window列表切换window</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名当前windows</span></span><br><span class="line">&lt;prefix&gt;,</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改当前window编号</span></span><br><span class="line">&lt;prefix&gt;.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 水平分割窗口 形成两个Pane</span></span><br><span class="line">&lt;prefix&gt;%</span><br><span class="line"><span class="meta">#</span><span class="bash"> 垂直分割窗口 形成两个Pane</span></span><br><span class="line">&lt;prefix&gt;\"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭当前Pane</span></span><br><span class="line">&lt;prefix&gt;x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大化当前Pane 重复一次恢复正常</span></span><br><span class="line">&lt;prefix&gt;z</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示Pane编号 在编号消失前输入对应的数字可切换到相应的Pane</span></span><br><span class="line">&lt;prefix&gt;q</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移动光标切换Pane</span></span><br><span class="line">&lt;prefix&gt;&lt;方向键&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调整pane大小</span></span><br><span class="line">&lt;prefix&gt;&lt;ctrl+方向键&gt;  # 以1个单元格为单位调整当前pane边缘</span><br><span class="line">&lt;prefix&gt;&lt;alt+方向键&gt;  # 以5个单元格为单位调整当前pane边缘</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换 Pane 布局</span></span><br><span class="line">&lt;prefix&gt;&lt;space&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制粘贴</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Tmux中通过`&lt;prefix&gt;[`进入拷贝模式，按下&lt;space&gt;开始拷贝。然后用Vim/Emacs快捷键选择文本，按下&lt;Enter&gt;拷贝所选内容。然后通过`&lt;prefix&gt;]`进行粘贴</span></span><br></pre></td></tr></table></figure><h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3OTIxNTA0MA==&mid=2650802567&idx=1&sn=9e18d2c5064eb762b7fd7f8f32282ebf&scene=7" target="_blank" rel="noopener">jq</a>是是linux下的json格式化神器,如果有安装python的情况下也可以使用<code>json.tool</code>完成.<code>echo &#39;{&quot;one&quot;: 1, &quot;two&quot;: 2}&#39; | python -m json.tool</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> install</span></span><br><span class="line">sudo apt-get install jq</span><br><span class="line"><span class="meta">#</span><span class="bash"> qiuck start</span></span><br><span class="line">echo '&#123;"one": 1, "two": 2, "name": "zhongjiajie"&#125;' | jq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key</span></span><br><span class="line">echo '&#123;"one": 1, "two": 2, "name": "zhongjiajie"&#125;' | jq '.name'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 嵌套解析</span></span><br><span class="line">cat json_test.txt | jq '.location.city'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 内建函数</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 获取所有的key</span></span><br><span class="line">cat json_test.txt | jq 'keys'</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 判断某个可以是否存在</span></span><br><span class="line">cat json_test.txt | jq 'has("location")'</span><br></pre></td></tr></table></figure><h3 id="pv"><a href="#pv" class="headerlink" title="pv"></a>pv</h3><p>复制时候显示完成百分比、传输速度、剩余时间、已用时间，用法和<code>cp</code>类似: <code>pv src_file &gt; dest_file</code>，参照<a href="https://linux.cn/article-6734-1.html" target="_blank" rel="noopener">如何使用 pv 命令监控 linux 命令的执行进度</a></p><h3 id="guake"><a href="#guake" class="headerlink" title="guake"></a>guake</h3><p>有了tmux之后guake很少用了</p><p><del>按<code>F12</code>可以快速生成一个terminal，然后失去焦点后会自动缩进去的终端，在临时处理事情的时候非常有用<code>sudo apt-get guake</code>，<a href="http://www.binarytides.com/install-guake-xubuntu-14-04/" target="_blank" rel="noopener">这里</a>给了一些<strong>Guake can not init!</strong>问题的处理方式。</del></p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="Python虚拟环境的安装"><a href="#Python虚拟环境的安装" class="headerlink" title="Python虚拟环境的安装"></a>Python虚拟环境的安装</h4><p>ubuntu 系统内置两个版本的 Python ，之前一直用py2，但是考虑到20年py2就要停止维护了，所以打算上py3， ubuntu 16.04 默认两个版本的 python 都有安装，开发的时候一般都会用虚拟环境以免 ubuntu 原生的工具被破坏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 pip3</span></span><br><span class="line">sudo apt-get install python-pip3</span><br><span class="line">pip3 --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 virtualenv</span></span><br><span class="line">pip install virtualenv</span><br><span class="line">virtualenv --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 virtualenvwrapper</span></span><br><span class="line">pip install virtualenvwrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑你的 .bashrc 或者 .zshrc 在最后面添加</span></span><br><span class="line">VIRTUALENVWRAPPER_PYTHON=$(which python3)    # 这句一定要添加，不然会默认用python2 来解析</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者加 VIRTUALENVWRAPPER_PYTHON=<span class="string">'/path/to/python3'</span></span></span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">source $(which virtualenvwrapper.sh)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> virtualenvwrapper 使用</span></span><br><span class="line">mkvirtualenv venv</span><br><span class="line">deactivate</span><br><span class="line">rmvirtualenv venv</span><br></pre></td></tr></table></figure><h4 id="pip-换国内源"><a href="#pip-换国内源" class="headerlink" title="pip 换国内源"></a>pip 换国内源</h4><p>官方源很好，但是下载速度比较慢，所以把 pip 默认的源从官方源改成国内源提高速度，等国内源下载确实有问题时再去官方源下载，国内源用的是<a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">清华大学pypi源</a></p><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>Java JDK有两个版本，一个开源版本Openjdk，还有一个oracle官方版本jdk。下面记录在Ubuntu 16.04上安装Java JDK的步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开源版openjdk</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> oracle Java JDK</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖包</span></span><br><span class="line">sudo apt-get install python-software-properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加仓库源</span></span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p>根据<a href="https://gradle.org/install/#with-a-package-manager" target="_blank" rel="noopener">gradle-instal</a>方式,推荐手动安装,然后将安装路径的<code>bin</code>子路径放在环境变量中<code>vim ~/.zshrc; export PATH=$PATH:/opt/gradle/gradle-4.10.2/bin</code>,测试是否存在<code>gradle -v</code></p><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><p>安装maven<code>sudo apt-get install mvn</code>,测试是否成功及版本<code>mvn -v</code></p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>文本编辑器，根据官网<a href="https://code.visualstudio.com/docs/setup/linux" target="_blank" rel="noopener">Running VS Code on Linux</a>的介绍，建议直接下载deb包并且安装</p><h3 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h3><p>JetBrains 出品的 Python IDE,可直接在 ubuntu software中下载</p><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>JetBrains 出品的 Java IDE,可直接在 ubuntu software中下载</p><h3 id="数据库管理工具"><a href="#数据库管理工具" class="headerlink" title="数据库管理工具"></a>数据库管理工具</h3><ul><li><a href="https://www.jetbrains.com/datagrip/" target="_blank" rel="noopener">datagrip</a>: 跨三个平台的 jetbrains 独立出来的数据库管理工具,可以除了配置指定的数据源之外,还可以配置驱动链接 hive kylin 等数据源.但是 NoSQL 还没有很好的解决方案,可直接在ubuntu software中下载</li><li><a href="https://dbeaver.io/download/" target="_blank" rel="noopener">dbeaver</a>: 跨三个平台的数据库管理工具,天生支持 hive sparkhive neo4j Greenplum等数据库,但是不支持 mongo,同样是需要下载jar包通过jdbc进行链接</li></ul><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>docker 是非常好用的容器技术，可以说是改变了软件的交付和部署方式，docker 的安装如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载旧版本的docker</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker 可选的内核模块</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 apt 镜像源安装</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过国内源安装</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向 source.list 添加 docker 软件源</span></span><br><span class="line">sudo add-apt-repository "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 Docker CE</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 docker ce</span></span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立 docker 用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启之后可以在普通用户运行 docker</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 国内镜像加速</span></span><br><span class="line">vim /etc/docker/daemon.json   # 输入你用的国内镜像加速器 这里以docker中国为例</span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   <span class="string">"registry-mirrors"</span>: [</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       <span class="string">"https://registry.docker-cn.com"</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       <span class="string">"https://&lt;your-specific-key&gt;.mirror.aliyuncs.com"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   ]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#125;</span></span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><p>其中国内镜像加速器有<br><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">docker中国</a><br><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云</a><br><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daocloud</a></p><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>update: 20180829,使用<a href="https://rime.im/download/" target="_blank" rel="noopener">rime</a>输入法替代搜狗输入法,用的是 <strong>fcitx-rime</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx-rime</span><br><span class="line">im-configsudo reboot</span><br><span class="line">fcitx-config-gtk3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启后便可</span></span><br></pre></td></tr></table></figure><p><del>搜狗输入法是我下载的第一个应用，他是和计算机交流的重要途径。直接前往<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">搜狗for linux</a>进行下载，安装指南直接看官网的<a href="https://pinyin.sogou.com/linux/help.php" target="_blank" rel="noopener">安装指南</a>。因为我是ubuntu 16.04.LTS，所以我更新了upgrade了系统的软件后直接双击<code>.deb</code>文件就完成了安装过程。</del></p><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>可直接在 ubuntu 18.04的 ubuntu software下载</p><p><del>生活沟通必备，主要是QQ被我用烂了，不想用了。两种方式可以实现微信的安装，一种是在<a href="https://chrome.google.com/webstore/detail/wechat/ckhliaadcjmdjbhdlkpjkffidcifglba?hl=en-US" target="_blank" rel="noopener">chrome插件</a>里面安装，直接页面操作不多解释。另一种是第三方的安装方式<a href="https://github.com/geeeeeeeeek/electronic-wechat" target="_blank" rel="noopener">electronic-wechat</a>，如果是简单的交流肯定是用第一种方式更加简单粗暴，如果希望有更多的功能就要选择第二中方式。</del></p><h3 id="shutter"><a href="#shutter" class="headerlink" title="shutter"></a>shutter</h3><p>截图软件，直接在ubuntu software搜索安装</p><ul><li>安装之后不能在ubuntu任务栏上显示其快捷方式,<a href="http://tipsonubuntu.com/2018/05/25/re-enable-shutter-app-icon-ubuntu-18-04-system-tray/" target="_blank" rel="noopener">Re-enable Shutter App Icon in Ubuntu 18.04 System Tray</a></li><li>安装完了之后不能对截图进行编辑,可以按照<a href="https://askubuntu.com/a/1029101" target="_blank" rel="noopener">How to enable the Edit button in Shutter</a>的方式安装三个依赖的包然后重启电脑便可</li></ul><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>听歌必备神器，直接在<a href="http://music.163.com/#/download" target="_blank" rel="noopener">网易云音乐</a>下载安装点击deb包就可以安装</p><h3 id="VLC"><a href="#VLC" class="headerlink" title="VLC"></a>VLC</h3><p>视频播放软件，直接在ubuntu software搜索安装</p><h3 id="Tweaks"><a href="#Tweaks" class="headerlink" title="Tweaks"></a>Tweaks</h3><p>直接在ubuntu software安装</p><ul><li>配置开关在左边: windows-&gt;titlebar buttons-&gt;placement-&gt;left</li><li>显示电池百分比: top bar-&gt;battery percentage</li><li>不显示应用菜单: top bar-&gt;application menu</li><li>调整显示时间相关: top bar</li><li>桌面不显示icon: desktop-&gt;show icon</li></ul><h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>先在<a href="http://www.wps.cn/product/wpslinux/#" target="_blank" rel="noopener">WPS-社区</a>下载对应的安装包,到对应的下载目录安装<code>sudo dpkg -i wps-office_10.1.0.5672_a21_amd64.deb</code>,如果此时安装出错要用<code>sudo apt-get install -f</code>.安装成功打开回提示部分字体缺失,可以到<code>https://pan.baidu.com/s/1eS6xIzo</code>下载字体,解压字体并<code>sudo mv wps_symbol_fonts /usr/share/fonts</code>移动到对应的文件夹.运行命令生成字体索引信息<code>sudo mkfontscale;sudo mkfontdir</code>更新字体缓存<code>sudo fc-cache</code></p><h3 id="FBReader"><a href="#FBReader" class="headerlink" title="FBReader"></a>FBReader</h3><p>轻量级的阅读器,支持多种电子书籍格式,直接在应用中心下载</p><h3 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h3><p>平时工作交流用钉钉，所以装了个<a href="https://github.com/nashaofu/dingtalk" target="_blank" rel="noopener">钉钉 for linux</a>，只需要按照README文档中介绍在<strong>relase</strong>页面下载相应的deb包进行安装就行</p><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><p>翻译软件，直接<a href="http://cidian.youdao.com/index-linux.html" target="_blank" rel="noopener">有道翻译页面</a>下载deb然后安装，建议下载deepin版本</p><h3 id="数据库客户端"><a href="#数据库客户端" class="headerlink" title="数据库客户端"></a>数据库客户端</h3><h4 id="Oracle-client-sqlplus"><a href="#Oracle-client-sqlplus" class="headerlink" title="Oracle client - sqlplus"></a>Oracle client - sqlplus</h4><p>安装 Oracle client 参见 <a href="http://webikon.com/cases/installing-oracle-sql-plus-client-on-ubuntu" target="_blank" rel="noopener">Installing Oracle SQL*Plus client on Ubuntu</a> 以及 <a href="https://askubuntu.com/questions/159939/how-to-install-sqlplus" target="_blank" rel="noopener">How to install SqlPlus</a></p><p>设置开机启动，进入<strong>search your computer</strong>，就是按Windows键或者ubuntu建，输入<strong>startup</strong></p><h3 id="Remmina远程桌面客户端"><a href="#Remmina远程桌面客户端" class="headerlink" title="Remmina远程桌面客户端"></a>Remmina远程桌面客户端</h3><p>ubuntu自带软件,支持多个远程协议 RDP SFTP SSH VNC</p><h3 id="迅雷"><a href="#迅雷" class="headerlink" title="迅雷"></a>迅雷</h3><p>通过迅雷固件制作而成的前端，需要自己编译，但是教程已经比较完整，详情查看<a href="https://github.com/Xinkai/XwareDesktop/wiki/Ubuntu%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Ubuntu上编译安装说明</a>，安装成功启动后请看<a href="https://github.com/Xinkai/XwareDesktop/wiki/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">使用说明</a>，因为有部分注意事项要遵守</p><p>由于迅雷前端固件经常会报错,所以直接用 xware + <a href="http://yuancheng.xunlei.com/" target="_blank" rel="noopener">迅雷远程下载网页版</a>进行下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull zhongjiajie/docker-xware</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker logs -f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以在日志中看到对应的 `THE ACTIVE CODE IS`,将</span></span><br></pre></td></tr></table></figure><h2 id="百度网盘客户端"><a href="#百度网盘客户端" class="headerlink" title="百度网盘客户端"></a>百度网盘客户端</h2><p>百度网盘和迅雷在国内都比较常用，百度网盘 Linux 客户端在 github 上主要是三个<a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">bypy</a><a href="https://github.com/GangZhuo/BaiduPCS" target="_blank" rel="noopener">BaiduPCS</a><a href="https://github.com/Yufeikang/bcloud" target="_blank" rel="noopener">Yufeikang/bcloud</a>，其中前两个是命令行客户端，后面是图形化界面。本来考虑图形化界面，但是看到 README 说作者不维护了，<a href="https://github.com/Yufeikang/bcloud" target="_blank" rel="noopener">Yufeikang/bcloud</a> 就是因为原作者没有维护所以才拿过来修改的，现在 Yufeikang 也弃坑了，所以只能转战命令行客户端了。两个来选，当然选择我更加熟悉的 Python 版的 bypy 了。说不定还能提几个 issue 和 PR 呢。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我放在了虚拟环境中运行</span></span><br><span class="line">workon venv</span><br><span class="line">pip3 install bypy</span><br><span class="line"></span><br><span class="line">bypy list # 在命令行界面会给出提示，让你去指定的网址进行登录注册，并将授权码复制到命令行</span><br></pre></td></tr></table></figure><h3 id="桌面美化相关"><a href="#桌面美化相关" class="headerlink" title="桌面美化相关"></a>桌面美化相关</h3><p>部分的桌面美化对于ubuntu来说还是有必要的，毕竟原来的桌面真的有点丑，我选择了大众而简单的美化路线，<a href="https://github.com/tualatrix/ubuntu-tweak" target="_blank" rel="noopener">ubuntu tweak</a><a href="https://github.com/anmoljagetia/Flatabulous" target="_blank" rel="noopener">flatabulous-theme</a>以及ultra-flat-icons。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu tweak</span></span><br><span class="line">sudo apt-get install unity-tweak-tool</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> flatabulous-theme 主题</span></span><br><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flatabulous-theme</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> flatabulous配套图标</span></span><br><span class="line">sudo add-apt-repository ppa:noobslab/icons</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure><p>安装完成后就可以启动ubuntu tweak，然后在<code>Tweak -&gt; Theme</code>中的GTK和windows主题中选择flatabulous，icon主题中选择ultra-flat</p><h2 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h2><p>格式转换工具<code>pandoc</code>,直接通过apt安装<code>sudo apt-get install pandoc</code>,将markdown转成HTML的例子如下<code>pandoc -o test.html test.md</code></p><h2 id="rdesktop"><a href="#rdesktop" class="headerlink" title="rdesktop"></a>rdesktop</h2><p>rdesktop is an open source client for Windows Remote Desktop Services, capable of natively speaking Remote Desktop Protocol (RDP) in order to present the user’s Windows desktop.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rdesktop</span><br><span class="line">rdesktop [hostname]</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">shadowsocks-qt5安装指南</a></li><li><a href="https://portableapps.com/node/22329" target="_blank" rel="noopener">Want to start Google Chrome with proxy command</a></li><li><a href="http://www.binarytides.com/install-guake-xubuntu-14-04/" target="_blank" rel="noopener">How to install guake (dropdown terminal) on Xubuntu 14.04</a></li><li><a href="https://github.com/Xinkai/XwareDesktop/wiki/Ubuntu%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">XwareDesktopUbuntu上编译安装说明</a></li><li><a href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/" target="_blank" rel="noopener">Chrome 配置 SwitchyOmega</a></li><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">docker - use-case-the-china-registry-mirror</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3OTIxNTA0MA==&mid=2650802567&idx=1&sn=9e18d2c5064eb762b7fd7f8f32282ebf&scene=7" target="_blank" rel="noopener">Linux下Json格式化神器jq</a></li><li><a href="http://webikon.com/cases/installing-oracle-sql-plus-client-on-ubuntu" target="_blank" rel="noopener">Installing Oracle SQL*Plus client on Ubuntu</a></li><li><a href="https://askubuntu.com/questions/159939/how-to-install-sqlplus" target="_blank" rel="noopener">How to install SqlPlus</a></li><li><a href="https://linux.cn/article-6734-1.html" target="_blank" rel="noopener">如何使用 pv 命令监控 linux 命令的执行进度</a></li><li><a href="http://yuancheng.xunlei.com/" target="_blank" rel="noopener">迅雷远程下载网页版</a></li><li><a href="https://www.jetbrains.com/datagrip/" target="_blank" rel="noopener">datagrip</a></li><li><a href="https://dbeaver.io/download/" target="_blank" rel="noopener">dbeaver</a></li><li><a href="https://rime.im/download/" target="_blank" rel="noopener">rime-download</a></li><li><a href="https://extensions.gnome.org/" target="_blank" rel="noopener">gnome-extensions</a></li><li><a href="https://askubuntu.com/a/1029101" target="_blank" rel="noopener">How to enable the Edit button in Shutter</a></li><li><a href="http://tipsonubuntu.com/2018/05/25/re-enable-shutter-app-icon-ubuntu-18-04-system-tray/" target="_blank" rel="noopener">Re-enable Shutter App Icon in Ubuntu 18.04 System Tray</a></li><li><a href="https://gradle.org/install/#with-a-package-manager" target="_blank" rel="noopener">gradle-instal</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;timeline&quot;&gt;&lt;a href=&quot;#timeline&quot; class=&quot;headerlink&quot; title=&quot;timeline&quot;&gt;&lt;/a&gt;timeline&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;update at 2019-01-11: ubuntu 18.04 LTS 的常用配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;文章介绍了自己第一次接触 Linux 系统的软件安装及常用配置，作为一名应届新萌，一直不能流畅的操作服务器，所以决定逼自己一把，直接将自己的操作系统换成 ubuntu&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://zhongjiajie.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>git 常用命令</title>
    <link href="http://zhongjiajie.com/2017/10/24/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhongjiajie.com/2017/10/24/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2017-10-24T03:25:28.000Z</published>
    <updated>2020-03-18T04:00:21.564Z</updated>
    
    <content type="html"><![CDATA[<p>NOTE!: github page根据使用功能区分，想要了解更多见<a href="https://github.com/zhongjiajie/zhongjiajie.github.com/wiki/Git%E7%9B%B8%E5%85%B3%E7%A7%AF%E7%B4%AF" target="_blank" rel="noopener">本人wiki</a></p><p>本文介绍Git常见的命令以及部分问题的处理方式，是一篇应用性较强的文章，如果想要更加深入的了解Git的原理，请参考本文的<a href="#References">References</a></p><a id="more"></a><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p><img src="gitflow.png" alt="gitflow"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>在使用Git前要对其进行基本的配置，记录是谁进行当前的修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name "YOUR_NAME"                 # 设置 commit 的用户</span><br><span class="line">git config user.email "YOUR_EMIAL@example.com"   # 设置 commit 的邮箱</span><br></pre></td></tr></table></figure><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 个性化 <span class="built_in">log</span></span></span><br><span class="line">git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"       # 自定义lg命令 格式化log的输出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 个性化 reflog</span></span><br><span class="line">git config --global alias.rlg "reflog --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"</span><br></pre></td></tr></table></figure><h2 id="获取版本库"><a href="#获取版本库" class="headerlink" title="获取版本库"></a>获取版本库</h2><h3 id="从远程版本库获取"><a href="#从远程版本库获取" class="headerlink" title="从远程版本库获取"></a>从远程版本库获取</h3><p>从远程版本库中直接拉取一个仓库，会在当前路径下新生成一个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zhongjiajie/Autohome.git   # 从github获取</span><br><span class="line">git clone git@server-name:path/repo-name.git            # 从私有服务器中获取</span><br></pre></td></tr></table></figure><h3 id="新建版本库"><a href="#新建版本库" class="headerlink" title="新建版本库"></a>新建版本库</h3><p>一般做法，只能在本地提交、推送到远程，别的用户不能从该库进行<code>clone</code>以及<code>push</code>操作，看到<em>first_git</em>文件夹下面有<strong>.git</strong>隐藏文件夹就说明创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir first_git</span><br><span class="line">cd first_git</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="新建裸库"><a href="#新建裸库" class="headerlink" title="新建裸库"></a>新建裸库</h3><p>新建远程版本库，可以提供<code>clone</code>和<code>push</code>到改版本库功能。此时<em>first_git</em>文件夹中和<a href="#新建版本库">新建版本库</a>不同，会生成多个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir first_git</span><br><span class="line">cd first_git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><h2 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h2><h3 id="查看远程版本库"><a href="#查看远程版本库" class="headerlink" title="查看远程版本库"></a>查看远程版本库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote       # 查看远程版本库信息</span><br><span class="line">git remote -v    # 远程版本库详细信息</span><br></pre></td></tr></table></figure><h3 id="添加远程版本库"><a href="#添加远程版本库" class="headerlink" title="添加远程版本库"></a>添加远程版本库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git       # 添加一个远程库</span><br></pre></td></tr></table></figure><h3 id="推送到远程版本库"><a href="#推送到远程版本库" class="headerlink" title="推送到远程版本库"></a>推送到远程版本库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master           # 推送到远程master分支</span><br><span class="line">git push -u origin BRANCHNAME    # 本地新建分支推送到远程兵追踪</span><br></pre></td></tr></table></figure><h3 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev       # 新建本地dev分支 与远程origin/dev分支进行关联 切换到本地dev分支</span><br></pre></td></tr></table></figure><h3 id="抓取分支的修改"><a href="#抓取分支的修改" class="headerlink" title="抓取分支的修改"></a>抓取分支的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master                   # 抓取远程master分支的commit信息</span><br><span class="line">git pull origin master                    # 抓取远程master分支的commit信息并对文件进行相应修改</span><br><span class="line">git fetch origin pull/ID/head:BRANCHNAME  # 抓取远程分支的某个pull requests</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete BRANCHNAME    # --delete选项删除远程分支</span><br><span class="line">git push origin :BRANCHNAME            # 推送一个空的分支到要删除的远程分支</span><br></pre></td></tr></table></figure><h3 id="更新远程分析信息"><a href="#更新远程分析信息" class="headerlink" title="更新远程分析信息"></a>更新远程分析信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p       # 更新远程版本库同步分支和tag</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev master           # 在master的基础上创建dev分支</span><br><span class="line">git checkout dev                # 切换到dev分支</span><br><span class="line">git checkout -b dev master      # 在master的基础上创建dev分支 并切换到dev分支</span><br><span class="line">git checkout -b dev origin/dev  # 新建dev分支 与远程origin/dev分支进行关联 并切换到dev分支</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff dev   # 合并dev分支 no-ff选项保留原分支记录 commit按照时间排序</span><br><span class="line"></span><br><span class="line">git checkout dev</span><br><span class="line">git rebase master       # 合并dev分支到master分支的最后面 重新排列commit顺序</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev       # 删除已合并的分支</span><br><span class="line">git branch -D dev       # 强行删除分支</span><br></pre></td></tr></table></figure><h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><h3 id="状态和差异"><a href="#状态和差异" class="headerlink" title="状态和差异"></a>状态和差异</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status                   # 查看工作区、暂存区的状态</span><br><span class="line">git diff                     # 查看未暂存的文件更新</span><br><span class="line">git diff --cached            # 查看已暂存文件的更新</span><br><span class="line">git diff HEAD -- FILENAME    # 查看工作区和版本库里面最新版本的区别</span><br><span class="line">git diff BRANCH_1 BRANCH_2   # 在合并改动之前，预览两个分支的差异</span><br></pre></td></tr></table></figure><h3 id="删除和移动"><a href="#删除和移动" class="headerlink" title="删除和移动"></a>删除和移动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rm FILENAME            # 直接删除文件</span><br><span class="line">git rm --cached FILENAME   # 删除文件暂存状态</span><br><span class="line"></span><br><span class="line">git mv FILENAME_1 FILENAME_2           # FILENAME_1重命名成FILENAME_2</span><br><span class="line">git mv FILENAME_1 path/to/FILENAME_2   # FILENAME_1移动到path/to目录并重命名成FILENAME_2</span><br><span class="line">git rm FILENAME                        # 删除文件FILENAME</span><br></pre></td></tr></table></figure><h3 id="储藏和恢复"><a href="#储藏和恢复" class="headerlink" title="储藏和恢复"></a>储藏和恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash                  # 储藏当前工作状态</span><br><span class="line">git stash list             # 查看储藏列表</span><br><span class="line">git stash apply STASH_ID   # 恢复指定储藏状态</span><br><span class="line">git stash drop STASH_ID    # 删除指定储藏ID</span><br><span class="line">git stash pop              # 恢复最近储藏 并删除 相当于apply + drop</span><br><span class="line">git stash clear            # 清空储藏列表</span><br></pre></td></tr></table></figure><h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add FILENAME             # 添加文件到暂存区</span><br><span class="line">git add .                    # 添加当前全部修改到暂存区</span><br><span class="line">git commit -m 'commit log'   # 将暂存区修改提交到本地版本库并记录commit log</span><br><span class="line">git commit -amend            # 修改最后一次提交</span><br><span class="line">git push origin master       # 提交到远程版本库</span><br></pre></td></tr></table></figure><h3 id="修改提交人信息"><a href="#修改提交人信息" class="headerlink" title="修改提交人信息"></a>修改提交人信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author "YOUR_NAME &lt;YOUR_EMIAL@example.com&gt;"       # 修改上次提交的用户信息</span><br></pre></td></tr></table></figure><h2 id="历史和回退"><a href="#历史和回退" class="headerlink" title="历史和回退"></a>历史和回退</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline           # 查看历史 每个历史一条记录</span><br><span class="line">git log --oneline FILENAME  # 查看指定文件历史 每个历史一条记录</span><br><span class="line">git log -p -2               # 显示最近2次提交内容的差异</span><br><span class="line">git show COMMIT_ID          # 查看某次修改</span><br></pre></td></tr></table></figure><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- FILENAME    # 丢弃工作区上某个文件的修改</span><br><span class="line">git reset HEAD FILENAME     # 丢弃暂存区上某个文件的修改，重新放回工作区</span><br><span class="line">git reset --hard HEAD^      # 回退到上一个版本</span><br><span class="line">git reset --hard COMMIT_ID  # 回退到具体某个版</span><br><span class="line"></span><br><span class="line">git reflog                  # 查看命令历史 常在merge或rebase丢失了commit后使用</span><br><span class="line"></span><br><span class="line">git revert COMMIT_ID        # 撤销指定的提交</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.1                # 新建标签，默认位 HEAD</span><br><span class="line">git tag v0.1 COMMIT_ID      # 对指定的 commit id 打标签</span><br><span class="line">git tag -a v0.1 -m 'version 0.1 released'       # 新建带注释标签</span><br></pre></td></tr></table></figure><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag             # 显示所有标签</span><br><span class="line">git show TAGNAME    # 显示指定标签信息</span><br></pre></td></tr></table></figure><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d TAGNAME                   # 删除标签</span><br><span class="line">git push origin :refs/tags/TAGNAME   #删除远程标签</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout TAGNAME      # 切换到标签</span><br><span class="line">git push origin TAGNAME   # 推送分支到源上</span><br><span class="line">git push origin --tags    # 一次性推送全部尚未推送到远程的本地标签</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h3><p><a href="http://blog.csdn.net/u013068377/article/details/52168434" target="_blank" rel="noopener">windows下git bash中文乱码解决办法</a></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li><p>修改某次特定commit的作者<a href="https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit" target="_blank" rel="noopener">Change commit author at one specific commit</a></p></li><li><p>修改某次特定的commit内容<a href="https://stackoverflow.com/questions/1186535/how-to-modify-a-specified-commit-in-git" target="_blank" rel="noopener">How to modify a specified commit in git</a></p></li><li><p>修改版本库的第一个commit<a href="https://stackoverflow.com/questions/2119480/edit-the-root-commit-in-git" target="_blank" rel="noopener">Edit the root commit in Git</a></p></li></ul><h3 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h3><p>统计每个用户提交的次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -nes       # 统计每个用户提交的次数 name + email + summary</span><br></pre></td></tr></table></figure><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><ul><li>恢复所有在git中被删除的文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -d | xargs echo -e | xargs git checkout --</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://stackoverflow.com/questions/23821235/how-to-link-to-specific-line-number-on-github" target="_blank" rel="noopener">How to link to specific line number on github</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://wuchong.me/blog/2015/03/30/git-useful-skills/" target="_blank" rel="noopener">Git 常用技能</a><br><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">my-git</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a><br><a href="https://help.github.com/articles/checking-out-pull-requests-locally/#modifying-an-inactive-pull-request-locally" target="_blank" rel="noopener">Modifying an inactive pull request locally</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NOTE!: github page根据使用功能区分，想要了解更多见&lt;a href=&quot;https://github.com/zhongjiajie/zhongjiajie.github.com/wiki/Git%E7%9B%B8%E5%85%B3%E7%A7%AF%E7%B4%AF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本人wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍Git常见的命令以及部分问题的处理方式，是一篇应用性较强的文章，如果想要更加深入的了解Git的原理，请参考本文的&lt;a href=&quot;#References&quot;&gt;References&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://zhongjiajie.com/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>用github管理blog</title>
    <link href="http://zhongjiajie.com/2017/10/23/%E7%94%A8github%E7%AE%A1%E7%90%86blog/"/>
    <id>http://zhongjiajie.com/2017/10/23/%E7%94%A8github%E7%AE%A1%E7%90%86blog/</id>
    <published>2017-10-23T13:47:43.000Z</published>
    <updated>2020-03-18T04:44:04.929Z</updated>
    
    <content type="html"><![CDATA[<p>update at 2019-01-11: 由于这种方式过于分散,导致换了电脑后就难以恢复博客内容,所以放弃了.<strong>根据一个懒码农的经验,写博客需要的是耐心,而不是高明的博客内容管理方法.</strong>所以我现在使用的方法是:</p><ul><li>在个人<a href="https://github.com/zhongjiajie/zhongjiajie.github.com" target="_blank" rel="noopener">github-page-repo</a>上面新建一个分支source用于储存全部的源码(包括主题和配置),需要写博客时直接切换到这个分支写完,然后<code>hexo d</code>完成部署</li><li>如果有多篇文章同时在编写中,没有完成release的,统一将内容放在本人的<a href="https://github.com/zhongjiajie/zhongjiajie.github.com/wiki" target="_blank" rel="noopener">wiki</a>的<strong>blog-tmp</strong>文件夹中,这样wiki在本地提交到repo中也会因为没有暴露出<strong>blog-tmp</strong>的文件夹链接而没有直接入口</li></ul><p>自从开始写博客以来，怎么管理博客文章的编写和发布一直困扰着我，最近刚好在加强Gitflow工作流，正好将其运用到博客管理上，使得博客的编写和发布更加有条理，现将个人对博客的管理经验与大家分享</p><a id="more"></a><h2 id="为什么要管理文章"><a href="#为什么要管理文章" class="headerlink" title="为什么要管理文章"></a>为什么要管理文章</h2><p>我写博客一般是下班或者午饭过后，都是一些零碎的时间。博客的内容有深有浅，有的能在20分钟内写完，有的要比较长的时间。如果遇到读书笔记之类的，要读完一本书才能完成一篇博客的就时间更长了</p><p>在写博客的时候很可能是多篇博客一起写，我目前有两篇读书笔记还在进行（长期），还有一个关于个人项目的博客（中长期），还有一些短期的想法想要分享，例如这篇博客</p><p>这样在博客发布的时候就笔记复杂了，之前的做法是认为将没有完成的文章剪切到别的地方，然后将已完成的博客用<strong>HEXO</strong>进行部署，这样的方法显得不够灵活，操作复杂且容易丢失博客，试过吃完饭睡个觉忘了把剪切出来的博客复制回去，之前时间太久博客被自己手贱删了。所以就有了用Gitflow来管理博客的想法，通过建立不同的分支来控制各个每篇不同的文章，完成之后再合并到master分支用于发布，更好管理文章的同时也可以加强写git的使用，何乐而不为？</p><h2 id="Gitflow博客管理流程"><a href="#Gitflow博客管理流程" class="headerlink" title="Gitflow博客管理流程"></a>Gitflow博客管理流程</h2><h3 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h3><p>在<a href="https://github.com" target="_blank" rel="noopener">Github</a>上创建存储blog的repository，我创建了一个<a href="https://github.com/zhongjiajie/srcBlog" target="_blank" rel="noopener">srcBlog</a></p><h3 id="对文章的管理"><a href="#对文章的管理" class="headerlink" title="对文章的管理"></a>对文章的管理</h3><ul><li>先将之前已经完成并发布的文章放在<strong>master</strong>分支中</li><li>从<strong>master</strong>分支中<code>checkout</code>一个<strong>develop</strong>分支</li><li>新建文章就从<strong>develop</strong>分支中<code>checkout</code>一个分支进行编写，分支名为<strong>feature-<post_name></strong></li><li>完成了文章的创建就<code>checkout</code>到<strong>develop</strong>分支，<code>git merge --no-ff feature-&lt;post_name&gt;</code></li><li>对于没有完成的文章，或者持续更新的文章（读书笔记、学习日志等），及时的<code>git stash</code>储存或者<code>git push -u feature-&lt;post_name&gt;</code>推送到Github</li><li>对特定文章的编写再<code>git checkout feature-&lt;post_name&gt;</code></li></ul><h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p><img src="gitflow.png" alt="Gitflow"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;update at 2019-01-11: 由于这种方式过于分散,导致换了电脑后就难以恢复博客内容,所以放弃了.&lt;strong&gt;根据一个懒码农的经验,写博客需要的是耐心,而不是高明的博客内容管理方法.&lt;/strong&gt;所以我现在使用的方法是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在个人&lt;a href=&quot;https://github.com/zhongjiajie/zhongjiajie.github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github-page-repo&lt;/a&gt;上面新建一个分支source用于储存全部的源码(包括主题和配置),需要写博客时直接切换到这个分支写完,然后&lt;code&gt;hexo d&lt;/code&gt;完成部署&lt;/li&gt;
&lt;li&gt;如果有多篇文章同时在编写中,没有完成release的,统一将内容放在本人的&lt;a href=&quot;https://github.com/zhongjiajie/zhongjiajie.github.com/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wiki&lt;/a&gt;的&lt;strong&gt;blog-tmp&lt;/strong&gt;文件夹中,这样wiki在本地提交到repo中也会因为没有暴露出&lt;strong&gt;blog-tmp&lt;/strong&gt;的文件夹链接而没有直接入口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从开始写博客以来，怎么管理博客文章的编写和发布一直困扰着我，最近刚好在加强Gitflow工作流，正好将其运用到博客管理上，使得博客的编写和发布更加有条理，现将个人对博客的管理经验与大家分享&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://zhongjiajie.com/categories/Blog/"/>
    
      <category term="Github" scheme="http://zhongjiajie.com/categories/Github/"/>
    
    
  </entry>
  
  <entry>
    <title>pypi安装包制作及发布</title>
    <link href="http://zhongjiajie.com/2017/10/21/pypi%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%B6%E4%BD%9C%E5%8F%8A%E5%8F%91%E5%B8%83/"/>
    <id>http://zhongjiajie.com/2017/10/21/pypi%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%B6%E4%BD%9C%E5%8F%8A%E5%8F%91%E5%B8%83/</id>
    <published>2017-10-21T03:07:26.000Z</published>
    <updated>2020-03-18T04:43:35.895Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如果将自己的程序制作成pypi包并发布到<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a></p><a id="more"></a><h2 id="pypi简介"><a href="#pypi简介" class="headerlink" title="pypi简介"></a>pypi简介</h2><p><a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a>全程是<strong>Python Package Index</strong>，其官方定义是</p><blockquote><p>The Python Package Index is a repository of software for the Python programming language. There are currently 119827 packages here.  – until 2017-10-21</p></blockquote><p>我们平常安装程序所用的<code>pip</code>就是到pypi中找到相应的库并将其安装到本地的，比如我们运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p><code>pip</code>就会去pypi找到最符合<strong>requests</strong>的这个包，然后下载到本地，最后将其安装</p><h2 id="pypi安装包制作"><a href="#pypi安装包制作" class="headerlink" title="pypi安装包制作"></a>pypi安装包制作</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>pypi的库不允许有相同的名称，如果想要跟着教程完成相关的操作的话请先将教程的<code>zhongjiajie</code>改成你的名称（目的是在<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a>找不到相应的库），才能完成库的上传操作</strong></p><h3 id="普通库"><a href="#普通库" class="headerlink" title="普通库"></a>普通库</h3><p>这里的普通库指的是通过<code>from package import function</code>或<code>import package</code>方式调用的库，下面进行具体程序的演示，先切换到项目目录，这里是<strong>myproject</strong></p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">cd Desktop/</span><br><span class="line">mkdir myproject</span><br><span class="line">cd myproject/</span><br></pre></td></tr></table></figure><h4 id="定义库的功能"><a href="#定义库的功能" class="headerlink" title="定义库的功能"></a>定义库的功能</h4><p>创建文件夹<strong>zhongjiajiepypi</strong>并且在其中编写简单的Python函数<strong>myfunction.py</strong>及定义<strong><strong>init</strong>.py</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir zhongjiajiepypi</span><br><span class="line">cd zhongjiajiepypi/</span><br><span class="line">vim __init__.py       # 这个文件作用就是给这个文件夹打成包</span><br><span class="line">vim myfunction.py     # 这里放置逻辑代码了</span><br></pre></td></tr></table></figure><p>其中<strong>myfunction.py</strong>的内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat myfunction.py</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env python</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">def mysum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for v in args:</span><br><span class="line">        i = float(v)</span><br><span class="line">        s += i</span><br><span class="line">    print s</span><br></pre></td></tr></table></figure><p><strong><strong>init</strong>.py</strong>的内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat __init__.py</span></span><br><span class="line">from myfunction import mysum</span><br></pre></td></tr></table></figure><h4 id="编写项目setup-py文件"><a href="#编写项目setup-py文件" class="headerlink" title="编写项目setup.py文件"></a>编写项目setup.py文件</h4><p><strong>这是重点</strong>：接着要编写pypi的setup文件，生成pip可以识别的格式，为后期上传到pypi做准备，我们先切换到<strong>myproject</strong>根目录，然后编辑<strong>setup.py</strong>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim setup.py         <span class="comment"># 写入相应的setup.py内容 详见cat命令结果</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat setup.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env python</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name = "zhongjiajiepypi",</span><br><span class="line">    version = "0.0.1",</span><br><span class="line">    keywords = ("pip", "testpypi"),</span><br><span class="line">    description = "test pip module",</span><br><span class="line">    long_description = "test how to define pip module and upload to pypi",</span><br><span class="line">    license = "MIT",</span><br><span class="line"></span><br><span class="line">    url = "https://zhongjiajie.com",          # your module home page, such as</span><br><span class="line">    author = "zhongjiajie",                         # your name</span><br><span class="line">    author_email = "zhongjiajie955@hotmail.com",    # your email</span><br><span class="line"></span><br><span class="line">    packages = find_packages(),</span><br><span class="line">    include_package_data = True,</span><br><span class="line">    platforms = "any",</span><br><span class="line">    install_requires = []</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们需要注意一下，<strong>setup.py</strong>文件是能不能正确生成pip能识别文件的关键，他有自己的一套格式，我们编写setup文件要遵循这一套格式，实例代码是基础的设置，更多设置请查阅<a href="https://docs.python.org/3/distutils/setupscript.html#additional-meta-data" target="_blank" rel="noopener">Writing the Setup Script</a></p><h3 id="打包pypi"><a href="#打包pypi" class="headerlink" title="打包pypi"></a>打包pypi</h3><p>此时整个包已经编写完成了，整个项目的文件结构是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── zhongjiajiepypi</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── myfunction.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p>现在我们需要将项目变成<strong>pip</strong>能够识别并安装的文件，在本地测试成功后将文件上传到<strong>pypi</strong>，在项目的根目录（setup.py同等位置）中运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist       # 生成二进制包 支持pip安装 推荐使用</span><br><span class="line">python setup.py bdist_egg   # 生成egg 支持easy_install安装</span><br></pre></td></tr></table></figure><p>Python会自动将项目打包成二进制包，此时项目的文件结构是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   └── zhongjiajiepypi-0.0.1.tar.gz</span><br><span class="line">├── zhongjiajiepypi</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── myfunction.py</span><br><span class="line">├── zhongjiajiepypi.egg-info</span><br><span class="line">│   ├── dependency_links.txt</span><br><span class="line">│   ├── PKG-INFO</span><br><span class="line">│   ├── SOURCES.txt</span><br><span class="line">│   └── top_level.txt</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p>此时已算完成了pypi的打包</p><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><p>建议在将包上传到pypi之前现在本地完成测试工作，方法是先进入<strong>dist</strong>文件夹，然后用<code>pip</code>命令安装本地的二进制包，安装完成后测试其中的方法是否可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> dist</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install zhongjiajiepypi-0.0.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python -c <span class="string">"import zhongjiajiepypi; zhongjiajiepypi.mysum(3, 4, 5)"</span></span></span><br><span class="line">12.0</span><br></pre></td></tr></table></figure><p>可以看到结果是12.0证明包能达到预期，可以上传到pypi</p><h4 id="上传到pypi"><a href="#上传到pypi" class="headerlink" title="上传到pypi"></a>上传到pypi</h4><p><strong>注意</strong>: 部分旧版教程会说先运行<code>python setup.py register</code>进行注册，然后再运行<code>python setup.py sdist upload</code>将二进制包上传到pypi上，但是目前pypi已经可以不用注册直接运行<code>python setup.py sdist upload</code>完成上传。</p><p>我们先尝试用<code>python setup.py register</code>，接着输入密码，结果收到下面的提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registering zhongjiajiepypi to https://upload.pypi.org/legacy/</span><br><span class="line">Server response (410): Project pre-registration is no longer required or supported, so continue directly to uploading files.</span><br></pre></td></tr></table></figure><p>可以看到确实不用先注册了，下面我们尝试直接运行<code>python setup.py sdist upload</code>，然后输入密码，结果让我吃了一斤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Submitting dist/zhongjiajiepypi-0.0.1.tar.gz to https://upload.pypi.org/legacy/</span><br><span class="line">Upload failed (403): Invalid or non-existent authentication information.</span><br><span class="line">error: Upload failed (403): Invalid or non-existent authentication information.</span><br></pre></td></tr></table></figure><p>两种方法都不能将本地包上传到pypi，于是我google了原因，看到了github上面相关的链接<a href="https://github.com/pypa/setuptools/issues/941" target="_blank" rel="noopener">Invalid or non-existent authentication information</a>，要新建<code>$HOME/.pypirc</code>文件用于保存pypi的连接信息，尝试了<code>@dover247</code>的文件样例发现仍不能上传到pypi，然后看到<code>@jaraco</code>说那个版本有点旧，就去了<a href="https://docs.python.org/3.6/distutils/packageindex.html#pypirc" target="_blank" rel="noopener">The Python Package Index (PyPI)</a>使用了最新的样例，然后再运行<code>python setup.py sdist upload</code>就能上传成功了（注意国内网络环境访问pypi）</p><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><h3 id="CLI简介"><a href="#CLI简介" class="headerlink" title="CLI简介"></a>CLI简介</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener">CLI</a>（command-line interface，命令行界面）是指可在用户提示符下键入可执行指令的界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。我个人的理解是通过命令行操作调用程序的接口，以达到我们的目的，好处是更加直观、并提供交互式的完成一些简单的操作</p><h3 id="定义Python的CLI接口"><a href="#定义Python的CLI接口" class="headerlink" title="定义Python的CLI接口"></a>定义Python的CLI接口</h3><p>Python的CLI和Python的一般库的做法类似，不同的是它暴露了一个CLI的关键字，调用起来就类似于调用<code>python script_name.py args</code>的形式。他会在<code>$PYTHON_HOME/Scripts</code>生成可运行文件，命令行调用，下面我们把之前的例子改成CLI的调用方式，先修改<strong>zhongjiajiefunction.py</strong>文件，加上命令行传参的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat zhongjiajiefunction.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env python</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">def mysum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for v in args:</span><br><span class="line">        i = float(v)</span><br><span class="line">        s += i</span><br><span class="line">    print s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从此是新加的功能</span></span><br><span class="line">def mysum_cli():</span><br><span class="line">    import sys</span><br><span class="line">    args = sys.argv[1:]</span><br><span class="line">    mysum(*args)</span><br></pre></td></tr></table></figure><p>新加的<code>mysum_cli</code>提供了在命令行获取相关的参数，并将参数传递给原来的<code>mysum</code>函数。接着修改<strong>setup.py</strong>函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat setup.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env python</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name = "zhongjiajiepypi",</span><br><span class="line">    version = "0.0.1",</span><br><span class="line">    keywords = ("pip", "testpypi"),</span><br><span class="line">    description = "test pip module",</span><br><span class="line">    long_description = "test how to define pip module and upload to pypi",</span><br><span class="line">    license = "MIT",</span><br><span class="line"></span><br><span class="line">    url = "https://zhongjiajie.com",</span><br><span class="line">    author = "zhongjiajie",</span><br><span class="line">    author_email = "zhongjiajie955@hotmail.com",</span><br><span class="line"></span><br><span class="line">    packages = find_packages(),</span><br><span class="line">    include_package_data = True,</span><br><span class="line">    platforms = "any",</span><br><span class="line">    install_requires = [],</span><br><span class="line"></span><br><span class="line">    # 此处起是增加的内容</span><br><span class="line">    entry_points = &#123;</span><br><span class="line">        'console_scripts': [</span><br><span class="line">            'mysum=zhongjiajiepypi.zhongjiajiefunction:mysum_cli',</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到只需要在配置中加上<code>entry_points</code>入口选项就行了，其中<code>console_scripts</code>中指定命令行中的关键字，此处为<code>mysum</code>，对应的是<code>zhongjiajiepypi</code>这个库的<code>zhongjiajiefunction</code>函数里面的<code>mysum_cli</code>方法。</p><p>至此完成了CLI的配置，接着根据之前介绍的<a href="#打包pypi">打包pypi</a>的方法进行打包，然后本地测试运行就能得到我们想要的结果了，当和下面一样看到命令行调用<code>mysum 2 3 4</code>的结果是9.0的时候就说明CLI接口已经能正常运行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python setup.py sdist</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> dist</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install zhongjiajiepypi-0.0.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysum 2 3 4</span></span><br><span class="line">9.0</span><br></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>由于pypi不能有同名的库，所以拿样例测试的时候要将名字改成pypi不存在的库名</li><li>上传到pypi已经不用先注册，但要新建<code>$HOME/.pypirc</code>文件填入适当的内容</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.xiaoh.me/2015/12/11/python-egg/" target="_blank" rel="noopener">怎么制作pip安装包，Python Egg</a></p><p><a href="https://zhuanlan.zhihu.com/p/26159930" target="_blank" rel="noopener">如何将自己的程序发布到 PyPI</a></p><p><a href="https://python-packaging.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">How To Package Your Python Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如果将自己的程序制作成pypi包并发布到&lt;a href=&quot;https://pypi.python.org/pypi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pypi&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://zhongjiajie.com/categories/Python/"/>
    
      <category term="pypi" scheme="http://zhongjiajie.com/categories/pypi/"/>
    
    
  </entry>
  
  <entry>
    <title>美女图片API</title>
    <link href="http://zhongjiajie.com/2017/08/30/%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87API/"/>
    <id>http://zhongjiajie.com/2017/08/30/%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87API/</id>
    <published>2017-08-30T01:50:40.000Z</published>
    <updated>2020-03-18T04:00:05.523Z</updated>
    
    <content type="html"><![CDATA[<p>近期重构了之前Github的一个项目<a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">beauty</a>，项目伊始是大学期间为了学习Python及爬虫。项目通过爬虫提供了API访问<a href="http://www.55156.com/gaoqingtaotu/" target="_blank" rel="noopener">55156图库-高清套图</a>，让整个浏览图片的过程显得更加流畅与愉悦</p><a id="more"></a><h2 id="项目更新"><a href="#项目更新" class="headerlink" title="项目更新"></a>项目更新</h2><ul><li>20171017: 上传代码到<a href="https://pypi.python.org/pypi/beauty" target="_blank" rel="noopener">pypi</a>，提供更加便捷的使用方式</li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">zhongjiajie/beauty</a></p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>该项目爬虫的难度不大，但是提供了一种更加流畅与愉悦的看图方式，可以供大家参考。<br><strong>重构原因：</strong>大学期间的爬虫是用了多线程直接把<a href="http://www.55156.com/gaoqingtaotu/" target="_blank" rel="noopener">55156图库-高清套图</a>中的所有图片下载下来，已经达到了爬虫的学习目的但是只能全量抓取，不能有节制的爬取，一是容易带来资源的浪费（跑很久），二是部分的套图质量确实不敢恭维。所以重构的时候就秉持着几个原则：</p><ul><li>提供选择下载什么分类的套图（ugirl、tuigirl等）</li><li>提供选择现在多少个最新的套图</li><li>提供先下载单张小图，然后肉眼筛选再指定下载整个套图</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="clone或下载源码"><a href="#clone或下载源码" class="headerlink" title="clone或下载源码"></a>clone或下载源码</h3><p>从github版本库<a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">zhongjiajie/beauty</a>中clone或下载相应的源码</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>项目根目录运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beauty</span><br></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>tips: <strong>以下命令均在项目根目录运行</strong></p><h4 id="查看Usage及支持的套图类型"><a href="#查看Usage及支持的套图类型" class="headerlink" title="查看Usage及支持的套图类型"></a>查看Usage及支持的套图类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beauty -h</span><br></pre></td></tr></table></figure><ul><li><strong>Usage</strong>： 得知项目主要有两个方法<code>scan</code>和<code>download</code>，其中<code>scan</code>是浏览指定种类和数量的封面图片（小图），<code>download</code>是下载指定种类和数量的套图（大图）。</li><li><strong>Arguments</strong>： 目前支持的套图种类，为<code>scan</code>和<code>download</code>方法的必填项</li><li><strong>Options</strong>： 参数的关键字及对应的解释</li></ul><h4 id="直接下载套图"><a href="#直接下载套图" class="headerlink" title="直接下载套图"></a>直接下载套图</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载秀人套图 默认数量为10 默认路径是./pic</span></span><br><span class="line">beauty download xiuren</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载秀人套图 指定数量为15</span></span><br><span class="line">beauty download xiuren -n 15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载秀人套图 指定路径为D:/</span></span><br><span class="line">beauty download xiuren -p D:/</span><br></pre></td></tr></table></figure><p>完成后可在相应目录下看到下载结果</p><p><img src="beauty_download.png" alt="beauty_download"></p><h4 id="先浏览小图，根据个人喜好（套图质量）下载对应的大图"><a href="#先浏览小图，根据个人喜好（套图质量）下载对应的大图" class="headerlink" title="先浏览小图，根据个人喜好（套图质量）下载对应的大图"></a>先浏览小图，根据个人喜好（套图质量）下载对应的大图</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 浏览秀人套图 默认数量为10 默认路径是./pic/scan</span></span><br><span class="line">beauty scan xiuren</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 浏览秀人套图 指定数量为15</span></span><br><span class="line">beauty scan xiuren -n 15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 浏览秀人套图 指定路径为D:/scan scan方法默认的图片会下载到指定（默认目录）的scan文件夹</span></span><br><span class="line">beauty download xiuren -p D:/</span><br></pre></td></tr></table></figure><p>找到浏览套图文件夹<code>scan</code>，打开图片编辑器查看<code>scan</code>文件夹的图片</p><p><img src="beauty_scan.png" alt="beauty_scan"></p><p>从上图中找到要完整下载的套图，运行下载命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -n参数要和scan方法的参数一样 -f参数列表内部不要留空格</span></span><br><span class="line">beauty download xiuren -n 10 -f [204774,204775,204832]</span><br></pre></td></tr></table></figure><p>完成后可在相应目录下看到下载结果</p><p><img src="beauty_scan_download.png" alt="beauty_scan_download"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="命令行参数库docopt"><a href="#命令行参数库docopt" class="headerlink" title="命令行参数库docopt"></a>命令行参数库docopt</h3><p>获取命令行参数用了<a href="https://github.com/docopt/docopt" target="_blank" rel="noopener">docopt</a>第三方库，docopt通过解析py文件的<code>__doc__</code>文档生成对应的命令行参数解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line"><span class="string">"""Usage:</span></span><br><span class="line"><span class="string">  beauty.py scan &lt;NAME&gt; [-n=&lt;num&gt;] [-p=&lt;path&gt;]</span></span><br><span class="line"><span class="string">  beauty.py download &lt;NAME&gt; [-n=&lt;num&gt;] [-f=&lt;list&gt;] [-p=&lt;path&gt;]</span></span><br><span class="line"><span class="string">  beauty.py (--help | -h)</span></span><br><span class="line"><span class="string">  beauty.py --version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  --help -h                     Show this screen.</span></span><br><span class="line"><span class="string">  --version                     Show version.</span></span><br><span class="line"><span class="string">  --num -n=&lt;num&gt;                Number of picture to download, [default 10].</span></span><br><span class="line"><span class="string">  --filter -f=&lt;list&gt;            Filter from parameter --num album number</span></span><br><span class="line"><span class="string">  --path -p=&lt;path&gt;              Path to download picture, [default `$project/pic/`].</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>上面的代码会自动对命令行的输入进行解析，解析的结果会保存在一个<code>dict</code>类型里面，如我运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beauty download tuigirl -n 10 -p ./path</span><br></pre></td></tr></table></figure><p><code>docopt</code>会自动根据<code>__doc__</code>已经其中的<code>Usage</code>解析，将获取的参数存储成Python中的一个<code>dict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'--filter'</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">'--help'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'--num'</span>: <span class="string">'10'</span>,</span><br><span class="line">    <span class="string">'--path'</span>: <span class="string">'./path'</span>,</span><br><span class="line">    <span class="string">'--version'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'&lt;NAME&gt;'</span>: <span class="string">'tuigirl'</span>,</span><br><span class="line">    <span class="string">'download'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'scan'</span>: <span class="literal">False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爬虫主程序分析"><a href="#爬虫主程序分析" class="headerlink" title="爬虫主程序分析"></a>爬虫主程序分析</h3><p>项目主要依赖于Python2.7开发环境，如果发现自己环境运行不起来，欢迎在github上提<a href="https://github.com/zhongjiajie/beauty/issues/new" target="_blank" rel="noopener">issues</a></p><p>爬虫程序用到的第三方库是<a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a>，提取html中的数据用的是<code>re</code>内置库</p><h4 id="初始化输入及re-compile"><a href="#初始化输入及re-compile" class="headerlink" title="初始化输入及re.compile"></a>初始化输入及re.compile</h4><p>创建实例的时候先对输入进行判断，根据输入执行相应的操作。同时生成多个<code>re.compile</code>对象，用于后期对html的匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成re.compile对象，用于后期html的提取</span></span><br><span class="line">_SMALL_PIC_TMP_REGEX = <span class="string">r'&lt;div class="listBox" id="imgList"&gt;.*?&lt;/div&gt;'</span></span><br><span class="line">_SMALL_PIC_NAME_REGEX = <span class="string">r'&lt;a href="(.*?)" title="(.*?)" class="picLink"&gt;&lt;img src="(.*?)"'</span></span><br><span class="line">_SAMLL_NEXT_PAGE_REGEX = <span class="string">r'&lt;a target=\'_self\' href=\'(.*?)\'&gt;下一页&lt;/a&gt;&lt;/li&gt;'</span></span><br><span class="line">_BIG_PIC_REGEX = <span class="string">r'&lt;img alt=".*?" src="(.*?)" /&gt;'</span></span><br><span class="line">_BIG_NEXT_PAGE_TMP_REGEX = <span class="string">r'&lt;div class="pages"(.*?)&lt;/ul&gt;'</span></span><br><span class="line">_BIG_NEXT_PAGE_REGEX = <span class="string">r'&lt;a href=\'(.*?)\''</span></span><br><span class="line"></span><br><span class="line">_SMALL_PIC_TMP_PATTERN = re.compile(_SMALL_PIC_TMP_REGEX, re.S)</span><br><span class="line">_SMALL_PIC_NAME_PATTERN = re.compile(_SMALL_PIC_NAME_REGEX)</span><br><span class="line">_SAMLL_NEXT_PAGE_PATTERN = re.compile(_SAMLL_NEXT_PAGE_REGEX)</span><br><span class="line">_BIG_PIC_PATTERN = re.compile(_BIG_PIC_REGEX)</span><br><span class="line">_BIG_NEXT_PAGE_TMP_PATTERN = re.compile(_BIG_NEXT_PAGE_TMP_REGEX, re.S)</span><br><span class="line">_BIG_NEXT_PAGE_PATTERN = re.compile(_BIG_NEXT_PAGE_REGEX)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, scan=False, download=False, filter=None, path=None, num=None)</span>:</span></span><br><span class="line">    <span class="string">"""初始化参数及正则表达式"""</span></span><br><span class="line">    self.url = url</span><br><span class="line">    self.is_download = download</span><br><span class="line">    self.is_scan = scan</span><br><span class="line">    self.filter_list = eval(filter) <span class="keyword">if</span> filter <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 默认下载路径是项目根目录./pic</span></span><br><span class="line">    self.path = path <span class="keyword">if</span> path <span class="keyword">else</span> <span class="string">'&#123;dir&#125;/pic'</span>. \</span><br><span class="line">        format(dir=os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</span><br><span class="line">    self.num = int(num) <span class="keyword">if</span> num <span class="keyword">else</span> <span class="number">10</span>  <span class="comment"># 0下载全量 其他下载指定数量</span></span><br></pre></td></tr></table></figure><h4 id="获取网页response"><a href="#获取网页response" class="headerlink" title="获取网页response"></a>获取网页response</h4><p>先通过<code>random.choice</code>方法随机获取文件<code>./beauty/user_agent.py</code>文件中的UA，再通过<code>requests.get</code>方法获取获取网页的response，由于是整个项目获取response的方法，所以要函数的输入的URL应该定义为可变参数，并将函数设置成<code>@staticmethod</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""获取网页源代码"""</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: random.choice(agents)</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4 id="解析response主方法"><a href="#解析response主方法" class="headerlink" title="解析response主方法"></a>解析response主方法</h4><p>该函数主要根据用户输入解析成不同的执命令，<code>scan</code>和<code>download</code>。scan指下载封面的小图片，download下载整个套图的图片，并检查获取的数量是否大于指定的获取数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Beauty主函数"""</span></span><br><span class="line">    <span class="comment"># 获取封面图片URL，套图名称，大图URL</span></span><br><span class="line">    big_pic_name = []</span><br><span class="line">    html = self.get_response(self.url).content</span><br><span class="line">    big_pic_name.extend(self._parse_small_pic(html))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断获取的套图数量是否大于指定数量</span></span><br><span class="line">    <span class="keyword">while</span> len(big_pic_name) &lt; self.num:</span><br><span class="line">        samll_next_page = self._parse_small_next_page(html)</span><br><span class="line">        html = self.get_response(samll_next_page).content</span><br><span class="line">        big_pic_name.extend(self._parse_small_pic(html))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成以套图编号为key的dict</span></span><br><span class="line">    pic_no_dct = &#123;os.path.basename(i[<span class="number">0</span>]).split(<span class="string">'.'</span>)[<span class="number">0</span>]: list(i)</span><br><span class="line">                  <span class="keyword">for</span> i <span class="keyword">in</span> big_pic_name[:self.num]&#125;</span><br><span class="line">    <span class="comment"># 下载指定album</span></span><br><span class="line">    <span class="keyword">if</span> self.filter_list:</span><br><span class="line">        pic_no_dct = &#123;key: pic_no_dct[key] <span class="keyword">for</span> key <span class="keyword">in</span> pic_no_dct</span><br><span class="line">                      <span class="keyword">if</span> int(key) <span class="keyword">in</span> self.filter_list&#125;</span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    <span class="keyword">if</span> self.is_download:</span><br><span class="line">        <span class="keyword">for</span> album <span class="keyword">in</span> pic_no_dct:</span><br><span class="line">            big_pic_url = pic_no_dct[album][<span class="number">0</span>]</span><br><span class="line">            album_name = pic_no_dct[album][<span class="number">1</span>].decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">            html = self.get_response(big_pic_url).content</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self._parse_big_pic(html, url=big_pic_url):</span><br><span class="line">                pic_no_dct[album].append(url)</span><br><span class="line">            folder = <span class="string">u'&#123;album&#125;_&#123;name&#125;'</span>. \</span><br><span class="line">                format(album=album, name=album_name)</span><br><span class="line">            self._download_pic(folder, pic_no_dct[album][<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 浏览图片</span></span><br><span class="line">    <span class="keyword">elif</span> self.is_scan:</span><br><span class="line">        scan_dct = &#123;key: pic_no_dct[key][<span class="number">2</span>] <span class="keyword">for</span> key <span class="keyword">in</span> pic_no_dct&#125;</span><br><span class="line">        self._scan_pic(scan_dct)</span><br></pre></td></tr></table></figure><h4 id="解析大小图片"><a href="#解析大小图片" class="headerlink" title="解析大小图片"></a>解析大小图片</h4><p>解析大小图片，根据<code>parse</code>方法的判断分别执行相应的解析函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_small_pic</span><span class="params">(self, html)</span>:</span></span><br><span class="line">    <span class="string">"""解析小图"""</span></span><br><span class="line">    mid_html = self._SMALL_PIC_TMP_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line">    pic_url_name = self._SMALL_PIC_NAME_PATTERN.findall(mid_html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pic_url_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_small_next_page</span><span class="params">(self, html)</span>:</span></span><br><span class="line">    <span class="string">"""解析下一页小图"""</span></span><br><span class="line">    part_url = self._SAMLL_NEXT_PAGE_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self._subsite_url(part_url)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_big_pic</span><span class="params">(self, html, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""解析大图"""</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> self._parse_big_sub(html, **kwargs):</span><br><span class="line">        <span class="keyword">yield</span> url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_big_sub</span><span class="params">(self, html, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""解析大图子函数"""</span></span><br><span class="line">    next_page_mid = self._BIG_NEXT_PAGE_TMP_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line">    next_page = self._BIG_NEXT_PAGE_PATTERN.findall(next_page_mid)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> self._BIG_PIC_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> next_page != <span class="string">'#'</span>:</span><br><span class="line">        html = self.get_response(os.path.split(kwargs[<span class="string">'url'</span>])[<span class="number">0</span>] + <span class="string">'/'</span> + next_page).content</span><br><span class="line">        next_page_mid = self._BIG_NEXT_PAGE_TMP_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line">        next_page = self._BIG_NEXT_PAGE_PATTERN.findall(next_page_mid)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self._BIG_PIC_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_subsite_url</span><span class="params">(self, part_url)</span>:</span></span><br><span class="line">    <span class="string">"""返回子页面完整url"""</span></span><br><span class="line">    <span class="keyword">return</span> self.url + part_url</span><br></pre></td></tr></table></figure><h2 id="Star-amp-Fork"><a href="#Star-amp-Fork" class="headerlink" title="Star&amp;Fork"></a>Star&amp;Fork</h2><p>如果你觉得有点意思或者使用起来比较方便，欢迎在github上star我的项目<a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">zhongjiajie/beauty</a><br>如果你还有别的需求，或者觉得有需要改进的地方，欢迎提<a href="https://github.com/zhongjiajie/beauty/issues" target="_blank" rel="noopener">issues</a>。<br>如果你想要学习代码获取对项目进行协同开发欢迎Fork或者pull requests</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期重构了之前Github的一个项目&lt;a href=&quot;https://github.com/zhongjiajie/beauty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;beauty&lt;/a&gt;，项目伊始是大学期间为了学习Python及爬虫。项目通过爬虫提供了API访问&lt;a href=&quot;http://www.55156.com/gaoqingtaotu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;55156图库-高清套图&lt;/a&gt;，让整个浏览图片的过程显得更加流畅与愉悦&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://zhongjiajie.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>算法相关</title>
    <link href="http://zhongjiajie.com/2017/07/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://zhongjiajie.com/2017/07/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2017-07-26T08:56:31.000Z</published>
    <updated>2020-03-18T04:43:21.942Z</updated>
    
    <content type="html"><![CDATA[<p>分享一些平时遇到算法相关的程序，其中包括基础的数据算法，矩阵相关算法等</p><a id="more"></a><h2 id="数据算法相关"><a href="#数据算法相关" class="headerlink" title="数据算法相关"></a>数据算法相关</h2><h3 id="随机返回列表的全部元素"><a href="#随机返回列表的全部元素" class="headerlink" title="随机返回列表的全部元素"></a>随机返回列表的全部元素</h3><p>写一个函数，随机返回输入列表的全部元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_lst_val</span><span class="params">(lst)</span>:</span></span><br><span class="line">    len_ = len(lst)</span><br><span class="line">    <span class="keyword">while</span> len_ &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> lst.pop(random.randint(<span class="number">0</span>, len_ - <span class="number">1</span>))</span><br><span class="line">        len_ = len_ - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="最长的没有重复字母的子字符串"><a href="#最长的没有重复字母的子字符串" class="headerlink" title="最长的没有重复字母的子字符串"></a>最长的没有重复字母的子字符串</h3><p>给一个字符串，找出长度最长的且没有重复字符的子字符串，如：<code>abcabcbb</code>-&gt;<code>abc</code>长度是3,<code>bbbbb</code>-&gt;<code>b</code>长度是1,<code>pwwkew</code>-&gt;<code>wke</code>长度是3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_substring</span><span class="params">(str_)</span>:</span></span><br><span class="line">    tmp_longest_word = &#123;&#125;</span><br><span class="line">    word = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str_:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> word:</span><br><span class="line">            word += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp_longest_word[len(word)] = word</span><br><span class="line">            word = i</span><br><span class="line"></span><br><span class="line">    longest_idx = max(tmp_longest_word.keys())</span><br><span class="line">    <span class="keyword">return</span> tmp_longest_word[longest_idx], longest_idx</span><br></pre></td></tr></table></figure><h3 id="将矩阵0元素所在行列置0"><a href="#将矩阵0元素所在行列置0" class="headerlink" title="将矩阵0元素所在行列置0"></a>将矩阵0元素所在行列置0</h3><p>给定一个0、1矩阵，请写一个矩阵转换函数，将所有0所处的行和列所有元素置为0，并分析时间复杂度：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 0          0 0 0</span><br><span class="line">1 0 1   --&gt;    0 0 0</span><br><span class="line">1 1 1          1 0 0</span><br></pre></td></tr></table></figure><p>Python函数</p><ul><li>通过<code>Numpy</code>计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_a_row_col_zero</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param a: array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i, j = np.where(a==<span class="number">0</span>)</span><br><span class="line">    a[i, :] = <span class="number">0</span></span><br><span class="line">    a[:, j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><ul><li>用内置库计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_row_col2zero</span><span class="params">(arr, i, j)</span>:</span></span><br><span class="line">    len_ = len(arr)</span><br><span class="line">    arr[i] = [<span class="number">0</span>] * (len_)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len_):</span><br><span class="line">        arr[idx][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_list</span><span class="params">(l)</span>:</span></span><br><span class="line">    len_ = len(l)</span><br><span class="line">    len_sub = len(l[<span class="number">0</span>])</span><br><span class="line">    copy_ = copy.deepcopy(lst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len_sub):</span><br><span class="line">            <span class="keyword">if</span> lst[i][j] == <span class="number">0</span>:</span><br><span class="line">                change_row_col2zero(copy_, i, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy_</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> transform_list(lst)</span><br></pre></td></tr></table></figure><p>时间复杂度</p><ul><li>用<code>Numpy</code>时间复杂度未知</li><li>用内置库，如果矩阵是方阵且行数为n: O(n^3)</li></ul><h3 id="阿姆斯特朗数"><a href="#阿姆斯特朗数" class="headerlink" title="阿姆斯特朗数"></a>阿姆斯特朗数</h3><p>一个n位正整数等于其各位数字的n次方之和,则称该数为阿姆斯特朗数，例如<code>1^3 + 5^3 + 3^3 = 153</code>，写一个函数，计算所有给定范围内的阿姆斯特朗数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">armstrong_number</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="string">"""用户输入范围的armstrong_number</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :type args: tuple</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 检查用户输入数量</span></span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">3</span>:</span><br><span class="line">        start, end, step = args</span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">2</span>:</span><br><span class="line">        start, end = args</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">1</span>:</span><br><span class="line">        end = args[<span class="number">0</span>]</span><br><span class="line">        start, step = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> xrange(start, end, step):</span><br><span class="line">        <span class="comment"># 指数位数和</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 指数</span></span><br><span class="line">        n = len(str(num))</span><br><span class="line"></span><br><span class="line">        temp = num</span><br><span class="line">        <span class="keyword">while</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">            digit = temp % <span class="number">10</span></span><br><span class="line">            sum += digit ** n</span><br><span class="line">            temp //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num == sum:</span><br><span class="line">            <span class="keyword">yield</span> num</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列定义：<code>F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)</code>，例如0,1,1,2,3,5…给一个通用函数，输入数列最大值，得到一系列斐波那契数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= max:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br></pre></td></tr></table></figure><h3 id="任意连续整数阶乘的和"><a href="#任意连续整数阶乘的和" class="headerlink" title="任意连续整数阶乘的和"></a>任意连续整数阶乘的和</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, map(<span class="keyword">lambda</span> x: x * x, range(<span class="number">1</span>, n + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><h3 id="任意连续区间的素数、质数"><a href="#任意连续区间的素数、质数" class="headerlink" title="任意连续区间的素数、质数"></a>任意连续区间的素数、质数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(start, stop)</span>:</span></span><br><span class="line">    <span class="comment"># 要求x大于2并且x在区间[2, x)中没有整除的除数</span></span><br><span class="line">    <span class="keyword">return</span> filter(<span class="keyword">lambda</span> x: x &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> [x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, x) <span class="keyword">if</span> x % i == <span class="number">0</span>],</span><br><span class="line">                  range(start, stop + <span class="number">1</span>))   <span class="comment"># 取出质数,x从range(start,stop) 取的数</span></span><br></pre></td></tr></table></figure><h3 id="字典中最大的value对应的keys"><a href="#字典中最大的value对应的keys" class="headerlink" title="字典中最大的value对应的keys"></a>字典中最大的value对应的keys</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dct_max_val_key</span><span class="params">(dct)</span>:</span></span><br><span class="line">    max_value = max(dct.values())</span><br><span class="line">    keys = [k <span class="keyword">for</span> k, v <span class="keyword">in</span> dct.items() <span class="keyword">if</span> k == max_value]</span><br><span class="line">    <span class="comment"># 最大值对应的key可能有一个或者多个</span></span><br><span class="line">    <span class="keyword">return</span> keys[<span class="number">0</span>] <span class="keyword">if</span> len(keys) == <span class="number">1</span> <span class="keyword">else</span> keys</span><br></pre></td></tr></table></figure><h3 id="字符串最长且相邻元素不相同的子字符串"><a href="#字符串最长且相邻元素不相同的子字符串" class="headerlink" title="字符串最长且相邻元素不相同的子字符串"></a>字符串最长且相邻元素不相同的子字符串</h3><p>找出一个字符串中最长的相邻字符串中不重复的子字符串，并输出字符串的长度。如 11101111，最长是3，子字符串是101。110011 最长是2 子字符串是10 或 01</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_large_sub_str</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""只能找到最长的长度，当有多个值重复的时候不能找到全部最长的子字符串"""</span></span><br><span class="line">    sub_str = <span class="string">''</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    dct = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> pre != i:</span><br><span class="line">            sub_str += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dct[len(sub_str)] = sub_str</span><br><span class="line">            sub_str = pre</span><br><span class="line">        pre = i</span><br><span class="line"></span><br><span class="line">    max_key = max(dct.iterkeys())</span><br><span class="line">    <span class="keyword">return</span> max_key, dct[max_key]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_large_sub_str_1</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""能找到重复的长度的子字符串"""</span></span><br><span class="line">    sub_str = <span class="string">''</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    dct = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> pre != i:</span><br><span class="line">            sub_str += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dct[sub_str] = len(sub_str)</span><br><span class="line">            sub_str = pre</span><br><span class="line">        pre = i</span><br><span class="line"></span><br><span class="line">    max_val = max(dct.itervalues())</span><br><span class="line">    keys = [k <span class="keyword">for</span> k, v <span class="keyword">in</span> dct.items() <span class="keyword">if</span> v == max_val]</span><br><span class="line">    <span class="keyword">return</span> max_val, keys[<span class="number">0</span>] <span class="keyword">if</span> len(keys) == <span class="number">1</span> <span class="keyword">else</span> keys</span><br></pre></td></tr></table></figure><h3 id="字符串str中的连续最长的数字串"><a href="#字符串str中的连续最长的数字串" class="headerlink" title="字符串str中的连续最长的数字串"></a>字符串str中的连续最长的数字串</h3><p>读入一个字符串str，输出字符串str中的连续最长的数字串。例如：abcd12345ed125ss123456789 输出：123456789</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_longest_int</span><span class="params">(s)</span>:</span></span><br><span class="line">    result_dict = &#123;&#125;</span><br><span class="line">    int_set = set([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>)])</span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> int_set:</span><br><span class="line">            tmp += i</span><br><span class="line">        <span class="keyword">elif</span> tmp:</span><br><span class="line">            result_dict[tmp] = len(tmp)</span><br><span class="line">            tmp = <span class="string">''</span></span><br><span class="line">    <span class="comment"># 防止最后还有一个值</span></span><br><span class="line">    <span class="keyword">if</span> tmp:</span><br><span class="line">        result_dict[tmp] = len(tmp)</span><br><span class="line"></span><br><span class="line">    max_val = max(result_dict.values())</span><br><span class="line">    key = [key <span class="keyword">for</span> key <span class="keyword">in</span> result_dict <span class="keyword">if</span> result_dict[key] == max_val]</span><br><span class="line">    <span class="keyword">return</span> key[<span class="number">0</span>] <span class="keyword">if</span> len(key) == <span class="number">1</span> <span class="keyword">else</span> key</span><br><span class="line"></span><br><span class="line">s = <span class="string">'abcd12345ed125ss123456789'</span></span><br><span class="line"><span class="keyword">print</span> str_longest_int(s)</span><br></pre></td></tr></table></figure><h3 id="字符数组最后一个单词长度"><a href="#字符数组最后一个单词长度" class="headerlink" title="字符数组最后一个单词长度"></a>字符数组最后一个单词长度</h3><p>输入：”Hello World “。输出：5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_word_len</span><span class="params">(s)</span>:</span></span><br><span class="line">    len_ = len(s)</span><br><span class="line">    curr = <span class="number">0</span></span><br><span class="line">    index = <span class="number">-1</span></span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> curr &lt; len_:</span><br><span class="line">        <span class="keyword">if</span> s[index] != <span class="string">' '</span>:</span><br><span class="line">            tmp += s[index]</span><br><span class="line">        <span class="comment"># 避免倒数第一个是' '</span></span><br><span class="line">        <span class="keyword">elif</span> index != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(tmp)</span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        curr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只要一个单词的情况</span></span><br><span class="line">    <span class="keyword">return</span> len(s.strip())</span><br><span class="line"></span><br><span class="line">s = <span class="string">"Hello_World "</span></span><br><span class="line"><span class="keyword">print</span> last_word_len(s)</span><br></pre></td></tr></table></figure><h3 id="数组中找指定和"><a href="#数组中找指定和" class="headerlink" title="数组中找指定和"></a>数组中找指定和</h3><p>数组A由1000万个随机正整数(int)组成，设计算法，给定整数n，在A中找出a和 b，使其符合如下等式：n = a + b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">题目数据量大看似吓人 但是还是要透过现象看本质</span></span><br><span class="line"><span class="string">set用于去重 如果set太大也可以改成bitmap</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_1</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="string">"""标准leetcode的twosum问题"""</span></span><br><span class="line">    mid_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> mid_dict:</span><br><span class="line">            <span class="keyword">return</span> val, mid_dict[val]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid_dict[n - val] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_2</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="string">"""根据问题调整成set格式"""</span></span><br><span class="line">    mid_set = set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> mid_set:</span><br><span class="line">            <span class="keyword">return</span> val, n - val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid_set.add(n - val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"><span class="keyword">print</span> two_sum_1(a, n)</span><br><span class="line"><span class="keyword">print</span> two_sum_2(a, n)</span><br></pre></td></tr></table></figure><h3 id="判断重量"><a href="#判断重量" class="headerlink" title="判断重量"></a>判断重量</h3><p>给定两颗钻石的编号g1、g2，编号从1开始，同时给定关系数组vector，其中元素为一些二元组，第一个元素为一次比较中较重的钻石的编号，第二个元素为较轻的钻石的编号。最后给定之前的比较次数n。请返回这两颗钻石的关系，若g1更重返回1，g2更重返回-1，无法判断返回0。输入数据保证合法，不会有矛盾情况出现。输入：2,3,[[1,2],[2,4],[1,3],[4,3]],4 返回:1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">* 根据描述简历一个有向图 在图中找到指定两点之间是否有路径</span></span><br><span class="line"><span class="string">* 钻石编号是顶点，比较关系是边，生成有向图。先做两个顶点是否可达判断，再进行拓扑排序</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span><span class="params">(x, y, l, n)</span>:</span></span><br><span class="line">    <span class="string">"""用递归调用 看是否有大小关系"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> l[i][<span class="number">0</span>] == x:</span><br><span class="line">            <span class="keyword">if</span> l[i][<span class="number">1</span>] == y:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> bigger(l[i][<span class="number">1</span>], y, l, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(g1, g2, p, n)</span>:</span></span><br><span class="line">    <span class="string">"""要经过两次比较 比价g1 g2谁更大"""</span></span><br><span class="line">    tag = bigger(g1, g2, p, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先交换后比较</span></span><br><span class="line">    <span class="keyword">if</span> tag != <span class="number">1</span>:</span><br><span class="line">        tag = bigger(g2, g1, p, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tag == <span class="number">1</span>:</span><br><span class="line">            tag = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> tag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> compare(<span class="number">2</span>, <span class="number">3</span>, [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>]], <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> compare(<span class="number">3</span>, <span class="number">2</span>, [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>]], <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="每隔两个数删除一个数"><a href="#每隔两个数删除一个数" class="headerlink" title="每隔两个数删除一个数"></a>每隔两个数删除一个数</h3><p>有一个整型数组a[n]顺序存放0~n-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。<br>以8个数(n=8)为例:｛0，1，2，3，4，5，6，7｝，0-&gt;1-&gt;2(删除)-&gt;3-&gt;4-&gt;5(删除)-&gt;6-&gt;7-&gt;0(删除)，如此循环直到最后一个数被删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">生成一个循环链表，一个值记录当前索引，当索引能被2整除且不为0时，删除该值，知道链表只剩一个元素</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><p>LeetCode[3]:<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p><p>Given a string, find the length of the longest substring without repeating characters.<br>Examples:<br>Given “abcabcbb”, the answer is “abc”, which the length is 3.<br>Given “bbbbb”, the answer is “b”, with the length of 1.<br>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s)</span>:</span></span><br><span class="line">    start = maxLength = <span class="number">0</span></span><br><span class="line">    usedChar = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">            start = usedChar[s[i]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxLength = max(maxLength, i - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        usedChar[s[i]] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一些平时遇到算法相关的程序，其中包括基础的数据算法，矩阵相关算法等&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://zhongjiajie.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>sql实现小记</title>
    <link href="http://zhongjiajie.com/2017/06/24/sql%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AE%B0/"/>
    <id>http://zhongjiajie.com/2017/06/24/sql%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AE%B0/</id>
    <published>2017-06-24T09:08:41.000Z</published>
    <updated>2020-03-18T03:59:53.232Z</updated>
    
    <content type="html"><![CDATA[<p>项目及开源学习中经常有些sql需要写，其中一些sql逻辑比较简单，但是另外的一个还是要思考一段时间的，本文就是把这部分需要思考一段时间的sql记录下来，可以与大家分享的同时，也可以避免长期未使用而遗忘。</p><a id="more"></a><h2 id="单表自关联"><a href="#单表自关联" class="headerlink" title="单表自关联"></a>单表自关联</h2><h3 id="分组排序累加"><a href="#分组排序累加" class="headerlink" title="分组排序累加"></a>分组排序累加</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp1(</span><br><span class="line">    os_type <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'源系统'</span>,</span><br><span class="line">    <span class="keyword">hours</span> <span class="built_in">varchar</span>(<span class="number">4</span>) <span class="keyword">comment</span> <span class="string">'时间-小时'</span>,</span><br><span class="line">    count_num <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'数量'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'01'</span>, <span class="number">600</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'02'</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'03'</span>, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'04'</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'05'</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'06'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'01'</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'02'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'01'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>求表各个<code>os_type</code>(系统)按照<code>hours</code>(时间)排序，并且累加<code>count_num</code>的值。单表通过<code>os_type</code>自关联，用时间进行过滤，然后再分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.os_type</span><br><span class="line">     , t1.hours</span><br><span class="line">     , <span class="keyword">sum</span>(t2.count_num)</span><br><span class="line"><span class="keyword">from</span> tmp1 t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> tmp1 t2</span><br><span class="line">  <span class="keyword">on</span> t1.os_type = t2.os_type</span><br><span class="line"><span class="comment">-- 通过where排除不符合条件的内容</span></span><br><span class="line"><span class="keyword">where</span> t1.hours &gt;= t2.hours</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.os_type, t1.hours</span><br></pre></td></tr></table></figure><h2 id="使用临时变量部分"><a href="#使用临时变量部分" class="headerlink" title="使用临时变量部分"></a>使用临时变量部分</h2><p>很多从Oracle转来使用MySQL的同学都会抱怨，很多Oracle内置的函数Mysql都不支持，这部分主要讨论使用MySQL临时变量完成部分Oracle函数的功能。主要实现的函数有三种排序并标序号，[row_number ()partition over](#partition row_number), [rank() partition over](#partition rank), [dense_rank() partition over](#partition dense_rank)几个功能。</p><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>首先对将要测试的数据进行建表，运行下面建表及初始化数据的sql脚本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- drop table if exists employee;</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee (</span><br><span class="line">    empid <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'员工编号'</span>,</span><br><span class="line">    deptid <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'部门编号'</span>,</span><br><span class="line">    salary <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'工资'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">8</span>,<span class="number">50</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">14</span>,<span class="number">50</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">12</span>,<span class="number">20</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">7</span>,<span class="number">40</span>,<span class="number">44500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">20</span>,<span class="number">1900</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">40</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">20</span>,<span class="number">4800</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">13</span>,<span class="number">20</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">10</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">20</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">9</span>,<span class="number">50</span>,<span class="number">7500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">9</span>,<span class="number">50</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">6</span>,<span class="number">40</span>,<span class="number">14500</span>);</span><br></pre></td></tr></table></figure><p>查看表<code>employee</code>中的数据，<code>select * from employee;</code>可以看到如图：<br><img src="employee%E5%85%A8%E9%83%A8%E6%95%B0%E6%8D%AE.png" alt="employee全部数据"></p><h2 id="三种排序标序号"><a href="#三种排序标序号" class="headerlink" title="三种排序标序号"></a>三种排序标序号</h2><p>这部分主要针对MySQL中没有分组(partition)的排序，即对选择的所有记录进行排序，其中分为简单的标号排序，不跳过排序的并列值，跳过排序的并列值。sql实现难度也从简单到困难，下面对这三种标号的排序进行说明。</p><h3 id="单纯标号排序"><a href="#单纯标号排序" class="headerlink" title="单纯标号排序"></a>单纯标号排序</h3><p>单纯对工资排序，即使值重复序号也不一样，不会因为值重复就跳过重复的数量。</p><p>他的实现逻辑是编写一个按照要排序的字段(这里是salary字段)的升序后降序子查询t1，这样就能得到按照工资降序的临时子查询表t1。然后和临时变量@rank进行关联，每次在最外层查询select字段的时候，都将临时变量@rank的值加一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 只按照工资从高到低排名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t1.empid</span><br><span class="line">     , t1.deptid</span><br><span class="line">     , t1.salary</span><br><span class="line">     , @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> empid</span><br><span class="line">         , deptid</span><br><span class="line">         , salary</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> @<span class="keyword">rank</span> := <span class="number">0</span></span><br><span class="line">) t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行上面的sql会看到下面的结果：<br><img src="%E6%8E%92%E5%BA%8F.png" alt="排序"></p><h3 id="排序不跳过并列序号"><a href="#排序不跳过并列序号" class="headerlink" title="排序不跳过并列序号"></a>排序不跳过并列序号</h3><p>对工资进行排序，工资相同排序相同，有并列排名时不会跳过。在<a href="#单纯标号排序">单纯标号排序</a>的基础上比较每两个相邻的salary的值，当连续的salary相同时排名相同。</p><p>先按照要排序的字段(salary)进行升序或降序，生成一个临时表t1，然后和临时变量<code>@rank</code>(记录当前排名)，<code>@pre_salary</code>(记录上一条记录salary的值)进行关联。在最外层的查询中，表达式<code>@pre_salary != (@pre_salary := salary)</code>是判断当前的salary和<code>@pre_salary</code>是否相等，当两个值相等，是表达式为0，反之为1。所以外层查询选择的第四个字段相等于<code>@rank = @rank + (0 or 1)</code>，这样就能实现当salary相同时排名相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 对工资进行排序，工资相同排序相同，但不会跳过排名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t1.empid</span><br><span class="line">     , t1.deptid</span><br><span class="line">     , t1.salary</span><br><span class="line">     <span class="comment">-- @rank = @rank + (0 or 1) 如果表达式@pre_salary != (@pre_salary := salary)为True就是1 否则就是0</span></span><br><span class="line">     , @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + (@pre_salary != (@pre_salary := salary)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> empid</span><br><span class="line">         , deptid</span><br><span class="line">         , salary</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- @rank记录当前的排名 @pre_salary记录salary的上一个值</span></span><br><span class="line">    <span class="keyword">select</span> @<span class="keyword">rank</span> := <span class="number">0</span></span><br><span class="line">         , @pre_salary := <span class="number">-1</span></span><br><span class="line">) t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行上面的sql会看到下面的结果：<br><img src="%E6%8E%92%E5%BA%8F_%E9%87%8D%E5%A4%8D%E4%B8%8D%E8%B7%B3%E8%BF%87%E5%BA%8F%E5%8F%B7.png" alt="排序_重复不跳过序号"></p><h3 id="排序跳过并列序号"><a href="#排序跳过并列序号" class="headerlink" title="排序跳过并列序号"></a>排序跳过并列序号</h3><p>对工资进行排序，工资相同排序相同，有并列排名时会跳过。排序跳过并列序号是<a href="#排序不跳过并列序号">排序不跳过并列序号</a>的升级版，其难点是要比较两个连续salary是否相等的同时，记录连续salary出现的次数<code>@skip_num</code>。当两个连续salary不相等的时候，<code>@rank</code>的值除了要加一外，还要加上<code>@skip_num</code>的值。</p><p>先生成按照salary降序的临时表t1，临时变量<code>@rank</code>用于计算当前排名，<code>@skip_num</code>用于记录连续相同salary的次数，<code>@pre_salary_1</code>和<code>@pre_salary_2</code>均用于判断当前记录salary和前一条记录的salary是否相等，前者为<code>@rank</code>服务，后者为<code>@skip_num</code>服务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 对工资进行排序，工资相同排序相同，有并列排名时会跳过</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t3.empid</span><br><span class="line">     , t3.deptid</span><br><span class="line">     , t3.salary</span><br><span class="line">     , t3.rank</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> t1.empid</span><br><span class="line">       , t1.deptid</span><br><span class="line">       , t1.salary</span><br><span class="line">       <span class="comment">-- 当前值和之前的值一样，即@pre_salary_1 = (@pre_salary_1 := salary)时 取之前的排名@rank 不一样时取当前排名@rank+1+之前跳过的排名@skip_num</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_salary_1 = (@pre_salary_1 := salary), @<span class="keyword">rank</span>, @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span> + @skip_num</span><br><span class="line">            ) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line">       <span class="comment">-- @skip_num保存同一排名出现的次数 @pre_salary_2 = (@pre_salary_2 := salary)是就说明同一排名出现一次</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_salary_2 = (@pre_salary_2 := salary), @skip_num := @skip_num + <span class="number">1</span>, @skip_num := <span class="number">0</span></span><br><span class="line">            ) <span class="keyword">as</span> _skip_num</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">      <span class="keyword">select</span> empid</span><br><span class="line">           , deptid</span><br><span class="line">           , salary</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">  ) t1</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- @rank记录当前的排名 @pre_salary_1和@pre_salary_2记录salary的前一个值 @pre_salary_1用于计算排名是否增加 @pre_salary_2是中间变量确定排名跳过的数量，即@skip_num</span></span><br><span class="line">      <span class="keyword">select</span> @<span class="keyword">rank</span> := <span class="number">0</span></span><br><span class="line">           , @pre_salary_1 := <span class="number">-1</span></span><br><span class="line">           , @pre_salary_2 := <span class="number">-1</span></span><br><span class="line">           , @skip_num := <span class="number">0</span></span><br><span class="line">  ) t2</span><br><span class="line">) t3</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行上面的sql会看到下面的结果：<br><img src="%E6%8E%92%E5%BA%8F_%E9%87%8D%E5%A4%8D%E8%B7%B3%E8%BF%87%E5%BA%8F%E5%8F%B7.png" alt="排序_重复跳过序号"></p><h2 id="实现oracle相关分析函数功能"><a href="#实现oracle相关分析函数功能" class="headerlink" title="实现oracle相关分析函数功能"></a>实现oracle相关分析函数功能</h2><p>这部分主要实现了Oracle相关的分析函数，包括[row_number](#partition row_number), [rank](#partition rank), [dense_rank](#partition dense_rank)三个分析函数。</p><h3 id="partition-row-number"><a href="#partition-row-number" class="headerlink" title="partition row_number"></a>partition row_number</h3><p>实现Oracle的row_number() partition over方法，要达到的目的是先对源数据按其中一个字段(deptid)进行分组，再在分组中按照另一个字段(salary)升序或降序排序，并进行标号。</p><p>其实现逻辑是，生成一张按照deptid和salary排序的临时表，然后和临时变量<code>@pre_dept</code>和<code>@rank</code>进行关联，其中<code>@pre_dept</code>表示前一条记录部门的值，<code>@rank</code>表示排名。主要的实现在外层查询的<code>if (@pre_dept = (@pre_dept := deptid), @rank := @rank + 1, @rank := 1)</code>中，如果当前deptid和前一条记录的deptid相同时，说明是在同一个deptid的分组中，排名<code>@rank</code>就增加1；如果当前的deptid和前一条记录的deptid不相同，说明deptid分组已经变化了，排名<code>@rank</code>要重新从1开始计算，所以<code>@rank:=1</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Oracle row_number方法</span></span><br><span class="line"><span class="comment">-- 按照部门分组 每组进行排序</span></span><br><span class="line"><span class="comment">-- 排序逻辑 按工资高低排序 同样工资不同顺序</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t1.empid</span><br><span class="line">     , t1.deptid</span><br><span class="line">     , t1.salary</span><br><span class="line">     <span class="comment">-- 如果当前deptid(即@pre_dept := deptid) != 之前的deptid(即@pre_dept) 就令当前排序初始化为1(即@rank := 1);</span></span><br><span class="line">     <span class="comment">-- 如果等于之前的deptid 就在原来的排序上加一(即@rank := @rank + 1)</span></span><br><span class="line">     , <span class="keyword">if</span> (</span><br><span class="line">            @pre_dept = (@pre_dept := deptid), @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span> := <span class="number">1</span></span><br><span class="line">          ) <span class="keyword">as</span> _row_number</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 第一步 通过这里控制 以deptid分组 以salary降序</span></span><br><span class="line">    <span class="keyword">select</span> empid</span><br><span class="line">         , deptid</span><br><span class="line">         , salary</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> deptid, salary <span class="keyword">desc</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 此处要选一个异常值(不会在数据中出现的值) 尽量别用null 因为null有陷阱</span></span><br><span class="line">    <span class="keyword">select</span> @pre_dept := <span class="number">-1</span></span><br><span class="line">         , @<span class="keyword">rank</span> := <span class="number">-1</span></span><br><span class="line">) t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行上面的sql会看到下面的结果：<br><img src="row_number_partition_over.png" alt="row_number_partition_over"></p><h3 id="partition-rank"><a href="#partition-rank" class="headerlink" title="partition rank"></a>partition rank</h3><p>实现Oracle的rank() partition over方法，是[row_number](#partition row_number)的升级版。要达到的目的是先对源数据按其中一个字段(deptid)进行分组，再在分组中按照另一个字段(salary)升序或降序排序，并进行排序，此时的排序允许有并列序号，但是不会跳过并列序号的次数。</p><p>最外层查询只是为了选择<code>@pre_salary</code>变量的值，主要逻辑集中在次外层查询。首先在employee表中按照部门和工资排序，得到子查询t1，再和<code>@pre_dept</code>(前一条记录的部门), <code>@rank</code>(排名), <code>@pre_salary</code>(前一条记录的工资)关联。在次外层查询中，满足当前部门(deptid)和前一条记录的部门(<code>@pre_salary</code>)相等，并且当前记录工资(salary)和前一条记录工资(<code>@pre_salary</code>)相等时，说明是同一个部门并且工资相同，所以排序(<code>@rank</code>)值不变；仅是部门相等但是工资不等，则说明同一部门但是工资不同，所以<code>@rank + 1</code>；回到sql次外层查询中最外层的if条件，当前部门和前一条记录的部门不相等时，则部门变了，排序要重新开始，所以<code>@rank := 1</code>。注意次外层查询中，单独<code>@pre_salary := salary</code>进行赋值，防止当外层if条件不满足时，在内层sql写<code>@pre_salary = (@pre_salary := salary)</code>不能更新<code>@pre_salary</code>的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 实现Oracle的rank() partition over方法</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t3.empid</span><br><span class="line">     , t3.deptid</span><br><span class="line">     , t3.salary</span><br><span class="line">     , t3._rank_over</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> t1.empid</span><br><span class="line">       , t1.deptid</span><br><span class="line">       , t1.salary</span><br><span class="line">       <span class="comment">-- 如果当前deptid(即@pre_dept := deptid) != 之前的deptid(即@pre_dept) 就令当前排序初始化为1(即@rank := 1);</span></span><br><span class="line">       <span class="comment">-- 如果等于之前的deptid 就在原来的排序上加一(即@rank := @rank + 1)</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_dept = (@pre_dept := deptid)</span><br><span class="line">              <span class="comment">-- 如果部门相等 比较同部门的工资是否相等</span></span><br><span class="line">              , <span class="keyword">if</span> (</span><br><span class="line">                     @pre_salary = salary, @<span class="keyword">rank</span>, @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span></span><br><span class="line">                   )</span><br><span class="line">              , @<span class="keyword">rank</span> := <span class="number">1</span></span><br><span class="line">            ) <span class="keyword">as</span> _rank_over</span><br><span class="line">       <span class="comment">-- 单独保存本次salary的值 放在@pre_dept = (@pre_dept := deptid)里面会因为条件不一样导致结果不同</span></span><br><span class="line">       , @pre_salary := salary</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 第一步 通过这里控制 以deptid分组 以salary降序</span></span><br><span class="line">      <span class="keyword">select</span> empid</span><br><span class="line">           , deptid</span><br><span class="line">           , salary</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> deptid, salary <span class="keyword">desc</span></span><br><span class="line">  ) t1</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 此处要选一个异常值(不会在数据中出现的值) 尽量别用null 因为null有陷阱</span></span><br><span class="line">      <span class="keyword">select</span> @pre_dept := <span class="number">-1</span></span><br><span class="line">           , @<span class="keyword">rank</span> := <span class="number">-1</span></span><br><span class="line">           , @pre_salary := <span class="number">-1</span></span><br><span class="line">  ) t2</span><br><span class="line">) t3</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行上面的sql会看到下面的结果：<br><img src="rank_partition_oreder.png" alt="rank_partition_oreder"></p><h3 id="partition-dense-rank"><a href="#partition-dense-rank" class="headerlink" title="partition dense_rank"></a>partition dense_rank</h3><p>实现Oracle的dense_rank() partition over方法，是[rank](#partition rank)方法的升级版。在rank方法的基础上，如果有重复的序号，要跳过重复的次数。</p><p>先按照部门和工资排序，生成子查询t1。和临时变量<code>@pre_dept</code>(上一条记录部门的值)，<code>@rank</code>(当前数据排名)，<code>@pre_salary</code>(上一条记录工资的值)，<code>@skip_num</code>(该部门分组该排名需要跳过的值)进行关联。其中排名实现在[rank](#partition rank)方法上加上<code>@skip_num</code>值，所以剩下的问题是确定<code>@skip_num</code>的值。若当前工资的值和上一条记录中工资的值相等，<code>@skip_num</code>的值就加一，反之<code>@skip_num</code>均赋值为0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- oracle dense_rank() over 方法</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t3.empid</span><br><span class="line">     , t3.deptid</span><br><span class="line">     , t3.salary</span><br><span class="line">     , t3._dense_rank_over</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> t1.empid</span><br><span class="line">       , t1.deptid</span><br><span class="line">       , t1.salary</span><br><span class="line">       <span class="comment">-- 如果当前deptid(即@pre_dept := deptid) != 之前的deptid(即@pre_dept) 就令当前排序初始化为1(即@rank := 1);</span></span><br><span class="line">       <span class="comment">-- 如果等于之前的deptid 就在原来的排序上加一(即@rank := @rank + 1)</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_dept = (@pre_dept := deptid)</span><br><span class="line">              <span class="comment">-- 如果部门相等 比较同部门的工资是否相等</span></span><br><span class="line">              , <span class="keyword">if</span> (</span><br><span class="line">                     @pre_salary = salary, @<span class="keyword">rank</span>, @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span> + @skip_num</span><br><span class="line">                   )</span><br><span class="line">              , @<span class="keyword">rank</span> := <span class="number">1</span></span><br><span class="line">            ) <span class="keyword">as</span> _dense_rank_over</span><br><span class="line">       <span class="comment">-- 单独保存本次salary的值 放在@pre_dept = (@pre_dept := deptid)里面会因为条件不一样导致结果不同</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_salary = salary, @skip_num := @skip_num + <span class="number">1</span>, @skip_num := <span class="number">0</span></span><br><span class="line">            ) <span class="keyword">as</span> _skip_num</span><br><span class="line">       , @pre_salary := salary</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 第一步 通过这里控制 以deptid分组 以salary降序</span></span><br><span class="line">      <span class="keyword">select</span> empid</span><br><span class="line">           , deptid</span><br><span class="line">           , salary</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> deptid, salary <span class="keyword">desc</span></span><br><span class="line">  ) t1</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 此处要选一个异常值(不会在数据中出现的值) 尽量别用null 因为null有陷阱</span></span><br><span class="line">      <span class="keyword">select</span> @pre_dept := <span class="number">-1</span></span><br><span class="line">           , @<span class="keyword">rank</span> := <span class="number">-1</span></span><br><span class="line">           , @pre_salary := <span class="number">-1</span></span><br><span class="line">           , @skip_num := <span class="number">0</span></span><br><span class="line">  ) t2</span><br><span class="line">) t3</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>运行上面的sql会看到下面的结果：<br><img src="dense_rank_partition_order.png" alt="dense_rank_partition_order"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目及开源学习中经常有些sql需要写，其中一些sql逻辑比较简单，但是另外的一个还是要思考一段时间的，本文就是把这部分需要思考一段时间的sql记录下来，可以与大家分享的同时，也可以避免长期未使用而遗忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://zhongjiajie.com/categories/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql_schedule_backup定时备份mysql工具</title>
    <link href="http://zhongjiajie.com/2017/06/12/mysql-schedule-backup%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDmysql%E5%B7%A5%E5%85%B7/"/>
    <id>http://zhongjiajie.com/2017/06/12/mysql-schedule-backup%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDmysql%E5%B7%A5%E5%85%B7/</id>
    <published>2017-06-12T12:22:25.000Z</published>
    <updated>2020-03-18T04:05:29.446Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/zhongjiajie/mysql_schedule_backup" target="_blank" rel="noopener">mysql_schedule_backup</a>是定时、全量备份指定mysql数据库的程序。可设置是否压缩备份文件、备份文件保留的天数。<br>使用场景是简单的备份逻辑，通过<a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">schedule</a>就能满足的备份逻辑，没有DAG流程。</p><a id="more"></a><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><ul><li>schedule==0.4.2</li></ul><h2 id="How-to-run"><a href="#How-to-run" class="headerlink" title="How to run"></a>How to run</h2><ul><li>先安装schedule</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install schedule</span><br></pre></td></tr></table></figure><ul><li>根据demo配置<code>conf.py</code>中相关的备份信息</li><li>修改<code>mysql_schedule_backup.py</code>文件中<code>schedule.every().day.at(&quot;06:00&quot;).do(backup_mysql, bacup_conf)</code>为你的业务时间</li><li>在mysql_schedule_backup目录下运行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python mysql_schedule_backup.py</span><br></pre></td></tr></table></figure><h2 id="备份结果"><a href="#备份结果" class="headerlink" title="备份结果"></a>备份结果</h2><ul><li>备份是文件夹或者压缩文件，以备份时间为名称</li><li>文件夹（压缩文件）里面分为<code>*.sql</code>和<code>*.json</code>两类文件，其中<code>conf.json</code>为备份的配置文件，<code>*.sql</code>为备份的主文件，以<code>datetime_database.sql</code>方式命名</li><li>最终的备份样例</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─20170611</span><br><span class="line">     ├─20170611_sakila.sql</span><br><span class="line">     ├─20170611_tmp.sql</span><br><span class="line">     ├─20170611_world.sql</span><br><span class="line">     └─conf.json</span><br></pre></td></tr></table></figure><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>使用<a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">schedule</a>支持定时备份</li><li>使用配置文件<code>conf.py</code>统一除了备份时间外的配置备份信息（schedule的定时计划比较复杂，没有放置到配置文件<code>conf.py</code>中，而是放在主程序<code>mysql_schedule_backup.py</code>）</li><li>支持多个数据库备份</li><li>支持压缩备份文件</li><li>支持设置备份文件保留时间</li><li>备份文件中包含<code>mysql_schedule_backup</code>运行的配置信息</li></ul><h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─mysql_schedule_backup</span><br><span class="line">     ├─conf.py</span><br><span class="line">     ├─mysql_schedule_backup.py</span><br><span class="line">     └─requirements.txt</span><br></pre></td></tr></table></figure><ul><li><code>requirements.txt</code>:项目的requirements列表</li><li><code>mysql_schedule_backup.py</code>:是备份运行的主程序，其中<code>backup_mysql</code>函数是与配置文件<code>conf.py</code>交互的主函数。如果定制配置文件的样式可以对<code>backup_mysql</code>函数进行相应的修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    SLEEP_TIME = <span class="number">30</span></span><br><span class="line">    <span class="comment"># 测试定时运行程序 每分钟运行一次</span></span><br><span class="line">    <span class="comment"># schedule.every().minutes.do(backup_mysql)</span></span><br><span class="line">    <span class="comment"># 每天固定时间运行程序</span></span><br><span class="line">    schedule.every().day.at(<span class="string">"06:00"</span>).do(backup_mysql)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        schedule.run_pending()</span><br><span class="line">        time.sleep(SLEEP_TIME)</span><br></pre></td></tr></table></figure><ul><li><code>conf.py</code>:mysql_schedule_backup是定时的配置文件，可配置内容包括备份存放路径、备份保留时间、备份是否压缩、备份的数据库及表（支持多个库备份）。一般的备份文件如下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">job = &#123;</span><br><span class="line">    <span class="string">"setting"</span>: &#123;</span><br><span class="line">        <span class="comment"># 备份的根目录</span></span><br><span class="line">        <span class="string">"root"</span>: <span class="string">"F:/mysql_schedule_backup"</span>,</span><br><span class="line">        <span class="comment"># 备份保持的时间</span></span><br><span class="line">        <span class="string">"keep_day"</span>: <span class="number">60</span>,</span><br><span class="line">        <span class="comment"># 是否压缩备份</span></span><br><span class="line">        <span class="string">"is_zip"</span>: <span class="string">"true"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"db_connection"</span>: [</span><br><span class="line">        <span class="comment"># 第一个要备份的库</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"usr"</span>: <span class="string">"root"</span>,</span><br><span class="line">            <span class="string">"pwd"</span>: <span class="string">"mysql"</span>,</span><br><span class="line">            <span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">            <span class="string">"db_and_table"</span>: &#123;</span><br><span class="line">                <span class="comment"># "backup_database": ["backup_table_1", "backup_table_2", ...]</span></span><br><span class="line">                <span class="string">"tmp"</span>: [</span><br><span class="line">                    <span class="string">"tb1"</span>,</span><br><span class="line">                    <span class="string">"tb2"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="comment"># "backup_database": ["*"]   # *默认全库备份</span></span><br><span class="line">                <span class="string">"world"</span>: [</span><br><span class="line">                    <span class="string">"*"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 第二个要备份的库</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"usr"</span>: <span class="string">"root"</span>,</span><br><span class="line">            <span class="string">"pwd"</span>: <span class="string">"mysql"</span>,</span><br><span class="line">            <span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">            <span class="string">"db_and_table"</span>: &#123;</span><br><span class="line">                <span class="comment"># "backup_database": ["backup_table_1", "backup_table_2", ...]</span></span><br><span class="line">                <span class="string">"sakila"</span>: [</span><br><span class="line">                    <span class="string">"*"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欢迎start"><a href="#欢迎start" class="headerlink" title="欢迎start"></a>欢迎start</h2><p><a href="https://github.com/zhongjiajie/mysql_schedule_backup" target="_blank" rel="noopener">mysql_schedule_backup</a>地址，欢迎start或者fork</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/zhongjiajie/mysql_schedule_backup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mysql_schedule_backup&lt;/a&gt;是定时、全量备份指定mysql数据库的程序。可设置是否压缩备份文件、备份文件保留的天数。&lt;br&gt;使用场景是简单的备份逻辑，通过&lt;a href=&quot;https://github.com/dbader/schedule&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;schedule&lt;/a&gt;就能满足的备份逻辑，没有DAG流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://zhongjiajie.com/categories/MySQL/"/>
    
      <category term="Python" scheme="http://zhongjiajie.com/categories/Python/"/>
    
    
  </entry>
  
</feed>
