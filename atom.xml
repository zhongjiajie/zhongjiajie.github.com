<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhongjiajie&#39;s garden</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongjiajie.github.io/"/>
  <updated>2018-04-01T06:56:00.000Z</updated>
  <id>https://zhongjiajie.github.io/</id>
  
  <author>
    <name>zhongjiajie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shadowsocks使用技巧</title>
    <link href="https://zhongjiajie.github.io/2018/04/01/shadowsocks%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://zhongjiajie.github.io/2018/04/01/shadowsocks使用技巧/</id>
    <published>2018-04-01T06:53:07.000Z</published>
    <updated>2018-04-01T06:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>记录了安装使用ss过程中使用到的文档,包括后期遇到的问题及相关的解决方案</p><a id="more"></a><ul><li><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">github-shadowsocks</a></li><li><p>相关资料</p><ul><li>逗逼根据地<ul><li><a href="https://doub.io/ss-jc26/" target="_blank" rel="noopener">Shadowsocks指导篇（总结归类）——从无到有，境无止尽！</a></li><li><a href="https://doub.io/ss-jc9/" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="https://doub.io/vps-tj/" target="_blank" rel="noopener">一些便宜性价比高的VPS推荐</a></li></ul></li><li><a href="http://wuchong.me/blog/2015/02/02/shadowsocks-install-and-optimize/" target="_blank" rel="noopener">wuchong-科学上网之 Shadowsocks 安装及优化加速</a></li><li>全套包括客户端</li></ul></li><li><p>Github</p><ul><li><a href="https://github.com/shadowsocks/shadowsocks/issues/682" target="_blank" rel="noopener">如何关闭SS的日志</a>: ss的日志问题，日志等级及日志的输出位置</li></ul></li><li>关于PAC的自定义规则<ul><li><a href="http://honglu.me/2015/06/26/ShadowSocks%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99/" target="_blank" rel="noopener">ShadowSocks 自定义规则</a></li><li><a href="https://www.zybuluo.com/yiranphp/note/632963" target="_blank" rel="noopener">Shadowsocks 进阶之 PAC</a></li><li><a href="https://adblockplus.org/zh_CN/filters" target="_blank" rel="noopener">撰写 Adblock Plus 过滤规则</a>： Adblock Plus官网 user-rule用该规则定义</li></ul></li><li>关于GFWlist<ul><li><a href="https://github.com/gfwlist/gfwlist" target="_blank" rel="noopener">github-gfwlist/gfwlist</a>: 一定时间更新 通过base64编码</li><li><a href="https://github.com/itcook/gfwlist2pac" target="_blank" rel="noopener">github-itcook/gfwlist2pac</a>： 时间复杂度O(1)，将base64编码还原成pac文件</li></ul></li><li>用了ss还是上不了或者慢的问题<ul><li><strong>PAC模式</strong>失效是要使用<strong>全局模式</strong>，定时更新客户端，更新PAC</li><li>关于<strong>s3下载慢</strong>的问题，可以用<strong>ss开全局模式</strong>下载</li><li><strong>s3</strong>慢还可以在host文件中增加一条路由<code>219.76.4.4  github-cloud.s3.amazonaws.com</code></li></ul></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li><p>ss开了多个端口且多人使用后，发现 <code>ssseerver</code> 服务经常死掉，参照<a href="http://aircjm.com/2016/10/17/linux-timer-task-instance-shadowsocks-process-automatically-restarts-after-stopping/" target="_blank" rel="noopener">shadowsocks进程停止后自动重启</a>写了一个定时检查的任务运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line">proc_name="shadowsocks"</span><br><span class="line">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class="line">if [ $number -eq 0 ]; then</span><br><span class="line">  ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>将文件放在任意目录下，如 <code>/root</code></li><li>启动系统的 <code>cron</code> 任务 <code>sudo service cron start</code></li><li>编辑 crontab 任务，增加一个任务 <strong>注意路径要是全路径</strong> <code>*/1 * * * * /usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start</code> ，其中 <code>*/1 * * * *</code> 代表每分钟运行一次</li></ul></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">github-shadowsocks</a></li><li><a href="https://doub.io/ss-jc9/" target="_blank" rel="noopener">Shadowsocks（Sock5代理）的PAC模式与全局模式与VPN的区别</a></li><li><a href="https://doub.io/ss-jc26/" target="_blank" rel="noopener">Shadowsocks指导篇（总结归类）——从无到有，境无止尽！</a></li><li><a href="https://doub.io/vps-tj/" target="_blank" rel="noopener">一些便宜性价比高的VPS推荐</a></li><li><a href="http://wuchong.me/blog/2015/02/02/shadowsocks-install-and-optimize/" target="_blank" rel="noopener">科学上网之 Shadowsocks 安装及优化加速</a></li><li><a href="https://github.com/shadowsocks/shadowsocks/issues/682" target="_blank" rel="noopener">如何关闭SS的日志</a></li><li><a href="http://honglu.me/2015/06/26/ShadowSocks%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99/" target="_blank" rel="noopener">ShadowSocks 自定义规则</a></li><li><a href="https://www.zybuluo.com/yiranphp/note/632963" target="_blank" rel="noopener">Shadowsocks 进阶之 PAC</a></li><li><a href="https://adblockplus.org/zh_CN/filters" target="_blank" rel="noopener">撰写 Adblock Plus 过滤规则</a></li><li><a href="https://github.com/gfwlist/gfwlist" target="_blank" rel="noopener">github-gfwlist/gfwlist</a></li><li><a href="https://github.com/itcook/gfwlist2pac" target="_blank" rel="noopener">github-itcook/gfwlist2pac</a></li><li><a href="http://aircjm.com/2016/10/17/linux-timer-task-instance-shadowsocks-process-automatically-restarts-after-stopping/" target="_blank" rel="noopener">shadowsocks进程停止后自动重启</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Shadowsocks&quot;&gt;&lt;a href=&quot;#Shadowsocks&quot; class=&quot;headerlink&quot; title=&quot;Shadowsocks&quot;&gt;&lt;/a&gt;Shadowsocks&lt;/h1&gt;&lt;p&gt;记录了安装使用ss过程中使用到的文档,包括后期遇到的问题及相关的解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="shadowsocks" scheme="https://zhongjiajie.github.io/categories/shadowsocks/"/>
    
    
      <category term="shadowsocks" scheme="https://zhongjiajie.github.io/tags/shadowsocks/"/>
    
      <category term="梯子" scheme="https://zhongjiajie.github.io/tags/%E6%A2%AF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu常用软件安装和配置</title>
    <link href="https://zhongjiajie.github.io/2018/04/01/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhongjiajie.github.io/2018/04/01/ubuntu常用软件安装和配置/</id>
    <published>2018-04-01T06:50:11.000Z</published>
    <updated>2018-04-01T06:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu常用软件安装和配置"><a href="#ubuntu常用软件安装和配置" class="headerlink" title="ubuntu常用软件安装和配置"></a>ubuntu常用软件安装和配置</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文章介绍了自己第一次接触 Linux 系统的软件安装及常用配置，作为一名应届新萌，一直不能流畅的操作服务器，所以决定逼自己一把，直接将自己的操作系统换成 ubuntu</p><a id="more"></a><h2 id="ubuntu国内源"><a href="#ubuntu国内源" class="headerlink" title="ubuntu国内源"></a>ubuntu国内源</h2><p>在<a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学ubuntu镜像帮助</a>页面选择对应的ubuntu版本，然后将系统原来的<code>/etc/apt/sources.list</code>进行备份，<code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code>，将页面中的配置覆盖原<code>/etc/apt/sources.list</code>文件的内容，这个运行<code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></p><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p>输入法是我下载的第一个应用，他是和计算机交流的重要途径。直接前往<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">搜狗for linux</a>进行下载，安装指南直接看官网的<a href="https://pinyin.sogou.com/linux/help.php" target="_blank" rel="noopener">安装指南</a>。因为我是ubuntu 16.04.LTS，所以我更新了upgrade了系统的软件后直接双击<code>.deb</code>文件就完成了安装过程。</p><h3 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h3><p>直接官网<a href="http://wps-community.org/download.html" target="_blank" rel="noopener">WPS</a>下载deb包，点击安装即可，目前已经支持64位操作系统了</p><h3 id="shadowsocks客户端"><a href="#shadowsocks客户端" class="headerlink" title="shadowsocks客户端"></a>shadowsocks客户端</h3><p>ss作为翻墙大户，自然也会在我的安装清单中，各种系统的安装请参考页面<a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">安装指南</a>，ubuntu推荐用ppa方式安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><p>ss服务端可以配置多个账户登录，配置方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shadowsocks.json</span><br><span class="line">&#123;</span><br><span class="line">    "server":"your_server_ip",</span><br><span class="line">    # 你的端口对应的密码</span><br><span class="line">    "port_password":&#123;</span><br><span class="line">        "8381":"pass1",</span><br><span class="line">        "8382":"pass2",</span><br><span class="line">        "8383":"pass3",</span><br><span class="line">        "8384":"pass4"</span><br><span class="line">        &#125;,</span><br><span class="line">    "timeout":60,</span><br><span class="line">    "method":"rc4-md5",</span><br><span class="line">    "fast_open":false,</span><br><span class="line">    "workers":1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/" target="_blank" rel="noopener">Chrome 配置 SwitchyOmega</a>里面介绍了 SwitchyOmega 的简单配置使用，包括设置 ss 代理、配置国家防火墙、配置自动切换代理等</p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>谷歌浏览器，这个没有什么比较解释，很多插件和google的app都在chrome上面，<a href="http://blog.csdn.net/sdujava2011/article/details/50880663" target="_blank" rel="noopener">下载方式</a>有两种，我选择了命令行下载安装包本地安装，先下载软件包<code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code>，然后安装软件包<code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code></p><p>安装完成后打开chrome发现及时运行了ss客户端还是没有办法翻墙，这个和windows下比较不同，ubuntu下需要手动设置代理才能翻墙，但是发现代理软件需要登陆chrome应用市场下载，后来发现<a href="https://portableapps.com/node/22329" target="_blank" rel="noopener">start Google Chrome with proxy command</a>可以在命令行启动chrome，于是在命令行下运行<code>google-chrome --proxy-server=&quot;socks5://127.0.0.1:1080&quot;</code>然后chrome就能科学上网了</p><h3 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h3><p>平时工作交流用钉钉，所以装了个<a href="https://github.com/nashaofu/dingtalk" target="_blank" rel="noopener">钉钉 for linux</a>，只需要按照README文档中介绍在<strong>relase</strong>页面下载相应的deb包进行安装就行</p><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>生活沟通必备，主要是QQ被我用烂了，不想用了。两种方式可以实现微信的安装，一种是在<a href="https://chrome.google.com/webstore/detail/wechat/ckhliaadcjmdjbhdlkpjkffidcifglba?hl=en-US" target="_blank" rel="noopener">chrome插件</a>里面安装，直接页面操作不多解释。另一种是第三方的安装方式<a href="https://github.com/geeeeeeeeek/electronic-wechat" target="_blank" rel="noopener">electronic-wechat</a>，如果是简单的交流肯定是用第一种方式更加简单粗暴，如果希望有更多的功能就要选择第二中方式。</p><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>听歌必备神器，直接在<a href="http://music.163.com/#/download" target="_blank" rel="noopener">网易云音乐</a>下载安装点击deb包就可以安装</p><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><p>翻译软件，直接<a href="http://cidian.youdao.com/index-linux.html" target="_blank" rel="noopener">有道翻译页面</a>下载deb然后安装，建议下载deepin版本</p><h3 id="shutter"><a href="#shutter" class="headerlink" title="shutter"></a>shutter</h3><p>截图软件，直接在ubuntu software搜索安装</p><h3 id="VLC"><a href="#VLC" class="headerlink" title="VLC"></a>VLC</h3><p>视频播放软件，直接在ubuntu software搜索安装</p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>文本编辑器，根据官网<a href="https://code.visualstudio.com/docs/setup/linux" target="_blank" rel="noopener">Running VS Code on Linux</a>的介绍，建议直接下载deb包并且安装</p><h3 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h3><p>JetBrains 出品的 Python IDE。一般好东西是不解释的</p><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><p>JetBrains 出品的 Java IDE。同上不解释</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="Python虚拟环境的安装"><a href="#Python虚拟环境的安装" class="headerlink" title="Python虚拟环境的安装"></a>Python虚拟环境的安装</h4><p>ubuntu 系统内置两个版本的 Python ，之前一直用py2，但是考虑到20年py2就要停止维护了，所以打算上py3， ubuntu 16.04 默认两个版本的 python 都有安装，开发的时候一般都会用虚拟环境以免 ubuntu 原生的工具被破坏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装 pip3</span><br><span class="line">sudo apt-get install python-pip3</span><br><span class="line">pip3 --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 virtualenv</span><br><span class="line">pip install virtualenv</span><br><span class="line">virtualenv --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 virtualenvwrapper</span><br><span class="line">pip install virtualenvwrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编辑你的 .bashrc 或者 .zshrc 在最后面添加</span><br><span class="line">VIRTUALENVWRAPPER_PYTHON='/usr/bin/python3'  # 这句一定要添加，不然会默认用python2 来解析</span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> virtualenvwrapper 使用</span><br><span class="line">mkvirtualenv venv</span><br><span class="line">deactivate</span><br><span class="line">rmvirtualenv venv</span><br></pre></td></tr></table></figure><h4 id="pip-换国内源"><a href="#pip-换国内源" class="headerlink" title="pip 换国内源"></a>pip 换国内源</h4><p>官方源很好，但是下载速度比较慢，所以把 pip 默认的源从官方源改成国内源提高速度，等国内源下载确实有问题时再去官方源下载，国内源用的是<a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">清华大学pypi源</a></p><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>Java JDK有两个版本，一个开源版本Openjdk，还有一个oracle官方版本jdk。下面记录在Ubuntu 16.04上安装Java JDK的步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 开源版openjdk</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> oracle Java JDK</span><br><span class="line"><span class="meta">#</span> 安装依赖包</span><br><span class="line">sudo apt-get install python-software-properties</span><br><span class="line"><span class="meta">#</span> 添加仓库源</span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure><h3 id="数据库客户端"><a href="#数据库客户端" class="headerlink" title="数据库客户端"></a>数据库客户端</h3><h4 id="Oracle-client-sqlplus"><a href="#Oracle-client-sqlplus" class="headerlink" title="Oracle client - sqlplus"></a>Oracle client - sqlplus</h4><p>安装 Oracle client 参见 <a href="http://webikon.com/cases/installing-oracle-sql-plus-client-on-ubuntu" target="_blank" rel="noopener">Installing Oracle SQL*Plus client on Ubuntu</a> 以及 <a href="https://askubuntu.com/questions/159939/how-to-install-sqlplus" target="_blank" rel="noopener">How to install SqlPlus</a></p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>docker 是非常好用的容器框架，可以说是改变了软件的交付和部署方式，docker 的安装如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 卸载旧版本的docker</span><br><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> docker 可选的内核模块</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用 apt 镜像源安装</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 通过国内源安装</span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="meta">#</span> 向 source.list 添加 docker 软件源</span><br><span class="line">sudo add-apt-repository "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 Docker CE</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动 docker ce</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 建立 docker 用户组</span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line"><span class="meta">#</span> 重启之后可以在普通用户运行 docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 国内镜像加速</span><br><span class="line">vim /etc/docker/daemon.json   # 输入你用的国内镜像加速器 这里以docker中国为例</span><br><span class="line"><span class="meta">#</span> &#123;</span><br><span class="line"><span class="meta">#</span>   "registry-mirrors": ["https://registry.docker-cn.com"]</span><br><span class="line"><span class="meta">#</span> &#125;</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><p>其中国内镜像加速器有<br><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">docker中国</a><br><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云</a><br><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">daocloud</a></p><h3 id="guake"><a href="#guake" class="headerlink" title="guake"></a>guake</h3><p>按<code>F12</code>可以快速生成一个terminal，然后失去焦点后会自动缩进去的终端，在临时处理事情的时候非常有用<code>sudo apt-get guake</code>，<a href="http://www.binarytides.com/install-guake-xubuntu-14-04/" target="_blank" rel="noopener">这里</a>给了一些<strong>Guake can not init!</strong>问题的处理方式。</p><p>设置开机启动，进入<strong>search your computer</strong>，就是按Windows键或者ubuntu建，输入<strong>startup</strong>，</p><h3 id="迅雷"><a href="#迅雷" class="headerlink" title="迅雷"></a>迅雷</h3><p>通过迅雷固件制作而成的前端，需要自己编译，但是教程已经比较完整，详情查看<a href="https://github.com/Xinkai/XwareDesktop/wiki/Ubuntu%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Ubuntu上编译安装说明</a>，安装成功启动后请看<a href="https://github.com/Xinkai/XwareDesktop/wiki/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">使用说明</a>，因为有部分注意事项要遵守</p><h2 id="百度网盘客户端"><a href="#百度网盘客户端" class="headerlink" title="百度网盘客户端"></a>百度网盘客户端</h2><p>百度网盘和迅雷在国内都比较常用，百度网盘 Linux 客户端在 github 上主要是三个<a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">bypy</a><a href="https://github.com/GangZhuo/BaiduPCS" target="_blank" rel="noopener">BaiduPCS</a><a href="https://github.com/Yufeikang/bcloud" target="_blank" rel="noopener">Yufeikang/bcloud</a>，其中前两个是命令行客户端，后面是图形化界面。本来考虑图形化界面，但是看到 README 说作者不维护了，<a href="https://github.com/Yufeikang/bcloud" target="_blank" rel="noopener">Yufeikang/bcloud</a> 就是因为原作者没有维护所以才拿过来修改的，现在 Yufeikang 也弃坑了，所以只能转战命令行客户端了。两个来选，当然选择我更加熟悉的 Python 版的 bypy 了。说不定还能提几个 issue 和 PR 呢。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 我放在了虚拟环境中运行</span><br><span class="line">workon venv</span><br><span class="line">pip3 install bypy</span><br><span class="line"></span><br><span class="line">bypy list # 在命令行界面会给出提示，让你去指定的网址进行登录注册，并将授权码复制到命令行</span><br></pre></td></tr></table></figure><h3 id="桌面美化相关"><a href="#桌面美化相关" class="headerlink" title="桌面美化相关"></a>桌面美化相关</h3><p>部分的桌面美化对于ubuntu来说还是有必要的，毕竟原来的桌面真的有点丑，我选择了大众而简单的美化路线，<a href="https://github.com/tualatrix/ubuntu-tweak" target="_blank" rel="noopener">ubuntu tweak</a><a href="https://github.com/anmoljagetia/Flatabulous" target="_blank" rel="noopener">flatabulous-theme</a>以及ultra-flat-icons。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ubuntu tweak</span><br><span class="line">sudo apt-get install unity-tweak-tool</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> flatabulous-theme 主题</span><br><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flatabulous-theme</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> flatabulous配套图标</span><br><span class="line">sudo add-apt-repository ppa:noobslab/icons</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure><p>安装完成后就可以启动ubuntu tweak，然后在<code>Tweak -&gt; Theme</code>中的GTK和windows主题中选择flatabulous，icon主题中选择ultra-flat</p><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><h2 id="修改root角色密码"><a href="#修改root角色密码" class="headerlink" title="修改root角色密码"></a>修改root角色密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line"><span class="meta">#</span> enter root password and repeat it</span><br></pre></td></tr></table></figure><h3 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h3><ul><li>微软onedrive的DNS被污染，增加两行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat /etc/hosts</span><br><span class="line">204.79.197.217    onedrive.live.com</span><br><span class="line">134.170.108.152   skyapi.onedrive.live.com</span><br></pre></td></tr></table></figure><h2 id="更改默认shell"><a href="#更改默认shell" class="headerlink" title="更改默认shell"></a>更改默认shell</h2><p>zsh被称为终极shell，比ubuntu默认的bash要强大不少。根据<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" target="_blank" rel="noopener">Installing ZSH</a>安装zsh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br><span class="line"><span class="meta">#</span> check if installed</span><br><span class="line">zsh --version</span><br><span class="line"><span class="meta">#</span> check default shell in system</span><br><span class="line">echo $SHELL</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下载 oh-my-zsh 项目来配置 zsh 会自动读取环境变量并且自动帮 zsh 进行设置</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> make zsh as your default shell</span><br><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><h2 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h2><p>thefuck 是自动纠正上一个命令的命令行工具，经常用命令行的同学怎么可以错过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-dev python3-pip</span><br><span class="line">sudo pip3 install thefuck</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改 .zshrc 文件</span><br><span class="line">eval $(thefuck --alias fuck)</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3OTIxNTA0MA==&amp;mid=2650802567&amp;idx=1&amp;sn=9e18d2c5064eb762b7fd7f8f32282ebf&amp;scene=7" target="_blank" rel="noopener">jq</a>是是linux下的json格式化神器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> install</span><br><span class="line">sudo apt-get install jq</span><br><span class="line"><span class="meta">#</span> qiuck start</span><br><span class="line">echo '&#123;"one": 1, "two": 2, "name": "zhongjiajie"&#125;' | jq</span><br><span class="line"><span class="meta">#</span> 获取key</span><br><span class="line">echo '&#123;"one": 1, "two": 2, "name": "zhongjiajie"&#125;' | jq '.name'</span><br><span class="line"><span class="meta">#</span> 嵌套解析</span><br><span class="line">cat json_test.txt | jq '.location.city'</span><br><span class="line"><span class="meta">#</span> 内建函数</span><br><span class="line"><span class="meta">  #</span> 获取所有的key</span><br><span class="line">cat json_test.txt | jq 'keys'</span><br><span class="line"><span class="meta">  #</span> 判断某个可以是否存在</span><br><span class="line">cat json_test.txt | jq 'has("location")'</span><br></pre></td></tr></table></figure><h2 id="pv"><a href="#pv" class="headerlink" title="pv"></a>pv</h2><p>复制时候显示完成百分比、传输速度、剩余时间、已用时间，用法和<code>cp</code>类似: <code>pv src_file &gt; dest_file</code>，参照<a href="https://linux.cn/article-6734-1.html" target="_blank" rel="noopener">如何使用 pv 命令监控 linux 命令的执行进度</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">shadowsocks-qt5安装指南</a></li><li><a href="https://portableapps.com/node/22329" target="_blank" rel="noopener">Want to start Google Chrome with proxy command</a></li><li><a href="http://www.binarytides.com/install-guake-xubuntu-14-04/" target="_blank" rel="noopener">How to install guake (dropdown terminal) on Xubuntu 14.04</a></li><li><a href="https://github.com/Xinkai/XwareDesktop/wiki/Ubuntu%E4%B8%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">XwareDesktopUbuntu上编译安装说明</a></li><li><a href="http://www.cylong.com/blog/2017/04/09/chrome-SwitchyOmega/" target="_blank" rel="noopener">Chrome 配置 SwitchyOmega</a></li><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">docker - use-case-the-china-registry-mirror</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3OTIxNTA0MA==&amp;mid=2650802567&amp;idx=1&amp;sn=9e18d2c5064eb762b7fd7f8f32282ebf&amp;scene=7" target="_blank" rel="noopener">Linux下Json格式化神器jq</a></li><li><a href="http://webikon.com/cases/installing-oracle-sql-plus-client-on-ubuntu" target="_blank" rel="noopener">Installing Oracle SQL*Plus client on Ubuntu</a></li><li><a href="https://askubuntu.com/questions/159939/how-to-install-sqlplus" target="_blank" rel="noopener">How to install SqlPlus</a></li><li><a href="https://linux.cn/article-6734-1.html" target="_blank" rel="noopener">如何使用 pv 命令监控 linux 命令的执行进度</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ubuntu常用软件安装和配置&quot;&gt;&lt;a href=&quot;#ubuntu常用软件安装和配置&quot; class=&quot;headerlink&quot; title=&quot;ubuntu常用软件安装和配置&quot;&gt;&lt;/a&gt;ubuntu常用软件安装和配置&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;文章介绍了自己第一次接触 Linux 系统的软件安装及常用配置，作为一名应届新萌，一直不能流畅的操作服务器，所以决定逼自己一把，直接将自己的操作系统换成 ubuntu&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://zhongjiajie.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://zhongjiajie.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git 常用命令</title>
    <link href="https://zhongjiajie.github.io/2017/10/24/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhongjiajie.github.io/2017/10/24/git-常用命令/</id>
    <published>2017-10-24T03:25:28.000Z</published>
    <updated>2018-01-24T02:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文介绍Git常见的命令以及部分问题的处理方式，是一篇应用性较强的文章，如果想要更加深入的了解Git的原理，请参考本文的<a href="#References">References</a></p><a id="more"></a><h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>在使用Git前要对其进行基本的配置，记录是谁进行当前的修改<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name "YOUR_NAME"                 # 设置 commit 的用户</span><br><span class="line">git config user.email "YOUR_EMIAL@example.com"   # 设置 commit 的邮箱</span><br></pre></td></tr></table></figure></p><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 个性化 log</span><br><span class="line">git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"       # 自定义lg命令 格式化log的输出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 个性化 reflog</span><br><span class="line">git config --global alias.rlg "reflog --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"</span><br></pre></td></tr></table></figure><h1 id="获取版本库"><a href="#获取版本库" class="headerlink" title="获取版本库"></a>获取版本库</h1><h2 id="从远程版本库获取"><a href="#从远程版本库获取" class="headerlink" title="从远程版本库获取"></a>从远程版本库获取</h2><p>从远程版本库中直接拉取一个仓库，会在当前路径下新生成一个文件夹<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zhongjiajie/Autohome.git   # 从github获取</span><br><span class="line">git clone git@server-name:path/repo-name.git            # 从私有服务器中获取</span><br></pre></td></tr></table></figure></p><h2 id="新建版本库"><a href="#新建版本库" class="headerlink" title="新建版本库"></a>新建版本库</h2><p>一般做法，只能在本地提交、推送到远程，别的用户不能从该库进行<code>clone</code>以及<code>push</code>操作，看到<em>first_git</em>文件夹下面有<strong>.git</strong>隐藏文件夹就说明创建成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir first_git</span><br><span class="line">cd first_git</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p><h2 id="新建裸库"><a href="#新建裸库" class="headerlink" title="新建裸库"></a>新建裸库</h2><p>新建远程版本库，可以提供<code>clone</code>和<code>push</code>到改版本库功能。此时<em>first_git</em>文件夹中和<a href="#新建版本库">新建版本库</a>不同，会生成多个文件夹<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir first_git</span><br><span class="line">cd first_git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure></p><h1 id="远程版本库"><a href="#远程版本库" class="headerlink" title="远程版本库"></a>远程版本库</h1><h2 id="查看远程版本库"><a href="#查看远程版本库" class="headerlink" title="查看远程版本库"></a>查看远程版本库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote       # 查看远程版本库信息</span><br><span class="line">git remote -v    # 远程版本库详细信息</span><br></pre></td></tr></table></figure><h2 id="添加远程版本库"><a href="#添加远程版本库" class="headerlink" title="添加远程版本库"></a>添加远程版本库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git       # 添加一个远程库</span><br></pre></td></tr></table></figure><h2 id="推送到远程版本库"><a href="#推送到远程版本库" class="headerlink" title="推送到远程版本库"></a>推送到远程版本库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master           # 推送到远程master分支</span><br><span class="line">git push -u origin BRANCHNAME    # 本地新建分支推送到远程兵追踪</span><br></pre></td></tr></table></figure><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev       # 新建本地dev分支 与远程origin/dev分支进行关联 切换到本地dev分支</span><br></pre></td></tr></table></figure><h2 id="抓取分支的修改"><a href="#抓取分支的修改" class="headerlink" title="抓取分支的修改"></a>抓取分支的修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master                   # 抓取远程master分支的commit信息</span><br><span class="line">git pull origin master                    # 抓取远程master分支的commit信息并对文件进行相应修改</span><br><span class="line">git fetch origin pull/ID/head:BRANCHNAME  # 抓取远程分支的某个pull requests</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete BRANCHNAME    # --delete选项删除远程分支</span><br><span class="line">git push origin :BRANCHNAME            # 推送一个空的分支到要删除的远程分支</span><br></pre></td></tr></table></figure><h2 id="更新远程分析信息"><a href="#更新远程分析信息" class="headerlink" title="更新远程分析信息"></a>更新远程分析信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p       # 更新远程版本库同步分支和tag</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev master           # 在master的基础上创建dev分支</span><br><span class="line">git checkout dev                # 切换到dev分支</span><br><span class="line">git checkout -b dev master      # 在master的基础上创建dev分支 并切换到dev分支</span><br><span class="line">git checkout -b dev origin/dev  # 新建dev分支 与远程origin/dev分支进行关联 并切换到dev分支</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff dev   # 合并dev分支 no-ff选项保留原分支记录 commit按照时间排序</span><br><span class="line"></span><br><span class="line">git checkout dev</span><br><span class="line">git rebase master       # 合并dev分支到master分支的最后面 重新排列commit顺序</span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev       # 删除已合并的分支</span><br><span class="line">git branch -D dev       # 强行删除分支</span><br></pre></td></tr></table></figure><h1 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h1><h2 id="状态和差异"><a href="#状态和差异" class="headerlink" title="状态和差异"></a>状态和差异</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status                   # 查看工作区、暂存区的状态</span><br><span class="line">git diff                     # 查看未暂存的文件更新</span><br><span class="line">git diff --cached            # 查看已暂存文件的更新</span><br><span class="line">git diff HEAD -- FILENAME    # 查看工作区和版本库里面最新版本的区别</span><br><span class="line">git diff BRANCH_1 BRANCH_2   # 在合并改动之前，预览两个分支的差异</span><br></pre></td></tr></table></figure><h2 id="删除和移动"><a href="#删除和移动" class="headerlink" title="删除和移动"></a>删除和移动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rm FILENAME            # 直接删除文件</span><br><span class="line">git rm --cached FILENAME   # 删除文件暂存状态</span><br><span class="line"></span><br><span class="line">git mv FILENAME_1 FILENAME_2           # FILENAME_1重命名成FILENAME_2</span><br><span class="line">git mv FILENAME_1 path/to/FILENAME_2   # FILENAME_1移动到path/to目录并重命名成FILENAME_2</span><br><span class="line">git rm FILENAME                        # 删除文件FILENAME</span><br></pre></td></tr></table></figure><h2 id="储藏和恢复"><a href="#储藏和恢复" class="headerlink" title="储藏和恢复"></a>储藏和恢复</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash                  # 储藏当前工作状态</span><br><span class="line">git stash list             # 查看储藏列表</span><br><span class="line">git stash apply STASH_ID   # 恢复指定储藏状态</span><br><span class="line">git stash drop STASH_ID    # 删除指定储藏ID</span><br><span class="line">git stash pop              # 恢复最近储藏 并删除 相当于apply + drop</span><br><span class="line">git stash clear            # 清空储藏列表</span><br></pre></td></tr></table></figure><h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add FILENAME             # 添加文件到暂存区</span><br><span class="line">git add .                    # 添加当前全部修改到暂存区</span><br><span class="line">git commit -m 'commit log'   # 将暂存区修改提交到本地版本库并记录commit log</span><br><span class="line">git commit -amend            # 修改最后一次提交</span><br><span class="line">git push origin master       # 提交到远程版本库</span><br></pre></td></tr></table></figure><h2 id="修改提交人信息"><a href="#修改提交人信息" class="headerlink" title="修改提交人信息"></a>修改提交人信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author "YOUR_NAME &lt;YOUR_EMIAL@example.com&gt;"       # 修改上次提交的用户信息</span><br></pre></td></tr></table></figure><h1 id="历史和回退"><a href="#历史和回退" class="headerlink" title="历史和回退"></a>历史和回退</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline           # 查看历史 每个历史一条记录</span><br><span class="line">git log --oneline FILENAME  # 查看指定文件历史 每个历史一条记录</span><br><span class="line">git log -p -2               # 显示最近2次提交内容的差异</span><br><span class="line">git show COMMIT_ID          # 查看某次修改</span><br></pre></td></tr></table></figure><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- FILENAME    # 丢弃工作区上某个文件的修改</span><br><span class="line">git reset HEAD FILENAME     # 丢弃暂存区上某个文件的修改，重新放回工作区</span><br><span class="line">git reset --hard HEAD^      # 回退到上一个版本</span><br><span class="line">git reset --hard COMMIT_ID  # 回退到具体某个版</span><br><span class="line"></span><br><span class="line">git reflog                  # 查看命令历史 常在merge或rebase丢失了commit后使用</span><br><span class="line"></span><br><span class="line">git revert COMMIT_ID        # 撤销指定的提交</span><br></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.1                # 新建标签，默认位 HEAD</span><br><span class="line">git tag v0.1 COMMIT_ID      # 对指定的 commit id 打标签</span><br><span class="line">git tag -a v0.1 -m 'version 0.1 released'       # 新建带注释标签</span><br></pre></td></tr></table></figure><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag             # 显示所有标签</span><br><span class="line">git show TAGNAME    # 显示指定标签信息</span><br></pre></td></tr></table></figure><h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d TAGNAME                   # 删除标签</span><br><span class="line">git push origin :refs/tags/TAGNAME   #删除远程标签</span><br></pre></td></tr></table></figure><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout TAGNAME      # 切换到标签</span><br><span class="line">git push origin TAGNAME   # 推送分支到源上</span><br><span class="line">git push origin --tags    # 一次性推送全部尚未推送到远程的本地标签</span><br></pre></td></tr></table></figure><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h2><p><a href="http://blog.csdn.net/u013068377/article/details/52168434" target="_blank" rel="noopener">windows下git bash中文乱码解决办法</a></p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul><li><p>修改某次特定commit的作者<br><a href="https://stackoverflow.com/questions/3042437/change-commit-author-at-one-specific-commit" target="_blank" rel="noopener">Change commit author at one specific commit</a></p></li><li><p>修改某次特定的commit内容<br><a href="https://stackoverflow.com/questions/1186535/how-to-modify-a-specified-commit-in-git" target="_blank" rel="noopener">How to modify a specified commit in git</a></p></li><li><p>修改版本库的第一个commit<br><a href="https://stackoverflow.com/questions/2119480/edit-the-root-commit-in-git" target="_blank" rel="noopener">Edit the root commit in Git</a></p></li></ul><h2 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h2><p>统计每个用户提交的次数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -nes       # 统计每个用户提交的次数 name + email + summary</span><br></pre></td></tr></table></figure></p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><ul><li>恢复所有在git中被删除的文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -d | xargs echo -e | xargs git checkout --</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://stackoverflow.com/questions/23821235/how-to-link-to-specific-line-number-on-github" target="_blank" rel="noopener">How to link to specific line number on github</a></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://wuchong.me/blog/2015/03/30/git-useful-skills/" target="_blank" rel="noopener">Git 常用技能</a><br><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">my-git</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a><br><a href="https://help.github.com/articles/checking-out-pull-requests-locally/#modifying-an-inactive-pull-request-locally" target="_blank" rel="noopener">Modifying an inactive pull request locally</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本文介绍Git常见的命令以及部分问题的处理方式，是一篇应用性较强的文章，如果想要更加深入的了解Git的原理，请参考本文的&lt;a href=&quot;#References&quot;&gt;References&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://zhongjiajie.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://zhongjiajie.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>用github管理blog</title>
    <link href="https://zhongjiajie.github.io/2017/10/23/%E7%94%A8github%E7%AE%A1%E7%90%86blog/"/>
    <id>https://zhongjiajie.github.io/2017/10/23/用github管理blog/</id>
    <published>2017-10-23T13:47:43.000Z</published>
    <updated>2017-12-10T02:32:58.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从开始写博客以来，怎么管理博客文章的编写和发布一直困扰着我，最近刚好在加强Gitflow工作流，正好将其运用到博客管理上，使得博客的编写和发布更加有条理，现将个人对博客的管理经验与大家分享</p><a id="more"></a><h1 id="为什么要管理文章"><a href="#为什么要管理文章" class="headerlink" title="为什么要管理文章"></a>为什么要管理文章</h1><p>我写博客一般是下班或者午饭过后，都是一些零碎的时间。博客的内容有深有浅，有的能在20分钟内写完，有的要比较长的时间。如果遇到读书笔记之类的，要读完一本书才能完成一篇博客的就时间更长了</p><p>在写博客的时候很可能是多篇博客一起写，我目前有两篇读书笔记还在进行（长期），还有一个关于个人项目的博客（中长期），还有一些短期的想法想要分享，例如这篇博客</p><p>这样在博客发布的时候就笔记复杂了，之前的做法是认为将没有完成的文章剪切到别的地方，然后将已完成的博客用<strong>HEXO</strong>进行部署，这样的方法显得不够灵活，操作复杂且容易丢失博客，试过吃完饭睡个觉忘了把剪切出来的博客复制回去，之前时间太久博客被自己手贱删了。所以就有了用Gitflow来管理博客的想法，通过建立不同的分支来控制各个每篇不同的文章，完成之后再合并到master分支用于发布，更好管理文章的同时也可以加强写git的使用，何乐而不为？</p><h1 id="Gitflow博客管理流程"><a href="#Gitflow博客管理流程" class="headerlink" title="Gitflow博客管理流程"></a>Gitflow博客管理流程</h1><h2 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h2><p>在<a href="https://github.com" target="_blank" rel="noopener">Github</a>上创建存储blog的repository，我创建了一个<a href="https://github.com/zhongjiajie/srcBlog" target="_blank" rel="noopener">srcBlog</a></p><h2 id="对文章的管理"><a href="#对文章的管理" class="headerlink" title="对文章的管理"></a>对文章的管理</h2><ul><li>先将之前已经完成并发布的文章放在<strong>master</strong>分支中</li><li>从<strong>master</strong>分支中<code>checkout</code>一个<strong>develop</strong>分支</li><li>新建文章就从<strong>develop</strong>分支中<code>checkout</code>一个分支进行编写，分支名为<strong>feature-<post_name></post_name></strong></li><li>完成了文章的创建就<code>checkout</code>到<strong>develop</strong>分支，<code>git merge --no-ff feature-&lt;post_name&gt;</code></li><li>对于没有完成的文章，或者持续更新的文章（读书笔记、学习日志等），及时的<code>git stash</code>储存或者<code>git push -u feature-&lt;post_name&gt;</code>推送到Github</li><li>对特定文章的编写再<code>git checkout feature-&lt;post_name&gt;</code></li></ul><h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p><img src="2017-10-23-用github管理blog/gitflow.png" alt="Gitflow"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;自从开始写博客以来，怎么管理博客文章的编写和发布一直困扰着我，最近刚好在加强Gitflow工作流，正好将其运用到博客管理上，使得博客的编写和发布更加有条理，现将个人对博客的管理经验与大家分享&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://zhongjiajie.github.io/categories/blog/"/>
    
    
      <category term="Github" scheme="https://zhongjiajie.github.io/tags/Github/"/>
    
      <category term="blog" scheme="https://zhongjiajie.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>pypi安装包制作及发布</title>
    <link href="https://zhongjiajie.github.io/2017/10/21/pypi%E5%AE%89%E8%A3%85%E5%8C%85%E5%88%B6%E4%BD%9C%E5%8F%8A%E5%8F%91%E5%B8%83/"/>
    <id>https://zhongjiajie.github.io/2017/10/21/pypi安装包制作及发布/</id>
    <published>2017-10-21T03:07:26.000Z</published>
    <updated>2017-12-10T02:32:58.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>介绍如果将自己的程序制作成pypi包并发布到<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a></p><a id="more"></a><h1 id="pypi简介"><a href="#pypi简介" class="headerlink" title="pypi简介"></a>pypi简介</h1><p><a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a>全程是<strong>Python Package Index</strong>，其官方定义是</p><blockquote><p>The Python Package Index is a repository of software for the Python programming language. There are currently 119827 packages here.  – until 2017-10-21</p></blockquote><p>我们平常安装程序所用的<code>pip</code>就是到pypi中找到相应的库并将其安装到本地的，比如我们运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></p><p><code>pip</code>就会去pypi找到最符合<strong>requests</strong>的这个包，然后下载到本地，最后将其安装</p><h1 id="pypi安装包制作"><a href="#pypi安装包制作" class="headerlink" title="pypi安装包制作"></a>pypi安装包制作</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>pypi的库不允许有相同的名称，如果想要跟着教程完成相关的操作的话请先将教程的<code>zhongjiajie</code>改成你的名称（目的是在<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">pypi</a>找不到相应的库），才能完成库的上传操作</strong></p><h2 id="普通库"><a href="#普通库" class="headerlink" title="普通库"></a>普通库</h2><p>这里的普通库指的是通过<code>from package import function</code>或<code>import package</code>方式调用的库，下面进行具体程序的演示，先切换到项目目录，这里是<strong>myproject</strong></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd </span><br><span class="line"><span class="meta">$</span> cd Desktop/</span><br><span class="line"><span class="meta">$</span> mkdir myproject</span><br><span class="line"><span class="meta">$</span> cd myproject/</span><br></pre></td></tr></table></figure><h3 id="定义库的功能"><a href="#定义库的功能" class="headerlink" title="定义库的功能"></a>定义库的功能</h3><p>创建文件夹<strong>zhongjiajiepypi</strong>并且在其中编写简单的Python函数<strong>myfunction.py</strong>及定义<strong><strong>init</strong>.py</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir zhongjiajiepypi</span><br><span class="line"><span class="meta">$</span> cd zhongjiajiepypi/</span><br><span class="line"><span class="meta">$</span> vim __init__.py       # 这个文件作用就是给这个文件夹打成包</span><br><span class="line"><span class="meta">$</span> vim myfunction.py     # 这里放置逻辑代码了</span><br></pre></td></tr></table></figure><p>其中<strong>myfunction.py</strong>的内容为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat myfunction.py</span><br><span class="line"><span class="meta">#</span>!/usr/bin/env python</span><br><span class="line"><span class="meta">#</span>-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">def mysum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for v in args:</span><br><span class="line">        i = float(v)</span><br><span class="line">        s += i</span><br><span class="line">    print s</span><br></pre></td></tr></table></figure></p><p><strong><strong>init</strong>.py</strong>的内容为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat __init__.py</span><br><span class="line">from myfunction import mysum</span><br></pre></td></tr></table></figure><h3 id="编写项目setup-py文件"><a href="#编写项目setup-py文件" class="headerlink" title="编写项目setup.py文件"></a>编写项目setup.py文件</h3><p><strong>这是重点</strong>：接着要编写pypi的setup文件，生成pip可以识别的格式，为后期上传到pypi做准备，我们先切换到<strong>myproject</strong>根目录，然后编辑<strong>setup.py</strong>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim setup.py         # 写入相应的setup.py内容 详见cat命令结果</span><br><span class="line"><span class="meta">$</span> cat setup.py</span><br><span class="line"><span class="meta">#</span>!/usr/bin/env python</span><br><span class="line"><span class="meta">#</span>-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name = "zhongjiajiepypi",</span><br><span class="line">    version = "0.0.1",</span><br><span class="line">    keywords = ("pip", "testpypi"),</span><br><span class="line">    description = "test pip module",</span><br><span class="line">    long_description = "test how to define pip module and upload to pypi",</span><br><span class="line">    license = "MIT",</span><br><span class="line"></span><br><span class="line">    url = "https://zhongjiajie.github.io",          # your module home page, such as </span><br><span class="line">    author = "zhongjiajie",                         # your name</span><br><span class="line">    author_email = "zhongjiajie955@hotmail.com",    # your email</span><br><span class="line"></span><br><span class="line">    packages = find_packages(),</span><br><span class="line">    include_package_data = True,</span><br><span class="line">    platforms = "any",</span><br><span class="line">    install_requires = []</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们需要注意一下，<strong>setup.py</strong>文件是能不能正确生成pip能识别文件的关键，他有自己的一套格式，我们编写setup文件要遵循这一套格式，实例代码是基础的设置，更多设置请查阅<a href="https://docs.python.org/3/distutils/setupscript.html#additional-meta-data" target="_blank" rel="noopener">Writing the Setup Script</a></p><h3 id="打包pypi"><a href="#打包pypi" class="headerlink" title="打包pypi"></a>打包pypi</h3><p>此时整个包已经编写完成了，整个项目的文件结构是<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree</span><br><span class="line">.</span><br><span class="line">├── zhongjiajiepypi</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── myfunction.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure></p><p>现在我们需要将项目变成<strong>pip</strong>能够识别并安装的文件，在本地测试成功后将文件上传到<strong>pypi</strong>，在项目的根目录（setup.py同等位置）中运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python setup.py sdist       # 生成二进制包 支持pip安装 推荐使用</span><br><span class="line"><span class="meta">$</span> python setup.py bdist_egg   # 生成egg 支持easy_install安装</span><br></pre></td></tr></table></figure><p>Python会自动将项目打包成二进制包，此时项目的文件结构是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree</span><br><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   └── zhongjiajiepypi-0.0.1.tar.gz</span><br><span class="line">├── zhongjiajiepypi</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── myfunction.py</span><br><span class="line">├── zhongjiajiepypi.egg-info</span><br><span class="line">│   ├── dependency_links.txt</span><br><span class="line">│   ├── PKG-INFO</span><br><span class="line">│   ├── SOURCES.txt</span><br><span class="line">│   └── top_level.txt</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p>此时已算完成了pypi的打包</p><h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><p>建议在将包上传到pypi之前现在本地完成测试工作，方法是先进入<strong>dist</strong>文件夹，然后用<code>pip</code>命令安装本地的二进制包，安装完成后测试其中的方法是否可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd dist</span><br><span class="line"><span class="meta">$</span> pip install zhongjiajiepypi-0.0.1.tar.gz</span><br><span class="line"><span class="meta">$</span> python -c "import zhongjiajiepypi; zhongjiajiepypi.mysum(3, 4, 5)"</span><br><span class="line">12.0</span><br></pre></td></tr></table></figure><p>可以看到结果是12.0证明包能达到预期，可以上传到pypi</p><h3 id="上传到pypi"><a href="#上传到pypi" class="headerlink" title="上传到pypi"></a>上传到pypi</h3><p><strong>注意</strong>: 部分旧版教程会说先运行<code>python setup.py register</code>进行注册，然后再运行<code>python setup.py sdist upload</code>将二进制包上传到pypi上，但是目前pypi已经可以不用注册直接运行<code>python setup.py sdist upload</code>完成上传。</p><p>我们先尝试用<code>python setup.py register</code>，接着输入密码，结果收到下面的提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registering zhongjiajiepypi to https://upload.pypi.org/legacy/</span><br><span class="line">Server response (410): Project pre-registration is no longer required or supported, so continue directly to uploading files.</span><br></pre></td></tr></table></figure><p>可以看到确实不用先注册了，下面我们尝试直接运行<code>python setup.py sdist upload</code>，然后输入密码，结果让我吃了一斤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Submitting dist/zhongjiajiepypi-0.0.1.tar.gz to https://upload.pypi.org/legacy/</span><br><span class="line">Upload failed (403): Invalid or non-existent authentication information.</span><br><span class="line">error: Upload failed (403): Invalid or non-existent authentication information.</span><br></pre></td></tr></table></figure><p>两种方法都不能将本地包上传到pypi，于是我google了原因，看到了github上面相关的链接<a href="https://github.com/pypa/setuptools/issues/941" target="_blank" rel="noopener">Invalid or non-existent authentication information</a>，要新建<code>$HOME/.pypirc</code>文件用于保存pypi的连接信息，尝试了<code>@dover247</code>的文件样例发现仍不能上传到pypi，然后看到<code>@jaraco</code>说那个版本有点旧，就去了<a href="https://docs.python.org/3.6/distutils/packageindex.html#pypirc" target="_blank" rel="noopener">The Python Package Index (PyPI)</a>使用了最新的样例，然后再运行<code>python setup.py sdist upload</code>就能上传成功了（注意国内网络环境访问pypi）</p><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><h3 id="CLI简介"><a href="#CLI简介" class="headerlink" title="CLI简介"></a>CLI简介</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener">CLI</a>（command-line interface，命令行界面）是指可在用户提示符下键入可执行指令的界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。我个人的理解是通过命令行操作调用程序的接口，以达到我们的目的，好处是更加直观、并提供交互式的完成一些简单的操作</p><h3 id="定义Python的CLI接口"><a href="#定义Python的CLI接口" class="headerlink" title="定义Python的CLI接口"></a>定义Python的CLI接口</h3><p>Python的CLI和Python的一般库的做法类似，不同的是它暴露了一个CLI的关键字，调用起来就类似于调用<code>python script_name.py args</code>的形式。他会在<code>$PYTHON_HOME/Scripts</code>生成可运行文件，命令行调用，下面我们把之前的例子改成CLI的调用方式，先修改<strong>zhongjiajiefunction.py</strong>文件，加上命令行传参的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat zhongjiajiefunction.py</span><br><span class="line"><span class="meta">#</span>!/usr/bin/env python</span><br><span class="line"><span class="meta">#</span>-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">def mysum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for v in args:</span><br><span class="line">        i = float(v)</span><br><span class="line">        s += i</span><br><span class="line">    print s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从此是新加的功能</span><br><span class="line">def mysum_cli():</span><br><span class="line">    import sys</span><br><span class="line">    args = sys.argv[1:]</span><br><span class="line">    mysum(*args)</span><br></pre></td></tr></table></figure><p>新加的<code>mysum_cli</code>提供了在命令行获取相关的参数，并将参数传递给原来的<code>mysum</code>函数。接着修改<strong>setup.py</strong>函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat setup.py</span><br><span class="line"><span class="meta">#</span>!/usr/bin/env python</span><br><span class="line"><span class="meta">#</span>-*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name = "zhongjiajiepypi",</span><br><span class="line">    version = "0.0.1",</span><br><span class="line">    keywords = ("pip", "testpypi"),</span><br><span class="line">    description = "test pip module",</span><br><span class="line">    long_description = "test how to define pip module and upload to pypi",</span><br><span class="line">    license = "MIT",</span><br><span class="line"></span><br><span class="line">    url = "https://zhongjiajie.github.io",</span><br><span class="line">    author = "zhongjiajie",</span><br><span class="line">    author_email = "zhongjiajie955@hotmail.com",</span><br><span class="line"></span><br><span class="line">    packages = find_packages(),</span><br><span class="line">    include_package_data = True,</span><br><span class="line">    platforms = "any",</span><br><span class="line">    install_requires = [],</span><br><span class="line">    </span><br><span class="line">    # 此处起是增加的内容</span><br><span class="line">    entry_points = &#123;</span><br><span class="line">        'console_scripts': [</span><br><span class="line">            'mysum=zhongjiajiepypi.zhongjiajiefunction:mysum_cli',</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到只需要在配置中加上<code>entry_points</code>入口选项就行了，其中<code>console_scripts</code>中指定命令行中的关键字，此处为<code>mysum</code>，对应的是<code>zhongjiajiepypi</code>这个库的<code>zhongjiajiefunction</code>函数里面的<code>mysum_cli</code>方法。</p><p>至此完成了CLI的配置，接着根据之前介绍的<a href="#打包pypi">打包pypi</a>的方法进行打包，然后本地测试运行就能得到我们想要的结果了，当和下面一样看到命令行调用<code>mysum 2 3 4</code>的结果是9.0的时候就说明CLI接口已经能正常运行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python setup.py sdist</span><br><span class="line"><span class="meta">$</span> cd dist</span><br><span class="line"><span class="meta">$</span> pip install zhongjiajiepypi-0.0.1.tar.gz</span><br><span class="line"><span class="meta">$</span> mysum 2 3 4</span><br><span class="line">9.0</span><br></pre></td></tr></table></figure><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul><li>由于pypi不能有同名的库，所以拿样例测试的时候要将名字改成pypi不存在的库名</li><li>上传到pypi已经不用先注册，但要新建<code>$HOME/.pypirc</code>文件填入适当的内容</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.xiaoh.me/2015/12/11/python-egg/" target="_blank" rel="noopener">怎么制作pip安装包，Python Egg</a></p><p><a href="https://zhuanlan.zhihu.com/p/26159930" target="_blank" rel="noopener">如何将自己的程序发布到 PyPI</a></p><p><a href="https://python-packaging.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">How To Package Your Python Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;介绍如果将自己的程序制作成pypi包并发布到&lt;a href=&quot;https://pypi.python.org/pypi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pypi&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zhongjiajie.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://zhongjiajie.github.io/tags/Python/"/>
    
      <category term="pypi" scheme="https://zhongjiajie.github.io/tags/pypi/"/>
    
  </entry>
  
  <entry>
    <title>美女图片API</title>
    <link href="https://zhongjiajie.github.io/2017/08/30/%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87API/"/>
    <id>https://zhongjiajie.github.io/2017/08/30/美女图片API/</id>
    <published>2017-08-30T01:50:40.000Z</published>
    <updated>2017-12-10T02:32:58.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近期重构了之前Github的一个项目<a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">beauty</a>，项目伊始是大学期间为了学习Python及爬虫。项目通过爬虫提供了API访问<a href="http://www.55156.com/gaoqingtaotu/" target="_blank" rel="noopener">55156图库-高清套图</a>，让整个浏览图片的过程显得更加流畅与愉悦</p><a id="more"></a><h1 id="项目更新"><a href="#项目更新" class="headerlink" title="项目更新"></a>项目更新</h1><ul><li>20171017: 上传代码到<a href="https://pypi.python.org/pypi/beauty" target="_blank" rel="noopener">pypi</a>，提供更加便捷的使用方式</li></ul><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">zhongjiajie/beauty</a></p><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>该项目爬虫的难度不大，但是提供了一种更加流畅与愉悦的看图方式，可以供大家参考。<br><strong>重构原因：</strong>大学期间的爬虫是用了多线程直接把<a href="http://www.55156.com/gaoqingtaotu/" target="_blank" rel="noopener">55156图库-高清套图</a>中的所有图片下载下来，已经达到了爬虫的学习目的但是只能全量抓取，不能有节制的爬取，一是容易带来资源的浪费（跑很久），二是部分的套图质量确实不敢恭维。所以重构的时候就秉持着几个原则：</p><ul><li>提供选择下载什么分类的套图（ugirl、tuigirl等）</li><li>提供选择现在多少个最新的套图</li><li>提供先下载单张小图，然后肉眼筛选再指定下载整个套图</li></ul><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><h2 id="clone或下载源码"><a href="#clone或下载源码" class="headerlink" title="clone或下载源码"></a>clone或下载源码</h2><p>从github版本库<a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">zhongjiajie/beauty</a>中clone或下载相应的源码</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>项目根目录运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beauty</span><br></pre></td></tr></table></figure></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><strong>以下命令均在项目根目录运行</strong></p><h3 id="查看Usage及支持的套图类型"><a href="#查看Usage及支持的套图类型" class="headerlink" title="查看Usage及支持的套图类型"></a>查看Usage及支持的套图类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beauty -h</span><br></pre></td></tr></table></figure><ul><li><strong>Usage</strong>： 得知项目主要有两个方法<code>scan</code>和<code>download</code>，其中<code>scan</code>是浏览指定种类和数量的封面图片（小图），<code>download</code>是下载指定种类和数量的套图（大图）。</li><li><strong>Arguments</strong>： 目前支持的套图种类，为<code>scan</code>和<code>download</code>方法的必填项</li><li><strong>Options</strong>： 参数的关键字及对应的解释</li></ul><h3 id="直接下载套图"><a href="#直接下载套图" class="headerlink" title="直接下载套图"></a>直接下载套图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载秀人套图 默认数量为10 默认路径是./pic</span><br><span class="line">beauty download xiuren</span><br><span class="line"></span><br><span class="line"># 下载秀人套图 指定数量为15 </span><br><span class="line">beauty download xiuren -n 15</span><br><span class="line"></span><br><span class="line"># 下载秀人套图 指定路径为D:/</span><br><span class="line">beauty download xiuren -p D:/</span><br></pre></td></tr></table></figure><p>完成后可在相应目录下看到下载结果</p><p><img src="2017-08-30-美女图片API/beauty_download.png" alt="beauty_download"></p><h3 id="先浏览小图，根据个人喜好（套图质量）下载对应的大图"><a href="#先浏览小图，根据个人喜好（套图质量）下载对应的大图" class="headerlink" title="先浏览小图，根据个人喜好（套图质量）下载对应的大图"></a>先浏览小图，根据个人喜好（套图质量）下载对应的大图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 浏览秀人套图 默认数量为10 默认路径是./pic/scan</span><br><span class="line">beauty scan xiuren</span><br><span class="line"></span><br><span class="line"># 浏览秀人套图 指定数量为15</span><br><span class="line">beauty scan xiuren -n 15</span><br><span class="line"></span><br><span class="line"># 浏览秀人套图 指定路径为D:/scan scan方法默认的图片会下载到指定（默认目录）的scan文件夹</span><br><span class="line">beauty download xiuren -p D:/</span><br></pre></td></tr></table></figure><p>找到浏览套图文件夹<code>scan</code>，打开图片编辑器查看<code>scan</code>文件夹的图片</p><p><img src="2017-08-30-美女图片API/beauty_scan.png" alt="beauty_scan"></p><p>从上图中找到要完整下载的套图，运行下载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -n参数要和scan方法的参数一样 -f参数列表内部不要留空格</span><br><span class="line">beauty download xiuren -n 10 -f [204774,204775,204832]</span><br></pre></td></tr></table></figure></p><p>完成后可在相应目录下看到下载结果</p><p><img src="2017-08-30-美女图片API/beauty_scan_download.png" alt="beauty_scan_download"></p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="命令行参数库docopt"><a href="#命令行参数库docopt" class="headerlink" title="命令行参数库docopt"></a>命令行参数库docopt</h2><p>获取命令行参数用了<a href="https://github.com/docopt/docopt" target="_blank" rel="noopener">docopt</a>第三方库，docopt通过解析py文件的<code>__doc__</code>文档生成对应的命令行参数解析。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line"><span class="string">"""Usage:</span></span><br><span class="line"><span class="string">  beauty.py scan &lt;NAME&gt; [-n=&lt;num&gt;] [-p=&lt;path&gt;]</span></span><br><span class="line"><span class="string">  beauty.py download &lt;NAME&gt; [-n=&lt;num&gt;] [-f=&lt;list&gt;] [-p=&lt;path&gt;]</span></span><br><span class="line"><span class="string">  beauty.py (--help | -h)</span></span><br><span class="line"><span class="string">  beauty.py --version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  --help -h                     Show this screen.</span></span><br><span class="line"><span class="string">  --version                     Show version.</span></span><br><span class="line"><span class="string">  --num -n=&lt;num&gt;                Number of picture to download, [default 10].</span></span><br><span class="line"><span class="string">  --filter -f=&lt;list&gt;            Filter from parameter --num album number</span></span><br><span class="line"><span class="string">  --path -p=&lt;path&gt;              Path to download picture, [default `$project/pic/`].</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>上面的代码会自动对命令行的输入进行解析，解析的结果会保存在一个<code>dict</code>类型里面，如我运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beauty download tuigirl -n 10 -p ./path</span><br></pre></td></tr></table></figure></p><p><code>docopt</code>会自动根据<code>__doc__</code>已经其中的<code>Usage</code>解析，将获取的参数存储成Python中的一个<code>dict</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'--filter'</span>: <span class="keyword">None</span>,</span><br><span class="line">    <span class="string">'--help'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'--num'</span>: <span class="string">'10'</span>,</span><br><span class="line">    <span class="string">'--path'</span>: <span class="string">'./path'</span>,</span><br><span class="line">    <span class="string">'--version'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'&lt;NAME&gt;'</span>: <span class="string">'tuigirl'</span>,</span><br><span class="line">    <span class="string">'download'</span>: <span class="keyword">True</span>,</span><br><span class="line">    <span class="string">'scan'</span>: <span class="keyword">False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="爬虫主程序分析"><a href="#爬虫主程序分析" class="headerlink" title="爬虫主程序分析"></a>爬虫主程序分析</h2><p>项目主要依赖于Python2.7开发环境，如果发现自己环境运行不起来，欢迎在github上提<a href="https://github.com/zhongjiajie/beauty/issues/new" target="_blank" rel="noopener">issues</a> </p><p>爬虫程序用到的第三方库是<a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a>，提取html中的数据用的是<code>re</code>内置库</p><h3 id="初始化输入及re-compile"><a href="#初始化输入及re-compile" class="headerlink" title="初始化输入及re.compile"></a>初始化输入及re.compile</h3><p>创建实例的时候先对输入进行判断，根据输入执行相应的操作。同时生成多个<code>re.compile</code>对象，用于后期对html的匹配<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成re.compile对象，用于后期html的提取</span></span><br><span class="line">_SMALL_PIC_TMP_REGEX = <span class="string">r'&lt;div class="listBox" id="imgList"&gt;.*?&lt;/div&gt;'</span></span><br><span class="line">_SMALL_PIC_NAME_REGEX = <span class="string">r'&lt;a href="(.*?)" title="(.*?)" class="picLink"&gt;&lt;img src="(.*?)"'</span></span><br><span class="line">_SAMLL_NEXT_PAGE_REGEX = <span class="string">r'&lt;a target=\'_self\' href=\'(.*?)\'&gt;下一页&lt;/a&gt;&lt;/li&gt;'</span></span><br><span class="line">_BIG_PIC_REGEX = <span class="string">r'&lt;img alt=".*?" src="(.*?)" /&gt;'</span></span><br><span class="line">_BIG_NEXT_PAGE_TMP_REGEX = <span class="string">r'&lt;div class="pages"(.*?)&lt;/ul&gt;'</span></span><br><span class="line">_BIG_NEXT_PAGE_REGEX = <span class="string">r'&lt;a href=\'(.*?)\''</span></span><br><span class="line"></span><br><span class="line">_SMALL_PIC_TMP_PATTERN = re.compile(_SMALL_PIC_TMP_REGEX, re.S)</span><br><span class="line">_SMALL_PIC_NAME_PATTERN = re.compile(_SMALL_PIC_NAME_REGEX)</span><br><span class="line">_SAMLL_NEXT_PAGE_PATTERN = re.compile(_SAMLL_NEXT_PAGE_REGEX)</span><br><span class="line">_BIG_PIC_PATTERN = re.compile(_BIG_PIC_REGEX)</span><br><span class="line">_BIG_NEXT_PAGE_TMP_PATTERN = re.compile(_BIG_NEXT_PAGE_TMP_REGEX, re.S)</span><br><span class="line">_BIG_NEXT_PAGE_PATTERN = re.compile(_BIG_NEXT_PAGE_REGEX)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, scan=False, download=False, filter=None, path=None, num=None)</span>:</span></span><br><span class="line">    <span class="string">"""初始化参数及正则表达式"""</span></span><br><span class="line">    self.url = url</span><br><span class="line">    self.is_download = download</span><br><span class="line">    self.is_scan = scan</span><br><span class="line">    self.filter_list = eval(filter) <span class="keyword">if</span> filter <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 默认下载路径是项目根目录./pic</span></span><br><span class="line">    self.path = path <span class="keyword">if</span> path <span class="keyword">else</span> <span class="string">'&#123;dir&#125;/pic'</span>. \</span><br><span class="line">        format(dir=os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</span><br><span class="line">    self.num = int(num) <span class="keyword">if</span> num <span class="keyword">else</span> <span class="number">10</span>  <span class="comment"># 0下载全量 其他下载指定数量</span></span><br></pre></td></tr></table></figure></p><h3 id="获取网页response"><a href="#获取网页response" class="headerlink" title="获取网页response"></a>获取网页response</h3><p>先通过<code>random.choice</code>方法随机获取文件<code>./beauty/user_agent.py</code>文件中的UA，再通过<code>requests.get</code>方法获取获取网页的response，由于是整个项目获取response的方法，所以要函数的输入的URL应该定义为可变参数，并将函数设置成<code>@staticmethod</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""获取网页源代码"""</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: random.choice(agents)</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></p><h3 id="解析response主方法"><a href="#解析response主方法" class="headerlink" title="解析response主方法"></a>解析response主方法</h3><p>该函数主要根据用户输入解析成不同的执命令，<code>scan</code>和<code>download</code>。scan指下载封面的小图片，download下载整个套图的图片，并检查获取的数量是否大于指定的获取数量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Beauty主函数"""</span></span><br><span class="line">    <span class="comment"># 获取封面图片URL，套图名称，大图URL</span></span><br><span class="line">    big_pic_name = []</span><br><span class="line">    html = self.get_response(self.url).content</span><br><span class="line">    big_pic_name.extend(self._parse_small_pic(html))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断获取的套图数量是否大于指定数量</span></span><br><span class="line">    <span class="keyword">while</span> len(big_pic_name) &lt; self.num:</span><br><span class="line">        samll_next_page = self._parse_small_next_page(html)</span><br><span class="line">        html = self.get_response(samll_next_page).content</span><br><span class="line">        big_pic_name.extend(self._parse_small_pic(html))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成以套图编号为key的dict</span></span><br><span class="line">    pic_no_dct = &#123;os.path.basename(i[<span class="number">0</span>]).split(<span class="string">'.'</span>)[<span class="number">0</span>]: list(i)</span><br><span class="line">                  <span class="keyword">for</span> i <span class="keyword">in</span> big_pic_name[:self.num]&#125;</span><br><span class="line">    <span class="comment"># 下载指定album</span></span><br><span class="line">    <span class="keyword">if</span> self.filter_list:</span><br><span class="line">        pic_no_dct = &#123;key: pic_no_dct[key] <span class="keyword">for</span> key <span class="keyword">in</span> pic_no_dct</span><br><span class="line">                      <span class="keyword">if</span> int(key) <span class="keyword">in</span> self.filter_list&#125;</span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    <span class="keyword">if</span> self.is_download:</span><br><span class="line">        <span class="keyword">for</span> album <span class="keyword">in</span> pic_no_dct:</span><br><span class="line">            big_pic_url = pic_no_dct[album][<span class="number">0</span>]</span><br><span class="line">            album_name = pic_no_dct[album][<span class="number">1</span>].decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">            html = self.get_response(big_pic_url).content</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self._parse_big_pic(html, url=big_pic_url):</span><br><span class="line">                pic_no_dct[album].append(url)</span><br><span class="line">            folder = <span class="string">u'&#123;album&#125;_&#123;name&#125;'</span>. \</span><br><span class="line">                format(album=album, name=album_name)</span><br><span class="line">            self._download_pic(folder, pic_no_dct[album][<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 浏览图片</span></span><br><span class="line">    <span class="keyword">elif</span> self.is_scan:</span><br><span class="line">        scan_dct = &#123;key: pic_no_dct[key][<span class="number">2</span>] <span class="keyword">for</span> key <span class="keyword">in</span> pic_no_dct&#125;</span><br><span class="line">        self._scan_pic(scan_dct)</span><br></pre></td></tr></table></figure></p><h3 id="解析大小图片"><a href="#解析大小图片" class="headerlink" title="解析大小图片"></a>解析大小图片</h3><p>解析大小图片，根据<code>parse</code>方法的判断分别执行相应的解析函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_small_pic</span><span class="params">(self, html)</span>:</span></span><br><span class="line">    <span class="string">"""解析小图"""</span></span><br><span class="line">    mid_html = self._SMALL_PIC_TMP_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line">    pic_url_name = self._SMALL_PIC_NAME_PATTERN.findall(mid_html)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pic_url_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_small_next_page</span><span class="params">(self, html)</span>:</span></span><br><span class="line">    <span class="string">"""解析下一页小图"""</span></span><br><span class="line">    part_url = self._SAMLL_NEXT_PAGE_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self._subsite_url(part_url)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_big_pic</span><span class="params">(self, html, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""解析大图"""</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> self._parse_big_sub(html, **kwargs):</span><br><span class="line">        <span class="keyword">yield</span> url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_big_sub</span><span class="params">(self, html, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""解析大图子函数"""</span></span><br><span class="line">    next_page_mid = self._BIG_NEXT_PAGE_TMP_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line">    next_page = self._BIG_NEXT_PAGE_PATTERN.findall(next_page_mid)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> self._BIG_PIC_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> next_page != <span class="string">'#'</span>:</span><br><span class="line">        html = self.get_response(os.path.split(kwargs[<span class="string">'url'</span>])[<span class="number">0</span>] + <span class="string">'/'</span> + next_page).content</span><br><span class="line">        next_page_mid = self._BIG_NEXT_PAGE_TMP_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line">        next_page = self._BIG_NEXT_PAGE_PATTERN.findall(next_page_mid)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self._BIG_PIC_PATTERN.findall(html)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_subsite_url</span><span class="params">(self, part_url)</span>:</span></span><br><span class="line">    <span class="string">"""返回子页面完整url"""</span></span><br><span class="line">    <span class="keyword">return</span> self.url + part_url</span><br></pre></td></tr></table></figure></p><h1 id="Star-amp-Fork"><a href="#Star-amp-Fork" class="headerlink" title="Star&amp;Fork"></a>Star&amp;Fork</h1><p>如果你觉得有点意思或者使用起来比较方便，欢迎在github上star我的项目<a href="https://github.com/zhongjiajie/beauty" target="_blank" rel="noopener">zhongjiajie/beauty</a><br>如果你还有别的需求，或者觉得有需要改进的地方，欢迎提<a href="https://github.com/zhongjiajie/beauty/issues" target="_blank" rel="noopener">issues</a>。<br>如果你想要学习代码获取对项目进行协同开发欢迎Fork或者pull requests</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;近期重构了之前Github的一个项目&lt;a href=&quot;https://github.com/zhongjiajie/beauty&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;beauty&lt;/a&gt;，项目伊始是大学期间为了学习Python及爬虫。项目通过爬虫提供了API访问&lt;a href=&quot;http://www.55156.com/gaoqingtaotu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;55156图库-高清套图&lt;/a&gt;，让整个浏览图片的过程显得更加流畅与愉悦&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://zhongjiajie.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://zhongjiajie.github.io/tags/Python/"/>
    
      <category term="Python爬虫" scheme="https://zhongjiajie.github.io/tags/Python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>算法相关</title>
    <link href="https://zhongjiajie.github.io/2017/07/26/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://zhongjiajie.github.io/2017/07/26/算法相关/</id>
    <published>2017-07-26T08:56:31.000Z</published>
    <updated>2017-12-10T02:32:58.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分享一些平时遇到算法相关的程序，其中包括基础的数据算法，矩阵相关算法等</p><a id="more"></a><h1 id="数据算法相关"><a href="#数据算法相关" class="headerlink" title="数据算法相关"></a>数据算法相关</h1><h2 id="随机返回列表的全部元素"><a href="#随机返回列表的全部元素" class="headerlink" title="随机返回列表的全部元素"></a>随机返回列表的全部元素</h2><p>写一个函数，随机返回输入列表的全部元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_lst_val</span><span class="params">(lst)</span>:</span></span><br><span class="line">    len_ = len(lst)</span><br><span class="line">    <span class="keyword">while</span> len_ &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> lst.pop(random.randint(<span class="number">0</span>, len_ - <span class="number">1</span>))</span><br><span class="line">        len_ = len_ - <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="最长的没有重复字母的子字符串"><a href="#最长的没有重复字母的子字符串" class="headerlink" title="最长的没有重复字母的子字符串"></a>最长的没有重复字母的子字符串</h2><p>给一个字符串，找出长度最长的且没有重复字符的子字符串，如：<code>abcabcbb</code>-&gt;<code>abc</code>长度是3,<code>bbbbb</code>-&gt;<code>b</code>长度是1,<code>pwwkew</code>-&gt;<code>wke</code>长度是3<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_substring</span><span class="params">(str_)</span>:</span></span><br><span class="line">    tmp_longest_word = &#123;&#125;</span><br><span class="line">    word = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str_:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> word:</span><br><span class="line">            word += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp_longest_word[len(word)] = word</span><br><span class="line">            word = i</span><br><span class="line"></span><br><span class="line">    longest_idx = max(tmp_longest_word.keys())</span><br><span class="line">    <span class="keyword">return</span> tmp_longest_word[longest_idx], longest_idx</span><br></pre></td></tr></table></figure></p><h2 id="将矩阵0元素所在行列置0"><a href="#将矩阵0元素所在行列置0" class="headerlink" title="将矩阵0元素所在行列置0"></a>将矩阵0元素所在行列置0</h2><p>给定一个0、1矩阵，请写一个矩阵转换函数，将所有0所处的行和列所有元素置为0，并分析时间复杂度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 0          0 0 0</span><br><span class="line">1 0 1   --&gt;    0 0 0</span><br><span class="line">1 1 1          1 0 0</span><br></pre></td></tr></table></figure></p><p><strong>Python函数</strong></p><ul><li><p>通过<code>Numpy</code>计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_a_row_col_zero</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">:param a: array</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    i, j = np.where(a==<span class="number">0</span>)</span><br><span class="line">    a[i, :] = <span class="number">0</span></span><br><span class="line">    a[:, j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li><li><p>用内置库计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">lst = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_row_col2zero</span><span class="params">(arr, i, j)</span>:</span></span><br><span class="line">    len_ = len(arr)</span><br><span class="line">    arr[i] = [<span class="number">0</span>] * (len_)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len_):</span><br><span class="line">        arr[idx][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_list</span><span class="params">(l)</span>:</span></span><br><span class="line">    len_ = len(l)</span><br><span class="line">    len_sub = len(l[<span class="number">0</span>])</span><br><span class="line">    copy_ = copy.deepcopy(lst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len_sub):</span><br><span class="line">            <span class="keyword">if</span> lst[i][j] == <span class="number">0</span>:</span><br><span class="line">                change_row_col2zero(copy_, i, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy_</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> transform_list(lst)</span><br></pre></td></tr></table></figure></li></ul><p><strong>时间复杂度</strong></p><ul><li>用<code>Numpy</code>时间复杂度未知</li><li>用内置库，如果矩阵是方阵且行数为n: O(n^3)</li></ul><h2 id="阿姆斯特朗数"><a href="#阿姆斯特朗数" class="headerlink" title="阿姆斯特朗数"></a>阿姆斯特朗数</h2><p>一个n位正整数等于其各位数字的n次方之和,则称该数为阿姆斯特朗数，例如<code>1^3 + 5^3 + 3^3 = 153</code>，写一个函数，计算所有给定范围内的阿姆斯特朗数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">armstrong_number</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="string">"""用户输入范围的armstrong_number</span></span><br><span class="line"><span class="string">    :param args: </span></span><br><span class="line"><span class="string">    :type args: tuple</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 检查用户输入数量</span></span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">3</span>:</span><br><span class="line">        start, end, step = args</span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">2</span>:</span><br><span class="line">        start, end = args</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> len(args) == <span class="number">1</span>:</span><br><span class="line">        end = args[<span class="number">0</span>]</span><br><span class="line">        start, step = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> xrange(start, end, step):</span><br><span class="line">        <span class="comment"># 指数位数和</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 指数</span></span><br><span class="line">        n = len(str(num))</span><br><span class="line"></span><br><span class="line">        temp = num</span><br><span class="line">        <span class="keyword">while</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">            digit = temp % <span class="number">10</span></span><br><span class="line">            sum += digit ** n</span><br><span class="line">            temp //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num == sum:</span><br><span class="line">            <span class="keyword">yield</span> num</span><br></pre></td></tr></table></figure></p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列定义：<code>F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)</code>，例如0,1,1,2,3,5…给一个通用函数，输入数列最大值，得到一系列斐波那契数列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= max:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br></pre></td></tr></table></figure></p><h2 id="任意连续整数阶乘的和"><a href="#任意连续整数阶乘的和" class="headerlink" title="任意连续整数阶乘的和"></a>任意连续整数阶乘的和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, map(<span class="keyword">lambda</span> x: x * x, range(<span class="number">1</span>, n + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure><h2 id="任意连续区间的素数、质数"><a href="#任意连续区间的素数、质数" class="headerlink" title="任意连续区间的素数、质数"></a>任意连续区间的素数、质数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(start, stop)</span>:</span></span><br><span class="line">    <span class="comment"># 要求x大于2并且x在区间[2, x)中没有整除的除数</span></span><br><span class="line">    <span class="keyword">return</span> filter(<span class="keyword">lambda</span> x: x &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> [x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, x) <span class="keyword">if</span> x % i == <span class="number">0</span>],</span><br><span class="line">                  range(start, stop + <span class="number">1</span>))   <span class="comment"># 取出质数,x从range(start,stop) 取的数</span></span><br></pre></td></tr></table></figure><h2 id="字典中最大的value对应的keys"><a href="#字典中最大的value对应的keys" class="headerlink" title="字典中最大的value对应的keys"></a>字典中最大的value对应的keys</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dct_max_val_key</span><span class="params">(dct)</span>:</span></span><br><span class="line">    max_value = max(dct.values())</span><br><span class="line">    keys = [k <span class="keyword">for</span> k, v <span class="keyword">in</span> dct.items() <span class="keyword">if</span> k == max_value]</span><br><span class="line">    <span class="comment"># 最大值对应的key可能有一个或者多个</span></span><br><span class="line">    <span class="keyword">return</span> keys[<span class="number">0</span>] <span class="keyword">if</span> len(keys) == <span class="number">1</span> <span class="keyword">else</span> keys</span><br></pre></td></tr></table></figure><h2 id="字符串最长且相邻元素不相同的子字符串"><a href="#字符串最长且相邻元素不相同的子字符串" class="headerlink" title="字符串最长且相邻元素不相同的子字符串"></a>字符串最长且相邻元素不相同的子字符串</h2><p>找出一个字符串中最长的相邻字符串中不重复的子字符串，并输出字符串的长度。如 11101111，最长是3，子字符串是101。110011 最长是2 子字符串是10 或 01<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_large_sub_str</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""只能找到最长的长度，当有多个值重复的时候不能找到全部最长的子字符串"""</span></span><br><span class="line">    sub_str = <span class="string">''</span></span><br><span class="line">    pre = <span class="keyword">None</span></span><br><span class="line">    dct = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> pre != i:</span><br><span class="line">            sub_str += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dct[len(sub_str)] = sub_str</span><br><span class="line">            sub_str = pre</span><br><span class="line">        pre = i</span><br><span class="line"></span><br><span class="line">    max_key = max(dct.iterkeys())</span><br><span class="line">    <span class="keyword">return</span> max_key, dct[max_key]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_large_sub_str_1</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""能找到重复的长度的子字符串"""</span></span><br><span class="line">    sub_str = <span class="string">''</span></span><br><span class="line">    pre = <span class="keyword">None</span></span><br><span class="line">    dct = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> pre != i:</span><br><span class="line">            sub_str += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dct[sub_str] = len(sub_str)</span><br><span class="line">            sub_str = pre</span><br><span class="line">        pre = i</span><br><span class="line"></span><br><span class="line">    max_val = max(dct.itervalues())</span><br><span class="line">    keys = [k <span class="keyword">for</span> k, v <span class="keyword">in</span> dct.items() <span class="keyword">if</span> v == max_val]</span><br><span class="line">    <span class="keyword">return</span> max_val, keys[<span class="number">0</span>] <span class="keyword">if</span> len(keys) == <span class="number">1</span> <span class="keyword">else</span> keys</span><br></pre></td></tr></table></figure></p><h2 id="字符串str中的连续最长的数字串"><a href="#字符串str中的连续最长的数字串" class="headerlink" title="字符串str中的连续最长的数字串"></a>字符串str中的连续最长的数字串</h2><p>读入一个字符串str，输出字符串str中的连续最长的数字串。例如：abcd12345ed125ss123456789 输出：123456789<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_longest_int</span><span class="params">(s)</span>:</span></span><br><span class="line">    result_dict = &#123;&#125;</span><br><span class="line">    int_set = set([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>)])</span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> int_set:</span><br><span class="line">            tmp += i</span><br><span class="line">        <span class="keyword">elif</span> tmp:</span><br><span class="line">            result_dict[tmp] = len(tmp)</span><br><span class="line">            tmp = <span class="string">''</span></span><br><span class="line">    <span class="comment"># 防止最后还有一个值</span></span><br><span class="line">    <span class="keyword">if</span> tmp:</span><br><span class="line">        result_dict[tmp] = len(tmp)</span><br><span class="line"></span><br><span class="line">    max_val = max(result_dict.values())</span><br><span class="line">    key = [key <span class="keyword">for</span> key <span class="keyword">in</span> result_dict <span class="keyword">if</span> result_dict[key] == max_val]</span><br><span class="line">    <span class="keyword">return</span> key[<span class="number">0</span>] <span class="keyword">if</span> len(key) == <span class="number">1</span> <span class="keyword">else</span> key</span><br><span class="line"></span><br><span class="line">s = <span class="string">'abcd12345ed125ss123456789'</span></span><br><span class="line"><span class="keyword">print</span> str_longest_int(s)</span><br></pre></td></tr></table></figure></p><h2 id="字符数组最后一个单词长度"><a href="#字符数组最后一个单词长度" class="headerlink" title="字符数组最后一个单词长度"></a>字符数组最后一个单词长度</h2><p>输入：”Hello World “。输出：5<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_word_len</span><span class="params">(s)</span>:</span></span><br><span class="line">    len_ = len(s)</span><br><span class="line">    curr = <span class="number">0</span></span><br><span class="line">    index = <span class="number">-1</span></span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> curr &lt; len_:</span><br><span class="line">        <span class="keyword">if</span> s[index] != <span class="string">' '</span>:</span><br><span class="line">            tmp += s[index]</span><br><span class="line">        <span class="comment"># 避免倒数第一个是' '</span></span><br><span class="line">        <span class="keyword">elif</span> index != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(tmp)</span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        curr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只要一个单词的情况</span></span><br><span class="line">    <span class="keyword">return</span> len(s.strip())</span><br><span class="line"></span><br><span class="line">s = <span class="string">"Hello_World "</span></span><br><span class="line"><span class="keyword">print</span> last_word_len(s)</span><br></pre></td></tr></table></figure></p><h2 id="数组中找指定和"><a href="#数组中找指定和" class="headerlink" title="数组中找指定和"></a>数组中找指定和</h2><p>数组A由1000万个随机正整数(int)组成，设计算法，给定整数n，在A中找出a和 b，使其符合如下等式：n = a + b<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">题目数据量大看似吓人 但是还是要透过现象看本质</span></span><br><span class="line"><span class="string">set用于去重 如果set太大也可以改成bitmap</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_1</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="string">"""标准leetcode的twosum问题"""</span></span><br><span class="line">    mid_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> mid_dict:</span><br><span class="line">            <span class="keyword">return</span> val, mid_dict[val]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid_dict[n - val] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_2</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="string">"""根据问题调整成set格式"""</span></span><br><span class="line">    mid_set = set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> mid_set:</span><br><span class="line">            <span class="keyword">return</span> val, n - val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid_set.add(n - val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"><span class="keyword">print</span> two_sum_1(a, n)</span><br><span class="line"><span class="keyword">print</span> two_sum_2(a, n)</span><br></pre></td></tr></table></figure></p><h2 id="判断重量"><a href="#判断重量" class="headerlink" title="判断重量"></a>判断重量</h2><p>给定两颗钻石的编号g1、g2，编号从1开始，同时给定关系数组vector，其中元素为一些二元组，第一个元素为一次比较中较重的钻石的编号，第二个元素为较轻的钻石的编号。最后给定之前的比较次数n。请返回这两颗钻石的关系，若g1更重返回1，g2更重返回-1，无法判断返回0。输入数据保证合法，不会有矛盾情况出现。输入：2,3,[[1,2],[2,4],[1,3],[4,3]],4 返回:1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">* 根据描述简历一个有向图 在图中找到指定两点之间是否有路径</span></span><br><span class="line"><span class="string">* 钻石编号是顶点，比较关系是边，生成有向图。先做两个顶点是否可达判断，再进行拓扑排序</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span><span class="params">(x, y, l, n)</span>:</span></span><br><span class="line">    <span class="string">"""用递归调用 看是否有大小关系"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> l[i][<span class="number">0</span>] == x:</span><br><span class="line">            <span class="keyword">if</span> l[i][<span class="number">1</span>] == y:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> bigger(l[i][<span class="number">1</span>], y, l, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(g1, g2, p, n)</span>:</span></span><br><span class="line">    <span class="string">"""要经过两次比较 比价g1 g2谁更大"""</span></span><br><span class="line">    tag = bigger(g1, g2, p, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先交换后比较</span></span><br><span class="line">    <span class="keyword">if</span> tag != <span class="number">1</span>:</span><br><span class="line">        tag = bigger(g2, g1, p, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tag == <span class="number">1</span>:</span><br><span class="line">            tag = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> tag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> compare(<span class="number">2</span>, <span class="number">3</span>, [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>]], <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> compare(<span class="number">3</span>, <span class="number">2</span>, [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>]], <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="每隔两个数删除一个数"><a href="#每隔两个数删除一个数" class="headerlink" title="每隔两个数删除一个数"></a>每隔两个数删除一个数</h2><p>有一个整型数组a[n]顺序存放0~n-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。<br>以8个数(n=8)为例:｛0，1，2，3，4，5，6，7｝，0-&gt;1-&gt;2(删除)-&gt;3-&gt;4-&gt;5(删除)-&gt;6-&gt;7-&gt;0(删除)，如此循环直到最后一个数被删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">生成一个循环链表，一个值记录当前索引，当索引能被2整除且不为0时，删除该值，知道链表只剩一个元素</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode[3]:Longest Substring Without Repeating Characters"></a>LeetCode[3]:<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></h2><p>Given a string, find the length of the longest substring without repeating characters.<br>Examples:<br>Given “abcabcbb”, the answer is “abc”, which the length is 3.<br>Given “bbbbb”, the answer is “b”, with the length of 1.<br>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s)</span>:</span></span><br><span class="line">    start = maxLength = <span class="number">0</span></span><br><span class="line">    usedChar = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">            start = usedChar[s[i]] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxLength = max(maxLength, i - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        usedChar[s[i]] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;分享一些平时遇到算法相关的程序，其中包括基础的数据算法，矩阵相关算法等&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://zhongjiajie.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="https://zhongjiajie.github.io/tags/Python/"/>
    
      <category term="基础算法" scheme="https://zhongjiajie.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>sql实现小记</title>
    <link href="https://zhongjiajie.github.io/2017/06/24/sql%E5%AE%9E%E7%8E%B0%E5%B0%8F%E8%AE%B0/"/>
    <id>https://zhongjiajie.github.io/2017/06/24/sql实现小记/</id>
    <published>2017-06-24T09:08:41.000Z</published>
    <updated>2017-12-10T02:32:58.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目及开源学习中经常有些sql需要写，其中一些sql逻辑比较简单，但是另外的一个还是要思考一段时间的，本文就是把这部分需要思考一段时间的sql记录下来，可以与大家分享的同时，也可以避免长期未使用而遗忘。</p><a id="more"></a><h1 id="MySQL部分"><a href="#MySQL部分" class="headerlink" title="MySQL部分"></a>MySQL部分</h1><h2 id="单表自关联"><a href="#单表自关联" class="headerlink" title="单表自关联"></a>单表自关联</h2><h3 id="分组排序累加"><a href="#分组排序累加" class="headerlink" title="分组排序累加"></a>分组排序累加</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp1(</span><br><span class="line">    os_type <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'源系统'</span>,</span><br><span class="line">    hours <span class="built_in">varchar</span>(<span class="number">4</span>) <span class="keyword">comment</span> <span class="string">'时间-小时'</span>,</span><br><span class="line">    count_num <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'数量'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'01'</span>, <span class="number">600</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'02'</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'03'</span>, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'04'</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'05'</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'06'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'01'</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'02'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp1 <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'01'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>求表各个<code>os_type</code>(系统)按照<code>hours</code>(时间)排序，并且累加<code>count_num</code>的值。单表通过<code>os_type</code>自关联，用时间进行过滤，然后再分组。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.os_type</span><br><span class="line">     , t1.hours</span><br><span class="line">     , <span class="keyword">sum</span>(t2.count_num)</span><br><span class="line"><span class="keyword">from</span> tmp1 t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> tmp1 t2</span><br><span class="line">  <span class="keyword">on</span> t1.os_type = t2.os_type</span><br><span class="line"><span class="comment">-- 通过where排除不符合条件的内容</span></span><br><span class="line"><span class="keyword">where</span> t1.hours &gt;= t2.hours</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.os_type, t1.hours</span><br></pre></td></tr></table></figure></p><h2 id="使用临时变量部分"><a href="#使用临时变量部分" class="headerlink" title="使用临时变量部分"></a>使用临时变量部分</h2><p>很多从Oracle转来使用MySQL的同学都会抱怨，很多Oracle内置的函数Mysql都不支持，这部分主要讨论使用MySQL临时变量完成部分Oracle函数的功能。主要实现的函数有三种排序并标序号，<a href="#partition row_number">row_number ()partition over</a>, <a href="#partition rank">rank() partition over</a>, <a href="#partition dense_rank">dense_rank() partition over</a>几个功能。</p><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>首先对将要测试的数据进行建表，运行下面建表及初始化数据的sql脚本<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- drop table if exists employee;</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee (</span><br><span class="line">    empid <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'员工编号'</span>,</span><br><span class="line">    deptid <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'部门编号'</span>,</span><br><span class="line">    salary <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'工资'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">8</span>,<span class="number">50</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">14</span>,<span class="number">50</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">12</span>,<span class="number">20</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">7</span>,<span class="number">40</span>,<span class="number">44500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">20</span>,<span class="number">1900</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">40</span>,<span class="number">6500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">20</span>,<span class="number">4800</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">13</span>,<span class="number">20</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">10</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">30</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">20</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">9</span>,<span class="number">50</span>,<span class="number">7500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">9</span>,<span class="number">50</span>,<span class="number">4500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">6</span>,<span class="number">40</span>,<span class="number">14500</span>);</span><br></pre></td></tr></table></figure></p><p>查看表<code>employee</code>中的数据，<code>select * from employee;</code>可以看到如图：<br><img src="2017-06-24-sql实现小记/employee全部数据.png" alt="employee全部数据"></p><h3 id="三种排序标序号"><a href="#三种排序标序号" class="headerlink" title="三种排序标序号"></a>三种排序标序号</h3><p>这部分主要针对MySQL中没有分组(partition)的排序，即对选择的所有记录进行排序，其中分为简单的标号排序，不跳过排序的并列值，跳过排序的并列值。sql实现难度也从简单到困难，下面对这三种标号的排序进行说明。</p><h4 id="单纯标号排序"><a href="#单纯标号排序" class="headerlink" title="单纯标号排序"></a><span id="单纯标号排序">单纯标号排序</span></h4><p>单纯对工资排序，即使值重复序号也不一样，不会因为值重复就跳过重复的数量。</p><p>他的实现逻辑是编写一个按照要排序的字段(这里是salary字段)的升序后降序子查询t1，这样就能得到按照工资降序的临时子查询表t1。然后和临时变量@rank进行关联，每次在最外层查询select字段的时候，都将临时变量@rank的值加一。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 只按照工资从高到低排名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t1.empid</span><br><span class="line">     , t1.deptid</span><br><span class="line">     , t1.salary</span><br><span class="line">     , @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> empid</span><br><span class="line">         , deptid</span><br><span class="line">         , salary</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> @<span class="keyword">rank</span> := <span class="number">0</span></span><br><span class="line">) t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><p>运行上面的sql会看到下面的结果：<br><img src="2017-06-24-sql实现小记/排序.png" alt="排序"></p><h4 id="排序不跳过并列序号"><a href="#排序不跳过并列序号" class="headerlink" title="排序不跳过并列序号"></a><span id="排序不跳过并列序号">排序不跳过并列序号</span></h4><p>对工资进行排序，工资相同排序相同，有并列排名时不会跳过。在<a href="#单纯标号排序">单纯标号排序</a>的基础上比较每两个相邻的salary的值，当连续的salary相同时排名相同。</p><p>先按照要排序的字段(salary)进行升序或降序，生成一个临时表t1，然后和临时变量<code>@rank</code>(记录当前排名)，<code>@pre_salary</code>(记录上一条记录salary的值)进行关联。在最外层的查询中，表达式<code>@pre_salary != (@pre_salary := salary)</code>是判断当前的salary和<code>@pre_salary</code>是否相等，当两个值相等，是表达式为0，反之为1。所以外层查询选择的第四个字段相等于<code>@rank = @rank + (0 or 1)</code>，这样就能实现当salary相同时排名相同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 对工资进行排序，工资相同排序相同，但不会跳过排名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t1.empid</span><br><span class="line">     , t1.deptid</span><br><span class="line">     , t1.salary</span><br><span class="line">     <span class="comment">-- @rank = @rank + (0 or 1) 如果表达式@pre_salary != (@pre_salary := salary)为True就是1 否则就是0</span></span><br><span class="line">     , @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + (@pre_salary != (@pre_salary := salary)) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> empid</span><br><span class="line">         , deptid</span><br><span class="line">         , salary</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- @rank记录当前的排名 @pre_salary记录salary的上一个值</span></span><br><span class="line">    <span class="keyword">select</span> @<span class="keyword">rank</span> := <span class="number">0</span></span><br><span class="line">         , @pre_salary := <span class="number">-1</span></span><br><span class="line">) t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><p>运行上面的sql会看到下面的结果：<br><img src="2017-06-24-sql实现小记/排序_重复不跳过序号.png" alt="排序_重复不跳过序号"></p><h4 id="排序跳过并列序号"><a href="#排序跳过并列序号" class="headerlink" title="排序跳过并列序号"></a><span id="排序跳过并列序号">排序跳过并列序号</span></h4><p>对工资进行排序，工资相同排序相同，有并列排名时会跳过。排序跳过并列序号是<a href="#排序不跳过并列序号">排序不跳过并列序号</a>的升级版，其难点是要比较两个连续salary是否相等的同时，记录连续salary出现的次数<code>@skip_num</code>。当两个连续salary不相等的时候，<code>@rank</code>的值除了要加一外，还要加上<code>@skip_num</code>的值。</p><p>先生成按照salary降序的临时表t1，临时变量<code>@rank</code>用于计算当前排名，<code>@skip_num</code>用于记录连续相同salary的次数，<code>@pre_salary_1</code>和<code>@pre_salary_2</code>均用于判断当前记录salary和前一条记录的salary是否相等，前者为<code>@rank</code>服务，后者为<code>@skip_num</code>服务。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 对工资进行排序，工资相同排序相同，有并列排名时会跳过</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t3.empid</span><br><span class="line">     , t3.deptid</span><br><span class="line">     , t3.salary</span><br><span class="line">     , t3.rank</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> t1.empid</span><br><span class="line">       , t1.deptid</span><br><span class="line">       , t1.salary</span><br><span class="line">       <span class="comment">-- 当前值和之前的值一样，即@pre_salary_1 = (@pre_salary_1 := salary)时 取之前的排名@rank 不一样时取当前排名@rank+1+之前跳过的排名@skip_num</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_salary_1 = (@pre_salary_1 := salary), @<span class="keyword">rank</span>, @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span> + @skip_num</span><br><span class="line">            ) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line">       <span class="comment">-- @skip_num保存同一排名出现的次数 @pre_salary_2 = (@pre_salary_2 := salary)是就说明同一排名出现一次</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_salary_2 = (@pre_salary_2 := salary), @skip_num := @skip_num + <span class="number">1</span>, @skip_num := <span class="number">0</span></span><br><span class="line">            ) <span class="keyword">as</span> _skip_num</span><br><span class="line">  <span class="keyword">from</span> </span><br><span class="line">  (</span><br><span class="line">      <span class="keyword">select</span> empid</span><br><span class="line">           , deptid</span><br><span class="line">           , salary</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">  ) t1</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- @rank记录当前的排名 @pre_salary_1和@pre_salary_2记录salary的前一个值 @pre_salary_1用于计算排名是否增加 @pre_salary_2是中间变量确定排名跳过的数量，即@skip_num</span></span><br><span class="line">      <span class="keyword">select</span> @<span class="keyword">rank</span> := <span class="number">0</span></span><br><span class="line">           , @pre_salary_1 := <span class="number">-1</span></span><br><span class="line">           , @pre_salary_2 := <span class="number">-1</span></span><br><span class="line">           , @skip_num := <span class="number">0</span></span><br><span class="line">  ) t2</span><br><span class="line">) t3</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><p>运行上面的sql会看到下面的结果：<br><img src="2017-06-24-sql实现小记/排序_重复跳过序号.png" alt="排序_重复跳过序号"></p><h3 id="实现oracle相关分析函数功能"><a href="#实现oracle相关分析函数功能" class="headerlink" title="实现oracle相关分析函数功能"></a>实现oracle相关分析函数功能</h3><p>这部分主要实现了Oracle相关的分析函数，包括<a href="#partition row_number">row_number</a>, <a href="#partition rank">rank</a>, <a href="#partition dense_rank">dense_rank</a>三个分析函数。</p><h4 id="partition-row-number"><a href="#partition-row-number" class="headerlink" title="partition row_number"></a><span id="partition row_number">partition row_number</span></h4><p>实现Oracle的row_number() partition over方法，要达到的目的是先对源数据按其中一个字段(deptid)进行分组，再在分组中按照另一个字段(salary)升序或降序排序，并进行标号。</p><p>其实现逻辑是，生成一张按照deptid和salary排序的临时表，然后和临时变量<code>@pre_dept</code>和<code>@rank</code>进行关联，其中<code>@pre_dept</code>表示前一条记录部门的值，<code>@rank</code>表示排名。主要的实现在外层查询的<code>if (@pre_dept = (@pre_dept := deptid), @rank := @rank + 1, @rank := 1)</code>中，如果当前deptid和前一条记录的deptid相同时，说明是在同一个deptid的分组中，排名<code>@rank</code>就增加1；如果当前的deptid和前一条记录的deptid不相同，说明deptid分组已经变化了，排名<code>@rank</code>要重新从1开始计算，所以<code>@rank:=1</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Oracle row_number方法</span></span><br><span class="line"><span class="comment">-- 按照部门分组 每组进行排序</span></span><br><span class="line"><span class="comment">-- 排序逻辑 按工资高低排序 同样工资不同顺序 </span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t1.empid</span><br><span class="line">     , t1.deptid</span><br><span class="line">     , t1.salary</span><br><span class="line">     <span class="comment">-- 如果当前deptid(即@pre_dept := deptid) != 之前的deptid(即@pre_dept) 就令当前排序初始化为1(即@rank := 1); </span></span><br><span class="line">     <span class="comment">-- 如果等于之前的deptid 就在原来的排序上加一(即@rank := @rank + 1)</span></span><br><span class="line">     , <span class="keyword">if</span> (</span><br><span class="line">            @pre_dept = (@pre_dept := deptid), @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span>, @<span class="keyword">rank</span> := <span class="number">1</span></span><br><span class="line">          ) <span class="keyword">as</span> _row_number</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 第一步 通过这里控制 以deptid分组 以salary降序</span></span><br><span class="line">    <span class="keyword">select</span> empid</span><br><span class="line">         , deptid</span><br><span class="line">         , salary</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> deptid, salary <span class="keyword">desc</span></span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 此处要选一个异常值(不会在数据中出现的值) 尽量别用null 因为null有陷阱</span></span><br><span class="line">    <span class="keyword">select</span> @pre_dept := <span class="number">-1</span></span><br><span class="line">         , @<span class="keyword">rank</span> := <span class="number">-1</span></span><br><span class="line">) t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><p>运行上面的sql会看到下面的结果：<br><img src="2017-06-24-sql实现小记/row_number_partition_over.png" alt="row_number_partition_over"></p><h4 id="partition-rank"><a href="#partition-rank" class="headerlink" title="partition rank"></a><span id="partition rank">partition rank</span></h4><p>实现Oracle的rank() partition over方法，是<a href="#partition row_number">row_number</a>的升级版。要达到的目的是先对源数据按其中一个字段(deptid)进行分组，再在分组中按照另一个字段(salary)升序或降序排序，并进行排序，此时的排序允许有并列序号，但是不会跳过并列序号的次数。</p><p>最外层查询只是为了选择<code>@pre_salary</code>变量的值，主要逻辑集中在次外层查询。首先在employee表中按照部门和工资排序，得到子查询t1，再和<code>@pre_dept</code>(前一条记录的部门), <code>@rank</code>(排名), <code>@pre_salary</code>(前一条记录的工资)关联。在次外层查询中，满足当前部门(deptid)和前一条记录的部门(<code>@pre_salary</code>)相等，并且当前记录工资(salary)和前一条记录工资(<code>@pre_salary</code>)相等时，说明是同一个部门并且工资相同，所以排序(<code>@rank</code>)值不变；仅是部门相等但是工资不等，则说明同一部门但是工资不同，所以<code>@rank + 1</code>；回到sql次外层查询中最外层的if条件，当前部门和前一条记录的部门不相等时，则部门变了，排序要重新开始，所以<code>@rank := 1</code>。注意次外层查询中，单独<code>@pre_salary := salary</code>进行赋值，防止当外层if条件不满足时，在内层sql写<code>@pre_salary = (@pre_salary := salary)</code>不能更新<code>@pre_salary</code>的值。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 实现Oracle的rank() partition over方法</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t3.empid</span><br><span class="line">     , t3.deptid</span><br><span class="line">     , t3.salary</span><br><span class="line">     , t3._rank_over</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> t1.empid</span><br><span class="line">       , t1.deptid</span><br><span class="line">       , t1.salary</span><br><span class="line">       <span class="comment">-- 如果当前deptid(即@pre_dept := deptid) != 之前的deptid(即@pre_dept) 就令当前排序初始化为1(即@rank := 1); </span></span><br><span class="line">       <span class="comment">-- 如果等于之前的deptid 就在原来的排序上加一(即@rank := @rank + 1)</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_dept = (@pre_dept := deptid)</span><br><span class="line">              <span class="comment">-- 如果部门相等 比较同部门的工资是否相等</span></span><br><span class="line">              , <span class="keyword">if</span> (</span><br><span class="line">                     @pre_salary = salary, @<span class="keyword">rank</span>, @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span></span><br><span class="line">                   )</span><br><span class="line">              , @<span class="keyword">rank</span> := <span class="number">1</span></span><br><span class="line">            ) <span class="keyword">as</span> _rank_over</span><br><span class="line">       <span class="comment">-- 单独保存本次salary的值 放在@pre_dept = (@pre_dept := deptid)里面会因为条件不一样导致结果不同</span></span><br><span class="line">       , @pre_salary := salary</span><br><span class="line">  <span class="keyword">from</span> </span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 第一步 通过这里控制 以deptid分组 以salary降序</span></span><br><span class="line">      <span class="keyword">select</span> empid</span><br><span class="line">           , deptid</span><br><span class="line">           , salary</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> deptid, salary <span class="keyword">desc</span></span><br><span class="line">  ) t1</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 此处要选一个异常值(不会在数据中出现的值) 尽量别用null 因为null有陷阱</span></span><br><span class="line">      <span class="keyword">select</span> @pre_dept := <span class="number">-1</span></span><br><span class="line">           , @<span class="keyword">rank</span> := <span class="number">-1</span></span><br><span class="line">           , @pre_salary := <span class="number">-1</span></span><br><span class="line">  ) t2</span><br><span class="line">) t3</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><p>运行上面的sql会看到下面的结果：<br><img src="2017-06-24-sql实现小记/rank_partition_oreder.png" alt="rank_partition_oreder"></p><h4 id="partition-dense-rank"><a href="#partition-dense-rank" class="headerlink" title="partition dense_rank"></a><span id="partition dense_rank">partition dense_rank</span></h4><p>实现Oracle的dense_rank() partition over方法，是<a href="#partition rank">rank</a>方法的升级版。在rank方法的基础上，如果有重复的序号，要跳过重复的次数。</p><p>先按照部门和工资排序，生成子查询t1。和临时变量<code>@pre_dept</code>(上一条记录部门的值)，<code>@rank</code>(当前数据排名)，<code>@pre_salary</code>(上一条记录工资的值)，<code>@skip_num</code>(该部门分组该排名需要跳过的值)进行关联。其中排名实现在<a href="#partition rank">rank</a>方法上加上<code>@skip_num</code>值，所以剩下的问题是确定<code>@skip_num</code>的值。若当前工资的值和上一条记录中工资的值相等，<code>@skip_num</code>的值就加一，反之<code>@skip_num</code>均赋值为0<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- oracle dense_rank() over 方法</span></span><br><span class="line"><span class="comment">-------------------------------------------------------</span></span><br><span class="line"><span class="keyword">select</span> t3.empid</span><br><span class="line">     , t3.deptid</span><br><span class="line">     , t3.salary</span><br><span class="line">     , t3._dense_rank_over</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> t1.empid</span><br><span class="line">       , t1.deptid</span><br><span class="line">       , t1.salary</span><br><span class="line">       <span class="comment">-- 如果当前deptid(即@pre_dept := deptid) != 之前的deptid(即@pre_dept) 就令当前排序初始化为1(即@rank := 1); </span></span><br><span class="line">       <span class="comment">-- 如果等于之前的deptid 就在原来的排序上加一(即@rank := @rank + 1)</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_dept = (@pre_dept := deptid)</span><br><span class="line">              <span class="comment">-- 如果部门相等 比较同部门的工资是否相等</span></span><br><span class="line">              , <span class="keyword">if</span> (</span><br><span class="line">                     @pre_salary = salary, @<span class="keyword">rank</span>, @<span class="keyword">rank</span> := @<span class="keyword">rank</span> + <span class="number">1</span> + @skip_num</span><br><span class="line">                   )</span><br><span class="line">              , @<span class="keyword">rank</span> := <span class="number">1</span></span><br><span class="line">            ) <span class="keyword">as</span> _dense_rank_over</span><br><span class="line">       <span class="comment">-- 单独保存本次salary的值 放在@pre_dept = (@pre_dept := deptid)里面会因为条件不一样导致结果不同</span></span><br><span class="line">       , <span class="keyword">if</span> (</span><br><span class="line">              @pre_salary = salary, @skip_num := @skip_num + <span class="number">1</span>, @skip_num := <span class="number">0</span></span><br><span class="line">            ) <span class="keyword">as</span> _skip_num</span><br><span class="line">       , @pre_salary := salary</span><br><span class="line">  <span class="keyword">from</span> </span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 第一步 通过这里控制 以deptid分组 以salary降序</span></span><br><span class="line">      <span class="keyword">select</span> empid</span><br><span class="line">           , deptid</span><br><span class="line">           , salary</span><br><span class="line">      <span class="keyword">from</span> employee</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> deptid, salary <span class="keyword">desc</span></span><br><span class="line">  ) t1</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">  (</span><br><span class="line">      <span class="comment">-- 此处要选一个异常值(不会在数据中出现的值) 尽量别用null 因为null有陷阱</span></span><br><span class="line">      <span class="keyword">select</span> @pre_dept := <span class="number">-1</span></span><br><span class="line">           , @<span class="keyword">rank</span> := <span class="number">-1</span></span><br><span class="line">           , @pre_salary := <span class="number">-1</span></span><br><span class="line">           , @skip_num := <span class="number">0</span></span><br><span class="line">  ) t2</span><br><span class="line">) t3</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><p>运行上面的sql会看到下面的结果：<br><img src="2017-06-24-sql实现小记/dense_rank_partition_order.png" alt="dense_rank_partition_order"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目及开源学习中经常有些sql需要写，其中一些sql逻辑比较简单，但是另外的一个还是要思考一段时间的，本文就是把这部分需要思考一段时间的sql记录下来，可以与大家分享的同时，也可以避免长期未使用而遗忘。&lt;/p&gt;
    
    </summary>
    
      <category term="SQL" scheme="https://zhongjiajie.github.io/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://zhongjiajie.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>mysql_schedule_backup定时备份mysql工具</title>
    <link href="https://zhongjiajie.github.io/2017/06/12/mysql-schedule-backup%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDmysql%E5%B7%A5%E5%85%B7/"/>
    <id>https://zhongjiajie.github.io/2017/06/12/mysql-schedule-backup定时备份mysql工具/</id>
    <published>2017-06-12T12:22:25.000Z</published>
    <updated>2018-04-01T06:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://github.com/zhongjiajie/mysql_schedule_backup" target="_blank" rel="noopener">mysql_schedule_backup</a>是定时、全量备份指定mysql数据库的程序。可设置是否压缩备份文件、备份文件保留的天数。<br>使用场景是简单的备份逻辑，通过<a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">schedule</a>就能满足的备份逻辑，没有DAG流程。</p><a id="more"></a> <h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><ul><li>schedule==0.4.2</li></ul><h2 id="How-to-run"><a href="#How-to-run" class="headerlink" title="How to run"></a>How to run</h2><ul><li><p>先安装schedule</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install schedule</span><br></pre></td></tr></table></figure></li><li><p>根据demo配置<code>conf.py</code>中相关的备份信息</p></li><li>修改<code>mysql_schedule_backup.py</code>文件中<code>schedule.every().day.at(&quot;06:00&quot;).do(backup_mysql, bacup_conf)</code>为你的业务时间</li><li>在mysql_schedule_backup目录下运行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python mysql_schedule_backup.py</span><br></pre></td></tr></table></figure></li></ul><h2 id="备份结果"><a href="#备份结果" class="headerlink" title="备份结果"></a>备份结果</h2><ul><li>备份是文件夹或者压缩文件，以备份时间为名称</li><li>文件夹（压缩文件）里面分为<code>*.sql</code>和<code>*.json</code>两类文件，其中<code>conf.json</code>为备份的配置文件，<code>*.sql</code>为备份的主文件，以<code>datetime_database.sql</code>方式命名</li><li>最终的备份样例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─20170611</span><br><span class="line">     ├─20170611_sakila.sql</span><br><span class="line">     ├─20170611_tmp.sql</span><br><span class="line">     ├─20170611_world.sql</span><br><span class="line">     └─conf.json</span><br></pre></td></tr></table></figure></li></ul><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>使用<a href="https://github.com/dbader/schedule" target="_blank" rel="noopener">schedule</a>支持定时备份</li><li>使用配置文件<code>conf.py</code>统一除了备份时间外的配置备份信息（schedule的定时计划比较复杂，没有放置到配置文件<code>conf.py</code>中，而是放在主程序<code>mysql_schedule_backup.py</code>）</li><li>支持多个数据库备份</li><li>支持压缩备份文件</li><li>支持设置备份文件保留时间</li><li>备份文件中包含<code>mysql_schedule_backup</code>运行的配置信息</li></ul><h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─mysql_schedule_backup</span><br><span class="line">     ├─conf.py</span><br><span class="line">     ├─mysql_schedule_backup.py</span><br><span class="line">     └─requirements.txt</span><br></pre></td></tr></table></figure><ul><li><code>requirements.txt</code>:项目的requirements列表</li><li><p><code>mysql_schedule_backup.py</code>:是备份运行的主程序，其中<code>backup_mysql</code>函数是与配置文件<code>conf.py</code>交互的主函数。如果定制配置文件的样式可以对<code>backup_mysql</code>函数进行相应的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    SLEEP_TIME = <span class="number">30</span></span><br><span class="line">    <span class="comment"># 测试定时运行程序 每分钟运行一次</span></span><br><span class="line">    <span class="comment"># schedule.every().minutes.do(backup_mysql)</span></span><br><span class="line">    <span class="comment"># 每天固定时间运行程序</span></span><br><span class="line">    schedule.every().day.at(<span class="string">"06:00"</span>).do(backup_mysql)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        schedule.run_pending()</span><br><span class="line">        time.sleep(SLEEP_TIME)</span><br></pre></td></tr></table></figure></li><li><p><code>conf.py</code>:mysql_schedule_backup是定时的配置文件，可配置内容包括备份存放路径、备份保留时间、备份是否压缩、备份的数据库及表（支持多个库备份）。一般的备份文件如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">job = &#123;</span><br><span class="line">    <span class="string">"setting"</span>: &#123;</span><br><span class="line">        <span class="comment"># 备份的根目录</span></span><br><span class="line">        <span class="string">"root"</span>: <span class="string">"F:/mysql_schedule_backup"</span>,</span><br><span class="line">        <span class="comment"># 备份保持的时间</span></span><br><span class="line">        <span class="string">"keep_day"</span>: <span class="number">60</span>,</span><br><span class="line">        <span class="comment"># 是否压缩备份</span></span><br><span class="line">        <span class="string">"is_zip"</span>: <span class="string">"true"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"db_connection"</span>: [</span><br><span class="line">        <span class="comment"># 第一个要备份的库</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"usr"</span>: <span class="string">"root"</span>,</span><br><span class="line">            <span class="string">"pwd"</span>: <span class="string">"mysql"</span>,</span><br><span class="line">            <span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">            <span class="string">"db_and_table"</span>: &#123;</span><br><span class="line">                <span class="comment"># "backup_database": ["backup_table_1", "backup_table_2", ...]</span></span><br><span class="line">                <span class="string">"tmp"</span>: [</span><br><span class="line">                    <span class="string">"tb1"</span>,</span><br><span class="line">                    <span class="string">"tb2"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="comment"># "backup_database": ["*"]   # *默认全库备份</span></span><br><span class="line">                <span class="string">"world"</span>: [</span><br><span class="line">                    <span class="string">"*"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="comment"># 第二个要备份的库</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"usr"</span>: <span class="string">"root"</span>,</span><br><span class="line">            <span class="string">"pwd"</span>: <span class="string">"mysql"</span>,</span><br><span class="line">            <span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"port"</span>: <span class="string">"3306"</span>,</span><br><span class="line">            <span class="string">"db_and_table"</span>: &#123;</span><br><span class="line">                <span class="comment"># "backup_database": ["backup_table_1", "backup_table_2", ...]</span></span><br><span class="line">                <span class="string">"sakila"</span>: [</span><br><span class="line">                    <span class="string">"*"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="欢迎start"><a href="#欢迎start" class="headerlink" title="欢迎start"></a>欢迎start</h2><p><a href="https://github.com/zhongjiajie/mysql_schedule_backup" target="_blank" rel="noopener">mysql_schedule_backup</a>地址，欢迎start或者fork</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhongjiajie/mysql_schedule_backup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mysql_schedule_backup&lt;/a&gt;是定时、全量备份指定mysql数据库的程序。可设置是否压缩备份文件、备份文件保留的天数。&lt;br&gt;使用场景是简单的备份逻辑，通过&lt;a href=&quot;https://github.com/dbader/schedule&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;schedule&lt;/a&gt;就能满足的备份逻辑，没有DAG流程。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql-backup" scheme="https://zhongjiajie.github.io/categories/mysql-backup/"/>
    
    
      <category term="mysql-backup" scheme="https://zhongjiajie.github.io/tags/mysql-backup/"/>
    
      <category term="MySQL" scheme="https://zhongjiajie.github.io/tags/MySQL/"/>
    
      <category term="Python" scheme="https://zhongjiajie.github.io/tags/Python/"/>
    
      <category term="schedule" scheme="https://zhongjiajie.github.io/tags/schedule/"/>
    
  </entry>
  
</feed>
